AWSTemplateFormatVersion: '2010-09-09'
Description: 'This AWS CloudFormation Template is for Stage Environment API'

#-----------------------------------------------------------------------------
# Parameters
#-----------------------------------------------------------------------------

Parameters:
  ApplicationName:
    Type: String
    Default: "Telematics-Geofence-API"
  EnvType:
    Description: 'Environment: dev,qa,stg,prod'
    Type: String
    Default: stg
    AllowedValues:
    - dev
    - qa
    - stg
    - prod
    ConstraintDescription: must be either 'dev','qa','stg' or 'prod'

#-----------------------------------------------------------------------------
# Mappings
#-----------------------------------------------------------------------------

Mappings:
  dev:
    Layer:
      "VpcId": "vpc-1081ac74"
      "SubnetId1": "subnet-dd038785"
      "SubnetId2": "subnet-bc28a093"
      "PubSubnetId1": "subnet-a04ee1f8"
      "PubSubnetId2": "subnet-191faa33"
      "RDSSecurityGroup": "sg-96aa31ee"
      "DBSubnetGroupName": "dev.rds.subnetgrp"
      
  qa:
    Layer:
      "VpcId": "vpc-9ad5dafe"
      "SubnetId1": "subnet-dd038785"
      "SubnetId2": "subnet-bc28a093"
      "PubSubnetId1": "subnet-a6e062fe"
      "PubSubnetId2": "subnet-2482390e"
      "RDSSecurityGroup": "sg-96aa31ee"
      
  stg:
    Layer:
      "VpcId": "vpc-a29785c6"
      "SubnetId1": "subnet-fdf1bdc0"
      "SubnetId2": "subnet-f54d3383"
      "PubSubnetId1": "subnet-024f3174"
      "PubSubnetId2": "subnet-85f0bcb8"
      "RDSSecurityGroup": "sg-96aa31ee"
      
  prod:
    Layer:
      "VpcId": "vpc-e8ece28c"
      "SubnetId1": "subnet-ca7e0bbc"
      "SubnetId2": "subnet-939d27b9"
      "PubSubnetId1": "subnet-cb7e0bbd"
      "PubSubnetId2": "subnet-0ece4356"
      "RDSSecurityGroup": "sg-96aa31ee"
      
#-----------------------------------------------------------------------------
# Conditions
#-----------------------------------------------------------------------------

Conditions:
  CreateProdResouces: !Or [!Equals [ !Ref EnvType, prod ], !Equals [ !Ref EnvType, stg ]]
  CreateDevResouces: !Or [!Equals [ !Ref EnvType, dev ], !Equals [ !Ref EnvType, qa ]]

Resources:
  #-----------------------------------------------------------------------------
  # IAM All Roles for telematics geofence Api
  #-----------------------------------------------------------------------------
  
  #-----------------------------------------------------------------------------
  # This Role for Appsync
  #-----------------------------------------------------------------------------
  AppsyncRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - appsync.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Description: Role to provide access to appsync
      Policies:
        - PolicyName: EmbeddedInlinePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: 'cloudformation:*'
                Resource: '*'
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
      RoleName:
        'Fn::Join':
            - '-'
            - - Ref: EnvType
              - telematics-geofence-Appsync
  AppsyncInlinePolicy:
    Type: AWS::IAM::Policy
    Properties: 
      PolicyDocument: 
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - 'dynamodb:BatchGetItem'
              - 'dynamodb:ConditionCheckItem'
              - 'dynamodb:PutItem'
              - 'dynamodb:DescribeContributorInsights'
              - 'dynamodb:Scan'
              - 'dynamodb:ListTagsOfResource'
              - 'dynamodb:Query'
              - 'dynamodb:DescribeStream'
              - 'dynamodb:UpdateItem'
              - 'dynamodb:DescribeTimeToLive'
              - 'dynamodb:DescribeGlobalTableSettings'
              - 'dynamodb:PartiQLSelect'
              - 'dynamodb:DescribeTable'
              - 'dynamodb:GetShardIterator'
              - 'dynamodb:DescribeGlobalTable'
              - 'dynamodb:GetItem'
              - 'dynamodb:DescribeContinuousBackups'
              - 'dynamodb:DescribeExport'
              - 'dynamodb:DescribeKinesisStreamingDestination'
              - 'dynamodb:DescribeBackup'
              - 'dynamodb:GetRecords'
              - 'dynamodb:DescribeTableReplicaAutoScaling'
            Resource: '*'
          
          - Effect: Allow
            Action:
              - 'dynamodb:DescribeReservedCapacityOfferings'
              - 'dynamodb:DescribeReservedCapacity'
              - 'dynamodb:DescribeLimits'
              - 'dynamodb:ListStreams'
              - 'iam:TagUser'
              - 'iam:TagRole'
              - 'iam:UntagUser'
              
            Resource: '*'
          
      PolicyName: DynamoInvokeInlinePolicy
      Roles: 
        - !Ref AppsyncRole
  
  
  #-----------------------------------------------------------------------------
  # This is for AWS AppSync GraphQLApi
  #-----------------------------------------------------------------------------
  
  GraphQLApi:
    Type: "AWS::AppSync::GraphQLApi"
    Properties:
      Name: 
        'Fn::Join':
            - '-'
            - - Ref: EnvType
              - appsync.consolidated.api
      AuthenticationType: API_KEY
      Tags: 
        - Key: "EnvType"
          Value: 
            Ref: EnvType         
        - Key: "ResourceType"
          Value: "AppSync"
        - Key: "CostCenter"
          Value: "9038"
        - Key: "Application"
          Value: "Elevate-Telematics"
        - Key: "ITOwner"
          Value: "Sunil Gupta"
        - Key: "Name"
          Value: 
            'Fn::Join':
                - '-'
                - - Ref: EnvType
                  - herc.stg.appsync.consolidated.api
  
  AppSyncApiKey:
    Type: AWS::AppSync::ApiKey
    Properties:
      ApiId: !GetAtt [GraphQLApi, ApiId]
      Description: "equipment details" 


  #-----------------------------------------------------------------------------
  # Datasources begin here
  #-----------------------------------------------------------------------------  

  ExportAlertLambdaDS:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: ExportAlertLambdaDS
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-commerce-ExportAlertsRequest" 

  #-----------------------------------------------------------------------------
  # This DataSource for AlertPreferenceByAccountNumberAndAlertCategoryLambda 
  #-----------------------------------------------------------------------------
  
  AlertPreferenceByAccountNumberAndAlertCategoryLambda:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: AlertPreferenceByAccountNumberAndAlertCategoryLambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-commerce-alertPreference-GetByCategoryAndAccount" 
  
  #-----------------------------------------------------------------------------
  # This DataSource for GetAlertPreferenceByAccountIdAndAlertCategory
  #-----------------------------------------------------------------------------
  
  GetAlertPreferenceByAccountIdAndAlertCategory:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: GetAlertPreferenceByAccountIdAndAlertCategory
      Description: The is backend for GetAlertPreferenceByAccountIdAndAlertCategory Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-commerce-alertPreference-GetByCategoryAndAccount"
  
  #-----------------------------------------------------------------------------
  # This DataSource for DummyDataSource
  #-----------------------------------------------------------------------------
  
  DummyDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: DummyDataSource
      Description: The is backend for EKS Micro Services
      Type: NONE
      ServiceRoleArn: !GetAtt AppsyncRole.Arn

  
  #-----------------------------------------------------------------------------
  # This DataSource for EquipmentSummary_RentalManData_Lambda
  #-----------------------------------------------------------------------------
  EquipmentSummaryRentalManDataLambda:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: EquipmentSummaryRentalManDataLambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-telematics-rentalmandetails" 

  #-----------------------------------------------------------------------------
  # This DataSource for MACOperatorRequestAccessToEquipment
  #-----------------------------------------------------------------------------
  
  MACOperatorRequestAccessToEquipment:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: MACOperatorRequestAccessToEquipment
      Description: The is backend for MACOperatorRequestAccessToEquipment Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-mac-operator-request-access-to-equipment"
  
  #-----------------------------------------------------------------------------
  # This DataSource for EquipmentlistInAccountlambda PendingLambda
  #-----------------------------------------------------------------------------
  
  EquipmentlistInAccountlambda:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: EquipmentlistInAccountlambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-appsync-equipments-in-accounts" 

  #-----------------------------------------------------------------------------
  # This DataSource for GetAccountAutoAddEqStatuslambda
  #-----------------------------------------------------------------------------
  
  GetAccountAutoAddEqStatus:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: GetAccountAutoAddEqStatuslambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-mac-get-account-auto-add-status" 

  #-----------------------------------------------------------------------------
  # This DataSource for GetAlertPreferenceById
  #-----------------------------------------------------------------------------
  
  GetAlertPreferenceById:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: GetAlertPreferenceById
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-commerce-alertPreference-GetById" 

  #-----------------------------------------------------------------------------
  # This DataSource for GetMacEligibleEquipments
  #-----------------------------------------------------------------------------
  GetMacEligibleEquipments:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: GetMacEligibleEquipments
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-telematics-maceligibleequipments" 

  #-----------------------------------------------------------------------------
  # This DataSource for GetGeofenceByAccountLambda
  #-----------------------------------------------------------------------------
  GetGeofenceByAccountLambda:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: GetGeofenceByAccountLambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-appsync-geofence-by-account" 

  #-----------------------------------------------------------------------------
  # This DataSource for GetAllDeliveryPickupsLambda
  #-----------------------------------------------------------------------------
  GetAllDeliveryPickupsLambda:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: GetAllDeliveryPickupsLambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-appsync-delivery-pickups-list"

  #-----------------------------------------------------------------------------
  # This DataSource for EquipmentsByBranchIdLambda
  #-----------------------------------------------------------------------------
  EquipmentsByBranchIdLambda:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: EquipmentsByBranchIdLambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-appsync-equipments-by-branch-id" 

  #-----------------------------------------------------------------------------
  # This DataSource for GetMacEquipments
  #-----------------------------------------------------------------------------
  GetMacEquipmentsMACwrapperLambda:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: GetMacEquipmentsMACwrapperLambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-telematics-macviewcustomequipmentsdetails" 

  #-----------------------------------------------------------------------------
  # This DataSource for MACOperatorRequestAccesstoEquipment
  #-----------------------------------------------------------------------------
  MACOperatorRequestAccesstoEquipment:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: MACOperatorRequestAccesstoEquipment
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-mac-operator-request-access-to-equipment" 

  #-----------------------------------------------------------------------------
  # This DataSource for MacToggleAccountAutoAddEqStatus
  #-----------------------------------------------------------------------------
  MacToggleAccountAutoAddEqStatus:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: MacToggleAccountAutoAddEqStatus
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-mac-toggle-account-auto-add-status" 

  #-----------------------------------------------------------------------------
  # This DataSource for Wrapper_Lambda
  #-----------------------------------------------------------------------------
  WrapperLambda:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: WrapperLambda
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-appsync-api-router" 

  #-----------------------------------------------------------------------------
  # This DataSource for CommerceDs
  #-----------------------------------------------------------------------------
  
  CommerceDs:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId 
      Name: CommerceDs
      Description: The is backend for EKS Micro Services
      Type: HTTP
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      HttpConfig:
        Endpoint: "https://mcstaging.hercrentals.com"

#-----------------------------------------------------------------------------
# This DataSource for MuleEndpoint
#-----------------------------------------------------------------------------
  
  MuleEndpoint:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId 
      Name: MuleEndpoint
      Description: The is backend for EKS Micro Services
      Type: HTTP
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      HttpConfig:
        Endpoint: "https://qa-digital-web-eapi.us-e1.cloudhub.io/"

#-----------------------------------------------------------------------------
# This DataSource for MuleEnView_Alerts2
#-----------------------------------------------------------------------------
  
  ViewAlertstwo:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId 
      Name: View_Alerts2
      Description: The is backend for EKS Micro Services
      Type: HTTP
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      HttpConfig:
        Endpoint: "https://dev-digital-web-eapi.us-e1.cloudhub.io"


  #-----------------------------------------------------------------------------
  # This DataSource for Herc_AppSync_Authorizer
  #-----------------------------------------------------------------------------
  
  HercAppSyncAuthorizerDS:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: HercAppSyncAuthorizerDS
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-appsync-authorizer" 

  #-----------------------------------------------------------------------------
  # This DataSource for TelematicsForGeofenceDS
  #-----------------------------------------------------------------------------
  
  TelematicsForGeofenceDS:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId 
      Name: TelematicsForGeofenceDS
      Description: The is backend for EKS Micro Services
      Type: HTTP
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      HttpConfig:
        Endpoint: "http://acbcfe309ede5499982ecbcda5de6dfa-1518439829.us-east-1.elb.amazonaws.com"

  #-----------------------------------------------------------------------------
  # This DataSource for RetrieveUserDeviceTokens phase-2
  #-----------------------------------------------------------------------------
  
  RetrieveUserDeviceTokensDS:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: RetrieveUserDeviceTokensDS
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-commerce-get-user-devicetoken"

  #-----------------------------------------------------------------------------
  # This DataSource for UserDeviceTokenRegistrationDS
  #-----------------------------------------------------------------------------

  UserDeviceTokenRegistrationDS:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: UserDeviceTokenRegistrationDS
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-commerce-user-devicetoken-registration"

  #-----------------------------------------------------------------------------
  # This DataSource for SaveOrUpdatePreference
  #-----------------------------------------------------------------------------

  SaveOrUpdatePreferenceDS:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: SaveOrUpdatePreferenceDS
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-commerce-alertPreference-SaveOrUpdatePreference"

  #-----------------------------------------------------------------------------
  # This DataSource for SaveEquipmentName
  #-----------------------------------------------------------------------------

  SaveEquipmentNameDS:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: SaveEquipmentNameDS
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-telematics-save-equipment-name"

  #-----------------------------------------------------------------------------
  # This DataSource for SaveEquipmentName
  #-----------------------------------------------------------------------------

  CustomEquipmentNameDS:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: CustomEquipmentNameDS
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-telematics-custom-equipment-name"
  
  #-----------------------------------------------------------------------------
  # This DataSource for ModifyCustomEquipmentNameDS
  #-----------------------------------------------------------------------------

  ModifyCustomEquipmentNameDS:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: ModifyCustomEquipmentNameDS
      Description: The is backend for Lambda Services
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppsyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: "arn:aws:lambda:us-east-1:110972972731:function:stg-telematics-modify-customequipmentname"
  
  #-----------------------------------------------------------------------------
  # Functions Begin from Here
  #-----------------------------------------------------------------------------

  #-----------------------------------------------------------------------------
  # Function for getDeliveryAndPickupFromM2
  #-----------------------------------------------------------------------------
  
  getDeliveryAndPickupFromM2:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: getDeliveryAndPickupFromM2 Function
      FunctionVersion: 2018-05-29
      Name: getDeliveryAndPickupFromM2
      RequestMappingTemplate: |
       {
          "method": "POST",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/graphql",
          "params":{
              "body": {"query":"{\r\n        getDeliveryAndPickupDetails(\r\n        contractType: \"$ctx.args.contractType\"\r\n        contractNumber: \"$ctx.args.contractNumber\"\r\n        contractSequence: \"$ctx.args.contractSequence\"\r\n        accountNumber: \"$ctx.args.accountId\"\r\n        branchNumber: \"$!{ctx.prev.result.branchCode}\"\r\n        ICNumber: \"$ctx.args.equipmentIC\"\r\n    ){\r\n        deliveryPickupDetails {\r\n            ticketNumber\r\n            deliveryInstrcutions\r\n            pickupInstruction\r\n            date\r\n            time\r\n            branchDetails {\r\n                branchname\r\n                branchcode\r\n                branchnumber\r\n                branchtype\r\n                addresslatitude\r\n                addresslongitude\r\n                address\r\n                phone\r\n                city\r\n                state\r\n                country\r\n                zip\r\n                timings\r\n                branchimageurl\r\n            }\r\n            pickupAddress {\r\n                pickupAddressInfo\r\n                pickupAddresslatitude\r\n                pickupAddresslongitude\r\n                pickupPhone\r\n                pickupContact\r\n            }\r\n            jobsiteAddress {\r\n                jobNumber\r\n                jobName\r\n                jobAddress1\r\n                jobAddress2\r\n                jobCity\r\n                jobState\r\n                jobZip\r\n                jobAddresslatitude\r\n                jobAaddresslongitude\r\n                jobPhone\r\n                jobContact\r\n            }\r\n        }\r\n    }\r\n}","variables":{}},
              "headers": {
              #if($ctx.args.divisionCode=="CR" )
              "store":"ca",
              #end
                  "Content-Type": "application/json",
                  "Authorization":"$ctx.stash.authorization"
              }
          }
        }      
      ResponseMappingTemplate: |
        #if($ctx.result.statusCode == 200)
        #set( $deliveryAndPickupData = $util.parseJson($ctx.result.body).data.getDeliveryAndPickupDetails.deliveryPickupDetails ) 
        #end
            {
              "branchCode": "$!{ctx.prev.result.branchCode}",
              "rentalAgreement":  "$!{ctx.prev.result.contractNumber}",
              "equipmentIC":  "$!{ctx.prev.result.equipmentIC}",
              "catClass":  "$!{ctx.prev.result.catClass}",
              "equipmentName":  "$!{ctx.prev.result.equipmentName}",
              "equipmentCustomName":  "$!{ctx.prev.result.equipmentCustomName}",
              "jobSiteNumber":  "$!{ctx.prev.result.jobSiteNumber}",
              "status":  "$!{ctx.prev.result.status}",
              "pickupType":  "$!{ctx.prev.result.pickupType}",
              "scheduledDateTime":  "$!{ctx.prev.result.scheduledDateTime}",
              "deliveryDateTime":   "$!{ctx.prev.result.deliveryDateTime}",
                #if($deliveryAndPickupData.deliveryInstructions)"deliveryInstructions": $util.toJson($deliveryAndPickupData.deliveryInstrcutions),#end
                #if($deliveryAndPickupData.pickupInstruction)"pickupInstruction": $util.toJson($deliveryAndPickupData.pickupInstruction),#end
                
                  "pickupDetails":{
                  "ticketNum":  "$!{deliveryAndPickupData.ticketNumber}",
                  "contractNum":  $!{ctx.args.contractNumber},
                  "contractSeq":  $!{ctx.args.contractSequence},
                  "iCNumber":  "$!{ctx.args.iCNumber}",
                  "comments":   "$!{deliveryAndPickupData.pickupInstruction}",
                  "releasedBy":  "$!{deliveryAndPickupData.releasedBy}",
                  "date":  "$!{deliveryAndPickupData.date}",
                  "time":  "$!{deliveryAndPickupData.time}"
                    },
          
                          "jobSite" : {
                  "jobNumber": "$!{deliveryAndPickupData.jobsiteAddress.jobNumber}",
                  "jobName": "$!{deliveryAndPickupData.jobsiteAddress.jobName}",
                  "jobAddr1": "$!{deliveryAndPickupData.jobsiteAddress.jobAddress1}",
                  "jobAddr2": "$!{deliveryAndPickupData.jobsiteAddress.jobAddress2}",
                  "jobCity": "$!{deliveryAndPickupData.jobsiteAddress.jobCity}",
                  "jobState": "$!{deliveryAndPickupData.jobsiteAddressy.jobState}",
                  "jobZip": "$!{deliveryAndPickupData.jobsiteAddress.jobZip}",
                  "addressLatitude": "$!{deliveryAndPickupData.jobsiteAddress.jobAddresslatitude}",
                  "addressLongitude": "$!{deliveryAndPickupData.jobsiteAddress.jobAaddresslongitude}",
                  "jobPhone": "$!{deliveryAndPickupData.jobsiteAddress.jobPhone}",
                  "contactName": "$!{deliveryAndPickupData.jobsiteAddress.jobContact}"    
                          },
              
              "driverInfo": {
                "driverId": "$!{ctx.prev.result.driverInfo.driverId}",
                "firstName":  "$!{ctx.prev.result.driverInfo.firstName}",
                "lastName":  "$!{ctx.prev.result.driverInfo.lastName}",
                "phone":  "$!{ctx.prev.result.driverInfo.phone}",
                "truckType":  "$!{ctx.prev.result.driverInfo.truckType}",
                "isHauler":  "$!{ctx.prev.result.driverInfo.hauler}"
              },
              "equipmentInfo": {
                  "equipmentId": "$!{ctx.prev.result.equipmentInfo.equipmentId}",
                  "equipmentNumber": "$!{ctx.prev.result.equipmentInfo.equipmentNumber}",
                  "make": "$!{ctx.prev.result.equipmentDetails.make}",
                  "model": "$!{ctx.prev.result.equipmentDetails.model}",
                  "serialNumber": "$!{ctx.prev.result.equipmentDetails.serialNumber}",
                  "catClass": "$!{ctx.prev.result.equipmentInfo.catClass}",
                  "quantity": $!{ctx.prev.result.equipmentInfo.quantity},
                  "condition": "$!{ctx.prev.result.equipmentInfo.condition}",
                  "deliveryImages": [
                      #foreach( $image in  $ctx.prev.result.equipmentInfo.images )
                      {
                          "imageUri": "$!{image.imageUri}",
                          "imageName": "$!{image.imageName}",
                          "photoTakenAt": "$!{image.photoTakenAt}",
                          "latLong": "$!{image.latLong}"
                      },
                  #end
                  ]
              },
              "description": #if($ctx.prev.result.description) "$ctx.prev.result.description.replace('"','\"')" #else "" #end ,
              "servingBranch": 
              {
                  "address": "$!{deliveryAndPickupData.branchDetails.address}",
                  "addressLatitude": "$!{deliveryAndPickupData.branchDetails.addresslatitude}",
                  "addressLongitude": "$!{deliveryAndPickupData.branchDetails.addresslongitude}",
                  "branchName": "$!{deliveryAndPickupData.branchDetails.branchname}",
                  "branchNumber": "$!{deliveryAndPickupData.branchDetails.branchnumber}",
                  "branchType": "$!{deliveryAndPickupData.branchDetails.branchtype}",
                  "city": "$!{deliveryAndPickupData.branchDetails.city}",
                  "country": "$!{deliveryAndPickupData.branchDetails.country}",
                  "phone": "$!{deliveryAndPickupData.branchDetails.phone}",
                  "state": "$!{deliveryAndPickupData.branchDetails.state}",
                  "zip":"$!{deliveryAndPickupData.branchDetails.zip}",
                  "image":"$!{deliveryAndPickupData.branchDetails.branchimageurl}"

            },
            "pickupAddress":
            {
              "pickupAddressInfo": "$!{deliveryAndPickupData.pickupAddress.pickupAddressInfo}",
              "pickupAddresslatitude": "$!{deliveryAndPickupData.pickupAddress.pickupAddresslatitude}",
              "pickupAddresslongitude": "$!{deliveryAndPickupData.pickupAddress.pickupAddresslongitude}",
              "pickupPhone": "$!{deliveryAndPickupData.pickupAddress.pickupPhone}",
              "pickupContact":"$!{deliveryAndPickupData.pickupAddress.pickupContact}"
            }
            }

  #-----------------------------------------------------------------------------
  # Function for GetAllDeliveryPickupsLambdaFunction
  #-----------------------------------------------------------------------------
  
  GetAllDeliveryPickupsLambdaFunction: 
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt GetAllDeliveryPickupsLambda.Name
      Description: GetAllDeliveryPickupsLambdaFunction
      FunctionVersion: 2018-05-29
      Name: GetAllDeliveryPickupsLambdaFunction
      RequestMappingTemplate: |
        #set( $rqBody = {} )
        #set( $body = {} )
        #set( $headers = {} )

        $util.qr($body.put("teleApiPath","/deliveries-pickups/filter"))
        $util.qr($body.put("contractType","Open,Closed,Overdue"))
        $util.qr($body.put("page","$ctx.args.page"))
        $util.qr($body.put("pageSize","$ctx.args.pageSize"))
        $util.qr($body.put("companyCode","$ctx.args.divisionCode"))
        $util.qr($body.put("customerNum","$ctx.args.accountId"))
        $util.qr($body.put("pickupType","$ctx.args.pickupType"))

        #if( $context.args.divisionCode =="US" )
        $util.qr($body.put("divisionCode","HG"))
        #end
        #if( $context.args.divisionCode =="CAN" )
        $util.qr($body.put("divisionCode","CR"))
        #end

        $util.qr($headers.put("guid","123123"))
        $util.qr($headers.put("activationId","$ctx.request.headers.x-amzn-requestid"))
        $util.qr($headers.put("accesstoken","121323"))

        $util.qr($rqBody.put("body",$body))
        $util.qr($rqBody.put("headers",$headers))


        {
          "version" : "2017-02-28",
          "operation": "Invoke",
          "payload": $util.toJson($rqBody)
        }
      
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 200 )
        $util.toJson($context.result.body.otgStatusResponses)
        #else
          $util.error("$ctx.result.message", "$ctx.result.statusCode")
        #end

#-----------------------------------------------------------------------------
  # Function for getBranchDetailsFromM2
  #-----------------------------------------------------------------------------
  
  getBranchDetailsFromM2Function: 
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: getBranchDetailsFromM2Function
      FunctionVersion: 2018-05-29
      Name: getBranchDetailsFromM2Function
      RequestMappingTemplate: |
        #set( $jobNumber = $ctx.prev.result.rentalInfo.jobsiteNumber)
        #set( $accountId = $ctx.prev.result.rentalInfo.accountNumber )
        #set( $branchNumber = $ctx.prev.result.equipmentBranchInfoResponse.branchCode )




        {
        "method": "POST",
        ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
        "resourcePath": "/graphql",
        "params":{
        "body":{"query":"{ getJobsite(accountNumber: \"$accountId\", jobNumber:\"$jobNumber\") {\r\n jobSites{\r\n jobNumber\r\n jobName\r\n jobAddr1\r\n jobAddr2\r\n jobCity\r\n jobLoc\r\n jobState\r\n jobZip\r\n jobPhone\r\n contactName\r\n }\r\n \r\n } \r\n \r\n getBranchDetailsByBranchNumber(branchNumber:[$branchNumber]) \r\n { \r\n branchDetails\r\n { \r\n branchname \r\n branchcode \r\n branchnumber \r\n branchtype \r\n addresslatitude\r\n addresslongitude \r\n address \r\n phone \r\n city \r\n state \r\n country \r\n zip \r\n timings \r\n branchimageurl \r\n } \r\n } \r\n \r\n}","variables":{}},
        ##"body":{"query":"{ \r\n \r\n getBranchDetailsByBranchNumber(branchNumber:[$branchNumber]) \r\n { \r\n branchDetails\r\n { \r\n branchname \r\n branchcode \r\n branchnumber \r\n branchtype \r\n addresslatitude\r\n addresslongitude \r\n address \r\n phone \r\n city \r\n state \r\n country \r\n zip \r\n timings \r\n branchimageurl \r\n } \r\n } \r\n \r\n}","variables":{}},



        "headers":{
        #if($ctx.args.division == "CR")
        "store":"ca",
        #end
        "Content-Type": "application/json",
        "Authorization": "$ctx.stash.authorization",
        "x-activationid":"$!{ctx.stash.x-activationid}",
        "guid":"$!{ctx.stash.guid}",
        "access-token":"$!{ctx.stash.access-token}"
        }
        }
        }
      
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        $util.qr($ctx.prev.result.put("jobSite",$util.parseJson($ctx.result.body).data.getJobsite.jobSites))
        $util.qr($ctx.prev.result.put("branch",$util.parseJson($context.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0]))
        $util.qr($ctx.prev.result.branch.put("streetAddress",$ctx.prev.result.equipmentBranchInfoResponse.streetAddress))
        $util.toJson($ctx.prev.result)

#-----------------------------------------------------------------------------
  # Function for HercAppSyncAuthorizer
  #-----------------------------------------------------------------------------
  
  HercAppSyncAuthorizer:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt HercAppSyncAuthorizerDS.Name
      Description: HercAppSyncAuthorizer Function
      FunctionVersion: 2018-05-29
      Name: HercAppSyncAuthorizerFunction
      RequestMappingTemplate: |
        #set( $headers = {} )
        #set( $body = {} )
        #set( $rqBody = {} )

        $util.qr($headers.put("guid","$!{ctx.request.headers.guid}"))
        $util.qr($headers.put("accesstoken","$!{ctx.request.headers.accesstoken}"))
        $util.qr($headers.put("authorization","$!{ctx.request.headers.authorization}"))
        $util.qr($headers.put("refreshtoken","$!{ctx.request.headers.refreshtoken}"))
        $util.qr($headers.put("customerid","$!{ctx.request.headers.customerid}"))

        $util.qr($body.put("methodName","$!{ctx.info.fieldName}"))

        $util.qr($rqBody.put("headers",$headers))
        $util.qr($rqBody.put("body",$body))


        $util.qr($context.stash.put("x-activationid",$ctx.request.headers.x-amzn-trace-id))
        $util.qr($context.stash.put("guid",$ctx.request.headers.guid))
        $util.qr($context.stash.put("access-token",$ctx.request.headers.accesstoken))
        $util.qr($context.stash.put("authorization",$ctx.request.headers.Authorization))
        $util.qr($context.stash.put("customerId",$ctx.request.headers.customerid))
        $util.qr($util.http.addResponseHeader("x-activationid",$ctx.request.headers.x-amzn-trace-id))
        #if($ctx.args.customerId)
          $util.qr($context.stash.put("customerId",$ctx.args.customerId))
        #end


        {
          "operation": "Invoke",
          "payload": $util.toJson($rqBody)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.body.isAuthorized == true)
          #if( !$util.isNullOrBlank($ctx.result.body.accesstoken))
            $util.qr($ctx.stash.put("access-token",$ctx.result.body.accesstoken))
            $util.qr($util.http.addResponseHeader("accesstoken",$!{ctx.result.body.accesstoken}))
          #end
          #if( !$util.isNullOrBlank($ctx.result.body.Authorization))
            $util.qr($ctx.stash.put("authorization",$ctx.result.body.Authorization))
            $util.qr($util.http.addResponseHeader("authorization",$!{ctx.result.body.authorization}))
          #end
          #if( !$util.isNullOrBlank($ctx.result.body.muleToken))
            $util.qr($ctx.stash.put("mule-token",$ctx.result.body.muleToken))
          #end
          $util.toJson($context.result)
        #else
        $util.error("$ctx.result.body.errorSummary", "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # Function for AddBulkGeofenceFunction
  #-----------------------------------------------------------------------------
  
  AddBulkGeofenceFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: HercAppSyncAuthorizer Function
      FunctionVersion: 2018-05-29
      Name: AddBulkGeofenceFunction
      RequestMappingTemplate: |
        
        #set($index=0)
        #foreach( $item in $ctx.args.geofences )
          #if( $item.divisionCode.trim()=="US")
              #set( $item.divisionCode = "HG" )
          #elseif( $item.divisionCode.trim()=="CAN" )
              #set( $item.divisionCode = "CR" )
          ## #else
          ##        $util.error("Please select US or CAN for geofence - ${item.name}")
          #end
          #if($item.shape.shapeType=="CIRCLE")
            #set($circleCoordinate=[])
            #if($item.shape.coordinate && $item.shape.coordinate.size() ==1 && $item.shape.coordinate[0].size()==1 && $item.shape.coordinate[0][0].size()==2)
            #set($v=$circleCoordinate.add($item.shape.coordinate[0][0][0]))
            #set($v=$circleCoordinate.add($item.shape.coordinate[0][0][1]))
            #elseif($item.shape.coordinate && $item.shape.coordinate.size() ==1 && $item.shape.coordinate[0].size()==1 && $item.shape.coordinate[0][0].size()!=2)
              #set( $circleCoordinate =$item.shape.coordinate[0][0])
            #end
            #set($item.shape.coordinate=$circleCoordinate)
          #end
          #set($index= $index+1)
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences/bulk"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 201 || $ctx.result.statusCode==206)
            ## If response is 200, return the body.
            $ctx.result.body
        #elseif($ctx.result.statusCode==400)
        $util.error("Please Check and Enter Correct Input")
        #elseif($ctx.result.statusCode==404)
            ## If response is not 200, append the response to error block.
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # Function for GetGeofenceByAccountLambdaFunction
  #-----------------------------------------------------------------------------
  
  GetGeofenceByAccountLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt GetGeofenceByAccountLambda.Name
      Description: GetGeofenceByAccountLambdaFunction
      FunctionVersion: 2018-05-29
      Name: GetGeofenceByAccountLambdaFunction
      RequestMappingTemplate: |
        #set( $rqBody = {} )
        #set( $body = {})
        #set( $headers = {} )

        $util.qr($body.put("teleApiPathGeofences","/geofence-api/geofences"))
        $util.qr($body.put("teleApiPathGeofencesSummary","/geofence-api/geofences/summary"))
        $util.qr($body.put("page","$ctx.args.page"))
        $util.qr($body.put("pageSize","$ctx.args.pageSize"))
        $util.qr($body.put("accountId","$ctx.args.accountId"))
        $util.qr($body.put("divisionCode","$ctx.args.divisionCode"))

        #if( $ctx.args.divisionCode == "US" )
        $util.qr($body.put("divisionCode","HG"))
        #elseif( $ctx.args.divisionCode == "CAN" )
        $util.qr($body.put("divisionCode","CR"))
        #end

        #if( $ctx.args.divisionCode == "us" )
        $util.qr($body.put("divisionCode","HG"))
        #elseif( $ctx.args.divisionCode == "can" )
        $util.qr($body.put("divisionCode","CR"))
        #end

        $util.qr($headers.put("guid","$ctx.request.headers.guid"))
        $util.qr($headers.put("activationId","$ctx.request.headers.x-amzn-requestid"))
        $util.qr($headers.put("accesstoken","$ctx.request.headers.activationId"))

        $util.qr($rqBody.put("body",$body))
        $util.qr($rqBody.put("headers",$headers))

        $util.qr($ctx.stash.put("rqBody",$rqBody))
        {
          "version" : "2017-02-28",
          "operation": "Invoke",
          "payload": $util.toJson($rqBody)
        }
      
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if( $ctx.result.statusCode ==200 )
        $util.toJson($context.result.body)
        #else
          $util.error("$ctx.result.message", "$ctx.result.statusCode")

        #end
  #-----------------------------------------------------------------------------
  # This is the appsync Function for CheckRegion
  #-----------------------------------------------------------------------------
  
  CheckRegionFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt DummyDataSource.Name
      Description: CheckRegion Function
      FunctionVersion: 2018-05-29
      Name: CheckRegionFunction
      RequestMappingTemplate: |
        #**
        Make an arbitrary HTTP call when this field is listed in a query selection set.
        The "relativePath" is the resource path relative to the root URL provided when you
        created the HTTP data source. Pass a "params" object to forward headers, body,
        and query parameters to the HTTP endpoint.
        *#

        #if($ctx.args.divisionCode && $util.str.toUpper($ctx.args.divisionCode) == "CAN")
        #set($ctx.args.divisionCode = "CR")
        {}
        #elseif($ctx.args.divisionCode && $util.str.toUpper($ctx.args.divisionCode) == "US")
        #set( $ctx.args.divisionCode = "HG" )
        {}
        #elseif($ctx.args.divisionCode.trim() == "")
        $util.error("DivisionCode cannot be empty")
        {}
        #elseif($ctx.args.divison && $util.str.toUpper($ctx.args.divison) == "CAN")
        #set($ctx.args.divison = "CR")
        {}
        #elseif($ctx.args.divison && $util.str.toUpper($ctx.args.divison) == "US")
        #set( $ctx.args.divison = "HG" )
        {}
        #elseif($ctx.args.division && $util.str.toUpper($ctx.args.division) == "CAN")
        #set( $ctx.args.division = "CR" )
        {}
        #elseif($ctx.args.division && $util.str.toUpper($ctx.args.division) == "US")
        #set( $ctx.args.division = "HG" )
        {}
        #elseif($ctx.args.input.divisionCode && $util.str.toUpper($ctx.args.input.divisionCode) == "US")
        #set( $ctx.args.input.divisionCode = "HG" )
        {}
        #elseif($ctx.args.input.divisionCode && $util.str.toUpper($ctx.args.input.divisionCode) == "CAN")
        #set( $ctx.args.input.divisionCode = "CR" )
        {}
        #elseif($ctx.args.countryCode && $util.str.toUpper($ctx.args.countryCode) == "US")
        #set( $ctx.args.countryCode = "HG" )
        {}
        #elseif($ctx.args.countryCode && $util.str.toUpper($ctx.args.countryCode) == "CAN")
        #set( $ctx.args.countryCode = "CR" )
        {}
        #elseif($ctx.args.input.companyCode && $util.str.toUpper($ctx.args.input.companyCode.trim()) == "US")
        #set( $ctx.args.input.companyCode = "HG" )
        {}
        #elseif($ctx.args.input.companyCode && $util.str.toUpper($ctx.args.input.companyCode.trim()) == "CAN")
        #set( $ctx.args.input.companyCode = "CR" )
        {}
        #elseif($ctx.args.companyCode && $util.str.toUpper($ctx.args.companyCode.trim()) == "US")
        #set( $ctx.args.companyCode = "HG" )
        {}
        #elseif($ctx.args.companyCode && $util.str.toUpper($ctx.args.companyCode.trim()) == "CAN")
        #set( $ctx.args.companyCode = "CR" )
        {}
        #else
        $util.error("Please select either CAN or US as division")
        #end
      ResponseMappingTemplate: |
        $util.toJson($context.result)

      

  #-----------------------------------------------------------------------------
  # This is the appsync Function for CreateGeoFence
  #-----------------------------------------------------------------------------
  
  CreateGeoFenceFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt TelematicsForGeofenceDS.Name
      Description: CreateGeoFence Function
      FunctionVersion: 2018-05-29
      Name: CreateGeoFenceFunction
      RequestMappingTemplate: |
        #**
        Make an arbitrary HTTP call when this field is listed in a query selection set.
        The "relativePath" is the resource path relative to the root URL provided when you
        created the HTTP data source. Pass a "params" object to forward headers, body,
        and query parameters to the HTTP endpoint.
        *#
        #if(!$ctx.args.input.name || $ctx.args.input.name == "")
          $util.error("Name can not be empty, please give this Geofence a name for easy identification.")   
        #end

        ## #if(!$ctx.args.input.totalExits)
        ##  #if($ctx.args.input.totalExits=="")
        ##      #set( $$ctx.args.input.totalExits = 0)
        ##     #end
        ## #end

        #if(!$ctx.args.input.accountId || $ctx.args.input.accountId == "")
          $util.error("Account ID can not be empty.")
        #end

        #if($ctx.args.input.shape.shapeType=="CIRCLE")
          #if($ctx.args.input.shape.coordinate[0].size()==1 )
            #set($var = $util.toJson($ctx.args.input))
          #else
            $util.error("Coordinates do not match for circle")
          #end
        #else
          #if($ctx.args.input.shape.coordinate[0].size()>2)
            #set($var = $util.toJson($ctx.args.input))
          #else
            $util.error("Inappropriate coordinates for the chosen ShapeType")
          #end
        #end
        #set($circleCoordinate=[])
        #if($ctx.args.input.shape.shapeType=="CIRCLE")
        #set($v=$circleCoordinate.add($ctx.args.input.shape.coordinate[0][0][0]))
        #set($v=$circleCoordinate.add($ctx.args.input.shape.coordinate[0][0][1]))
        #set($ctx.args.input.shape.coordinate=$circleCoordinate)
        #end
        #set($var = $util.toJson($ctx.args.input))
        {
          "version": "2018-05-29",
          "method": "POST",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/geofence-api/geofences",
          "params":{
              "body":$var,
              "headers": {
                  "Content-Type": "application/json",
                  ##"Authorization": "$ctx.request.headers.Authorization",
                    "x-activationid":"$ctx.stash.x-activationid",
                    "guid":"$ctx.stash.guid",
                    "access-token":"$ctx.stash.access-token"
              }
          }
        }

      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end

        ## #if($ctx.result.statusCode == 201 && $util.parseJson($ctx.result.body).totalExits=="")
        ##  #set($totalExits =$util.parseJson($ctx.result.body).totalExits)
        ## #else
        ##  #set( $totalExits = $util.parseJson($ctx.result.body).totalExits )
        ## #end

        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 201)

        #if($util.parseJson($ctx.result.body).shape.shapeType=="CIRCLE")
            {
              "geofenceId":"$util.parseJson($ctx.result.body).geofenceId",
              "accountId": "$util.parseJson($ctx.result.body).accountId",
              "name": "$util.parseJson($ctx.result.body).name",
              "divisionCode": "$util.parseJson($ctx.result.body).divisionCode",
              "shape": {
              "radius":$util.parseJson($ctx.result.body).shape.radius,
              "shapeType": "$util.parseJson($ctx.result.body).shape.shapeType",
              "coordinate":
              [[$util.parseJson($ctx.result.body).shape.coordinate]]
              },
              "active": $util.parseJson($ctx.result.body).active,
              "notes": "$util.parseJson($ctx.result.body).notes",
              "equipment": $util.toJson($util.parseJson($ctx.result.body).equipment),
              "autoAddEquipment": $util.parseJson($ctx.result.body).autoAddEquipment,
              "autoAddEquipOfType": "$util.parseJson($ctx.result.body).autoAddEquipOfType",
              "autoAddEquipTypeValues": $util.toJson($util.parseJson($ctx.result.body).autoAddEquipTypeValues),
              "status": #if($util.parseJson($ctx.result.body).status) "$util.parseJson($ctx.result.body).status" #else "ERROR" #end,
              "totalEntrances": $util.parseJson($ctx.result.body).totalEntrances,
              "totalExits":  #if($!util.parseJson($ctx.result.body).totalExits) $!util.parseJson($ctx.result.body).totalExits #else 0 #end,
              "equipmentsToAdd":  #if($util.toJson($util.parseJson($ctx.result.body).equipmentsToAdd)) $util.toJson($util.parseJson($ctx.result.body).equipmentsToAdd) #else [] #end,
              "equipmentsToRemove":  #if($util.toJson($util.parseJson($ctx.result.body).equipmentsToRemove)) $util.toJson($util.parseJson($ctx.result.body).equipmentsToRemove) #else [] #end,
              "alertPreference":
              #if( $util.parseJson($ctx.result.body).alertPreference )
              {
                  "active": $util.parseJson($ctx.result.body).alertPreference.active,
              "alertCategory": "$util.parseJson($ctx.result.body).alertPreference.alertCategory",
              "alertTriggerType": "$util.parseJson($ctx.result.body).alertPreference.alertTriggerType",
              "deliveryMode": $util.toJson($util.parseJson($ctx.result.body).alertPreference.deliveryMode),
              "id": "$util.parseJson($ctx.result.body).alertPreference.id",
                "moduleId": "$util.parseJson($ctx.result.body).alertPreference.moduleId",
                "manualRecepientPhoneList": [
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.manualRecepientPhoneList)
                  {
                    "name":"$item.name",
                    "phoneNumber":"$item.phoneNumber"
                  },
                  #end
                  ],
                "manualRecepientEmailList":[
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.manualRecepientEmailList)
                  {
                    "name":"$item.name",
                    "email":"$item.email"
                  },
                  #end
                  ],
                "existingAppRecepients": [
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.existingAppRecepients)
                  {
                    "firstName":"$item.firstName",
                    "lastName":"$item.lastName",
                    "email":"$item.email",
                    "phoneNumber":"$item.phoneNumber"
                  },
                  #end
                  ],
                "allEquipmentConfig":[
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.allEquipmentConfig)
                  {
                    "key":"$item.key",
                    "value":"$item.value"
                  },
                  #end
                  ],
                "alertTriggerTiming":$util.toJson($util.parseJson($ctx.result.body).alertPreference.alertTriggerTiming)
              }
              #else
              {}
              #end
              
          }
          #else
            $ctx.result.body
          #end  
        #else 
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end
  
  #-----------------------------------------------------------------------------
  # Function for AddGeofence_WrapperLambda
  #-----------------------------------------------------------------------------
  
  AddGeofenceWrapperLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: AddGeofence Wrapper Lambda Integration Function
      FunctionVersion: 2018-05-29
      Name: AddGeofence_WrapperLambdaFunction
      RequestMappingTemplate: |
        
        #if(!$ctx.args.input.name || $ctx.args.input.name == "")
          $util.error("Name can not be empty, please give this Geofence a name for easy identification.")   
        #end

        ## #if(!$ctx.args.input.totalExits)
        ##  #if($ctx.args.input.totalExits=="")
        ##      #set( $$ctx.args.input.totalExits = 0)
        ##     #end
        ## #end

        #if(!$ctx.args.input.accountId || $ctx.args.input.accountId == "")
          $util.error("Account ID can not be empty.")
        #end

        #if($ctx.args.input.shape.shapeType=="CIRCLE")
          #if($ctx.args.input.shape.coordinate[0].size()==1 )
            #set($var = $util.toJson($ctx.args.input))
          #else
            $util.error("Coordinates do not match for circle")
          #end
        #else
          #if($ctx.args.input.shape.coordinate[0].size()>2)
            #set($var = $util.toJson($ctx.args.input))
          #else
            $util.error("Inappropriate coordinates for the chosen ShapeType")
          #end
        #end
        #set($circleCoordinate=[])
        #if($ctx.args.input.shape.shapeType=="CIRCLE")
        #set($v=$circleCoordinate.add($ctx.args.input.shape.coordinate[0][0][0]))
        #set($v=$circleCoordinate.add($ctx.args.input.shape.coordinate[0][0][1]))
        #set($ctx.args.input.shape.coordinate=$circleCoordinate)
        #end
        #set($var = $util.toJson($ctx.args.input))

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences"))
        $util.qr($lambdaRq.put("requestBody",$var))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end

        ## #if($ctx.result.statusCode == 201 && $util.parseJson($ctx.result.body).totalExits=="")
        ##  #set($totalExits =$util.parseJson($ctx.result.body).totalExits)
        ## #else
        ##  #set( $totalExits = $util.parseJson($ctx.result.body).totalExits )
        ## #end

        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 201)

        #if($util.parseJson($ctx.result.body).shape.shapeType=="CIRCLE")
            {
              "geofenceId":"$util.parseJson($ctx.result.body).geofenceId",
              "accountId": "$util.parseJson($ctx.result.body).accountId",
              "name": "$util.parseJson($ctx.result.body).name",
              "divisionCode": "$util.parseJson($ctx.result.body).divisionCode",
              "shape": {
              "radius":$util.parseJson($ctx.result.body).shape.radius,
              "shapeType": "$util.parseJson($ctx.result.body).shape.shapeType",
              "coordinate":
              [[$util.parseJson($ctx.result.body).shape.coordinate]]
              },
              "active": #if($util.parseJson($ctx.result.body).active) $util.parseJson($ctx.result.body).active #else null #end,
              "notes": "$util.parseJson($ctx.result.body).notes",
              "equipment": $util.toJson($util.parseJson($ctx.result.body).equipment),
              "autoAddEquipment": $util.parseJson($ctx.result.body).autoAddEquipment,
              "autoAddEquipOfType": "$util.parseJson($ctx.result.body).autoAddEquipOfType",
              "autoAddEquipTypeValues": $util.toJson($util.parseJson($ctx.result.body).autoAddEquipTypeValues),
              "status": #if($util.parseJson($ctx.result.body).status) "$util.parseJson($ctx.result.body).status" #else "ERROR" #end,
              "totalEntrances": $util.parseJson($ctx.result.body).totalEntrances,
              "totalExits":  #if($!util.parseJson($ctx.result.body).totalExits) $!util.parseJson($ctx.result.body).totalExits #else 0 #end,
              "equipmentsToAdd":  #if($util.toJson($util.parseJson($ctx.result.body).equipmentsToAdd)) $util.toJson($util.parseJson($ctx.result.body).equipmentsToAdd) #else [] #end,
              "equipmentsToRemove":  #if($util.toJson($util.parseJson($ctx.result.body).equipmentsToRemove)) $util.toJson($util.parseJson($ctx.result.body).equipmentsToRemove) #else [] #end,
              "alertPreference":
              #if( $util.parseJson($ctx.result.body).alertPreference )
              {
                  "isActive": #if($util.parseJson($ctx.result.body).alertPreference.isActive) $util.parseJson($ctx.result.body).alertPreference.isActive #else null #end,
              "alertCategory": "$!util.parseJson($ctx.result.body).alertPreference.alertCategory",
              "alertTriggerType": "$util.parseJson($ctx.result.body).alertPreference.alertTriggerType",
              "deliveryMode": $util.toJson($util.parseJson($ctx.result.body).alertPreference.deliveryMode),
              "manualRecipientPhoneList": [
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.manualRecipientPhoneList)
                  {
                    "name":"$item.name",
                    "phoneNumber":"$item.phoneNumber"
                  },
                  #end
                  ],
                "manualRecipientEmailList":[
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.manualRecipientEmailList)
                  {
                    "name":"$item.name",
                    "email":"$item.email"
                  },
                  #end
                  ],
                "existingAppRecipients": [
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.existingAppRecipients)
                  {
                    "firstName":"$item.firstName",
                    "lastName":"$item.lastName",
                    "email":"$item.email",
                    "phoneNumber":"$item.phoneNumber"
                  },
                  #end
                  ],
                "allEquipmentConfig":[
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.allEquipmentConfig)
                  {
                    "key":"$item.key",
                    "value":"$item.value"
                  },
                  #end
                  ],
                "alertTriggerTiming":$util.toJson($util.parseJson($ctx.result.body).alertPreference.alertTriggerTiming)
              }
              #else
              {}
              #end
              
          }
          #else
            $ctx.result.body
          #end  
        #else 
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # Function for AddBulkGeofence_WrapperLambdaFunction
  #-----------------------------------------------------------------------------
  
  AddBulkGeofenceWrapperLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: Add bulk geofence Function
      FunctionVersion: 2018-05-29
      Name: AddBulkGeofence_WrapperLambdaFunction
      RequestMappingTemplate: |
        
        #set($index=0)
        #foreach( $item in $ctx.args.geofences )
          #if( $item.divisionCode.trim()=="US")
              #set( $item.divisionCode = "HG" )
          #elseif( $item.divisionCode.trim()=="CAN" )
              #set( $item.divisionCode = "CR" )
          ## #else
        ##      $util.error("Please select US or CAN for geofence - ${item.name}")
        #end
        #if($item.shape.shapeType=="CIRCLE")
          #set($circleCoordinate=[])
          #if($item.shape.coordinate && $item.shape.coordinate.size() ==1 && $item.shape.coordinate[0].size()==1 && $item.shape.coordinate[0][0].size()==2)
          #set($v=$circleCoordinate.add($item.shape.coordinate[0][0][0]))
          #set($v=$circleCoordinate.add($item.shape.coordinate[0][0][1]))
          #elseif($item.shape.coordinate && $item.shape.coordinate.size() ==1 && $item.shape.coordinate[0].size()==1 && $item.shape.coordinate[0][0].size()!=2)
            #set( $circleCoordinate =$item.shape.coordinate[0][0])
          #end
          #set($item.shape.coordinate=$circleCoordinate)
        #end
        #set($index= $index+1)
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences/bulk"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 201 || $ctx.result.statusCode==206)
            ## If response is 200, return the body.
            $ctx.result.body
        #elseif($ctx.result.statusCode==400)
        $util.error("Please Check and Enter Correct Input")
        #elseif($ctx.result.statusCode==404)
            ## If response is not 200, append the response to error block.
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # Function for UpdateGeofence_WrapperLambdaFunction
  #-----------------------------------------------------------------------------
  
  UpdateGeofenceWrapperLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: UpdateGeofence_WrapperLambdaFunction Function
      FunctionVersion: 2018-05-29
      Name: UpdateGeofence_WrapperLambdaFunction
      RequestMappingTemplate: |
        
        #if(!$ctx.args.input.name || $ctx.args.input.name.trim() == "")
          $util.error("Name can not be empty, please give this Geofence a name for easy identification.")   
        #end
        #set( $geoFenceId = ${ctx.args.geofenceId} )
        #if( !$ctx.args.input.shape.shapeType )
          $util.error("shapeType can't be missing")
        #elseif( $ctx.args.input.shape.shapeType.trim()=="" )
          $util.error("shapeType can't be an empty string")
        #end
        #if( !$ctx.args.input.accountId )
          $util.error("accountId can't be missing")
        #elseif( $ctx.args.input.accountId.trim()=="" )
          $util.error("accountId can't be an empty string")
        #end
        #if( $geoFenceId=="" )
          $util.error("Geofence ID can't be null")
        #elseif( $geoFenceId==" " )
          $util.error("Geofence ID can't be empty string")
        #end
        #if( !$ctx.args.input.shape.coordinate )
          $util.error("coordinate can't be missing")
        #end
        #if( $ctx.args.input.shape.coordinate.size()==0 )
          $util.error("coordinate can't be empty")
        #end

        #if($ctx.args.input.shape.shapeType=="CIRCLE")
          #if($ctx.args.input.shape.coordinate[0].size()==1 )
            #set($var = $util.toJson($ctx.args.input))
          #else
            $util.error("Coordinates do not match for circle")
          #end
        #else
          #if($ctx.args.input.shape.coordinate[0].size()>2)
            #set($var = $util.toJson($ctx.args.input))
          #else
            $util.error("Inappropriate coordinates for the chosen ShapeType")
          #end
        #end

        #set($circleCoordinate=[])
        #if($ctx.args.input.shape.shapeType=="CIRCLE")
        #set($v=$circleCoordinate.add($ctx.args.input.shape.coordinate[0][0][0]))
        #set($v=$circleCoordinate.add($ctx.args.input.shape.coordinate[0][0][1]))
        #set($ctx.args.input.shape.coordinate=$circleCoordinate)
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences/$geoFenceId"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","PUT"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.result.statusCode == 200)
          #set( $variable = $ctx.result.body )
        #if($util.parseJson($variable).shape.shapeType=="CIRCLE")
            {
              "geofenceId":"$util.parseJson($variable).geofenceId",
              "accountId": "$util.parseJson($variable).accountId",
              "name": "$util.parseJson($variable).name",
              "divisionCode": "$util.parseJson($variable).divisionCode",
              "shape": {
              "radius":$util.parseJson($variable).shape.radius,
              "shapeType": "$util.parseJson($variable).shape.shapeType",
              "coordinate":
              [[$util.parseJson($variable).shape.coordinate]]
              },
              "active": $util.parseJson($variable).active,
              "notes": #if($!util.parseJson($variable).notes) "$!util.parseJson($variable).notes" #else "" #end,
              "autoAddEquipment": $util.parseJson($variable).autoAddEquipment,
              "autoAddEquipOfType": "$!util.parseJson($variable).autoAddEquipOfType",
              "autoAddEquipTypeValues": $util.toJson($util.parseJson($variable).autoAddEquipTypeValues),
              "status": #if($util.parseJson($variable).status) "$util.parseJson($variable).status" #else "ERROR" #end,
              "totalEntrances": $util.parseJson($variable).totalEntrances,
              "totalExits":  #if($!util.parseJson($variable).totalExits) $!util.parseJson($variable).totalExits #else 0 #end,
              "equipmentsToAdd":  #if($util.toJson($util.parseJson($variable).equipmentsToAdd)) $util.toJson($util.parseJson($variable).equipmentsToAdd) #else [] #end,
              "equipmentsToRemove":  #if($util.toJson($util.parseJson($variable).equipmentsToRemove)) $util.toJson($util.parseJson($variable).equipmentsToRemove) #else [] #end
          }
          #else
            $variable
          #end 
          #else
          $utils.error($ctx.result.response, "$ctx.result.statusCode")
          #end

  #-----------------------------------------------------------------------------
  # Function for AddEquipmentToGeofence_WrapperLambdaFunction
  #-----------------------------------------------------------------------------
  
  AddEquipmentToGeofenceWrapperLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: AddEquipmentToGeofence_WrapperLambdaFunction Function
      FunctionVersion: 2018-05-29
      Name: AddEquipmentToGeofence_WrapperLambdaFunction
      RequestMappingTemplate: |
        
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        #set( $geofenceId = $ctx.args.geofenceId )
        #set( $equipmentNumber = $ctx.args.equipmentNumber )

        #if($geofenceId == "" || $geofenceId == " ")
          $util.error("Geofence Id cannot be null or empty!")
        #end

        #if($equipmentNumber == "" || $equipmentNumber == " ")
          $util.error("Equipment number cannot be null or empty!")
        #end


        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/$geofenceId/equipment/$equipmentNumber"))
        ## $util.qr($lambdaRq.put("requestBody",$var))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","PUT"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        $util.toJson($ctx.result.body)
        #elseif($ctx.result.statusCode == 404)
        $util.error($ctx.result.body, "$ctx.result.statusCode")
        #else
        $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # Function for DeleteGeofence_WrapperLambdaFunction
  #-----------------------------------------------------------------------------
  
  DeleteGeofenceWrapperLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DeleteGeofence_WrapperLambdaFunction 
      FunctionVersion: 2018-05-29
      Name: DeleteGeofence_WrapperLambdaFunction
      RequestMappingTemplate: |
        
        #set( $geoFenceId = $ctx.args.input )
        #if( $geoFenceId=="")
        $util.error("Geofence Id can't be null.")
        #end 


        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences/$geoFenceId"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","DELETE"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        #set( $deletionStatus = "Deleted successfully" )
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        $util.toJson($deletionStatus)
        #elseif($ctx.result.statusCode == 404)
        $utils.error("Entered Geofence ID is not Valid")
        #else
        $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # Function for GetAlertsByGeofence_WrapperLambdaFunction
  #-----------------------------------------------------------------------------
  
  GetAlertsByGeofenceWrapperLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetAlertsByGeofence_WrapperLambdaFunction
      FunctionVersion: 2018-05-29
      Name: GetAlertsByGeofence_WrapperLambdaFunction
      RequestMappingTemplate: |
        
        #if($ctx.args.id.trim()=="")
        $util.error("geofenceId can not be an empty String")
        #end
        #if($ctx.args.startDate.trim()=="")
        $util.error("startDate can not be an empty String")
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/$ctx.args.id/alert"))
        ##$util.qr($lambdaRq.put("requestBody",$var))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
              
      ResponseMappingTemplate: |
        
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
          $util.error($ctx.result.body)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # Function for GetGeofenceByAccount_WrapperLambdafunction
  #-----------------------------------------------------------------------------
  
  GetGeofenceByAccountWrapperLambdafunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetGeofenceByAccount_WrapperLambdafunction
      FunctionVersion: 2018-05-29
      Name: GetGeofenceByAccount_WrapperLambdafunction
      RequestMappingTemplate: |
        
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences"))
        ##$util.qr($lambdaRq.put("requestBody",$var))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #set($variable = [])
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        ## #set( $maps= $util.parseJson($ctx.prev.result).map )
        #foreach($item in $util.parseJson($ctx.result.body).response)
        #foreach( $j in $ctx.prev.result.response )
        #if( $item.geofenceId==$j.id )
        #set( $item.alertCount =$j.alertCount)
        #set( $item.equipmentCount = $j.equipmentCount )
        #end
        #end
        ## #set($v=$variable.add($item))
        ## #set( $item.alertCount =$maps["$item.geofenceId"].alertCount)
        ## #set( $item.equipmentCount = 20 )
        #if( $item.shape.shapeType=="CIRCLE" )
        #set( $item.shape.coordinate = [[$item.shape.coordinate]] )
        #end
        #if(!$item.autoAddEquipOfType)
        #set( $item.autoAddEquipOfType = " ")
        #end
        #if(!$item.totalExits)
        #set( $item.totalExits = 0)
        #end
        #if(!$item.status)
        #set( $item.status = " ")
        #end
        #set($v=$variable.add($item))
        #end
        $util.toJson($variable)
        #else
        $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # Function for GetGeofenceById_WrapperLambdafunction
  #-----------------------------------------------------------------------------
  
  GetGeofenceByIdWrapperLambdafunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetGeofenceById_WrapperLambdafunction
      FunctionVersion: 2018-05-29
      Name: GetGeofenceById_WrapperLambdafunction
      RequestMappingTemplate: |
        
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        #set( $geoFenceId = $ctx.args.geofenceId )
        #if( $geoFenceId=="" )
          $util.error("Geofence ID can't be null")
        #elseif( $geoFenceId==" " )
          $util.error("Geofence ID can't be empty string")
        #end
        ## #set($var = $util.toJson($ctx.args.input))

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences/$geoFenceId"))
        ## $util.qr($lambdaRq.put("requestBody",$var))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end

        ## #if($ctx.result.statusCode == 201 && $util.parseJson($ctx.result.body).totalExits=="")
        ##  #set($totalExits =$util.parseJson($ctx.result.body).totalExits)
        ## #else
        ##  #set( $totalExits = $util.parseJson($ctx.result.body).totalExits )
        ## #end

        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        #if($util.parseJson($ctx.result.body).shape.shapeType=="CIRCLE")
            {
              "geofenceId":"$util.parseJson($ctx.result.body).geofenceId",
              "accountId": "$util.parseJson($ctx.result.body).accountId",
              "runningCount":$util.parseJson($ctx.result.body).runningCount,
              "name": "$util.parseJson($ctx.result.body).name",
              "shape": {
              "radius":$util.parseJson($ctx.result.body).shape.radius,
              "shapeType": "$util.parseJson($ctx.result.body).shape.shapeType",
              "coordinate":
              [[$util.parseJson($ctx.result.body).shape.coordinate]]
              },
              "active": $util.parseJson($ctx.result.body).active,
              "runningCount":$util.parseJson($ctx.result.body).runningCount,
              "notes":  #if($!util.parseJson($ctx.result.body).notes) "$!util.parseJson($ctx.result.body).notes" #else "" #end,
              "autoAddEquipment": #if( $!util.parseJson($ctx.result.body).autoAddEquipment ) "$!util.parseJson($ctx.result.body).autoAddEquipment" #else "" #end,
              "autoAddEquipOfType": "$util.parseJson($ctx.result.body).autoAddEquipOfType",
              "autoAddEquipTypeValues": $util.toJson($util.parseJson($ctx.result.body).autoAddEquipTypeValues),
              "status": #if($util.parseJson($ctx.result.body).status) "$util.parseJson($ctx.result.body).status" #else "ERROR" #end,
              "totalEntrances": $util.parseJson($ctx.result.body).totalEntrances,
              "totalExits":  #if($!util.parseJson($ctx.result.body).totalExits) $!util.parseJson($ctx.result.body).totalExits #else 0 #end,
              "alertPreference":
              #if( $util.parseJson($ctx.result.body).alertPreference )
              {
                  "active": $util.parseJson($ctx.result.body).alertPreference.active,
              "alertCategory": "$util.parseJson($ctx.result.body).alertPreference.alertCategory",
              "alertTriggerType": "$util.parseJson($ctx.result.body).alertPreference.alertTriggerType",
              "deliveryMode": $util.toJson($util.parseJson($ctx.result.body).alertPreference.deliveryMode),
              "id": "$util.parseJson($ctx.result.body).alertPreference.id",
                "moduleId": "$util.parseJson($ctx.result.body).alertPreference.moduleId",
                "manualRecepientPhoneList": [
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.manualRecepientPhoneList)
                  {
                    "name":"$item.name",
                    "phoneNumber":"$item.phoneNumber"
                  },
                  #end
                  ],
                "manualRecepientEmailList":[
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.manualRecepientEmailList)
                  {
                    "name":"$item.name",
                    "email":"$item.email"
                  },
                  #end
                  ],
                "existingAppRecepients": [
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.existingAppRecepients)
                  {
                    "firstName":"$item.firstName",
                    "lastName":"$item.lastName",
                    "email":"$item.email",
                    "phoneNumber":"$item.phoneNumber"
                  },
                  #end
                  ],
                "allEquipmentConfig":[
                  #foreach( $item in  $util.parseJson($ctx.result.body).alertPreference.allEquipmentConfig)
                  {
                    "key":"$item.key",
                    "value":"$item.value"
                  },
                  #end
                  ],
                "alertTriggerTiming":$util.toJson($util.parseJson($ctx.result.body).alertPreference.alertTriggerTiming)
              }
              #else
              {}
              #end
          }
          #else
            $ctx.result.body
          #end  
        #elseif($ctx.result.statusCode == 400)
          $util.error("Invalid id supplied")
        #elseif($ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
          $util.error("Geofence not found")
        #else 
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # Function for GetGeofenceSummery_WrapperLambda
  #-----------------------------------------------------------------------------
  
  GetGeofenceSummeryWrapperLambda:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetGeofenceSummery_WrapperLambda 
      FunctionVersion: 2018-05-29
      Name: GetGeofenceSummery_WrapperLambda
      RequestMappingTemplate: |
        
        #if( $ctx.args.geofenceID.trim() == "")
          $util.error("Geofence Id cannot be empty")
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        #set($q={"startDate": "$ctx.args.startDate","endDate": "$ctx.args.endDate"})
        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences/$ctx.args.geofenceID/summary"))
        ##$util.qr($lambdaRq.put("requestBody",$var))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
          $util.error($ctx.result.body)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

#-----------------------------------------------------------------------------
  # Function for ExportAlertsMutation
  #-----------------------------------------------------------------------------
  
  ExportAlertsMutationFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt ExportAlertLambdaDS.Name
      Description: ExportAlertsMutationFunction 
      FunctionVersion: 2018-05-29
      Name: ExportAlertsMutationFunction
      RequestMappingTemplate: |
        #set( $variable = $ctx.args.input )
        $util.qr($context.args.input.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.input.put("guid",$ctx.stash.guid))
        $util.qr($context.args.input.put("access-token",$ctx.stash.access-token))
        {
        "version" : "2018-05-29",
        "operation": "Invoke",
        "payload": $util.toJson($variable)
        }
      
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  fetchImagesForGeofenceEquips:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: fetchImagesForGeofenceEquips Function
      FunctionVersion: 2018-05-29
      Name: fetchImagesForGeofenceEquips
      RequestMappingTemplate: |
        #set($catClasses = [])

        #foreach( $item in $ctx.prev.result)

        #if($item.rentalmanCategory && $item.rentalmanClass)
        $util.qr($catClasses.add("${item.rentalmanCategory}-${item.rentalmanClass}"))
        #end

        #end

        $util.qr( $ctx.stash.put("catClassList",$catClasses))
        {
        "method": "POST",
        ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
        "resourcePath": "/graphql",
        "params":{
        "body":{"query":"{\r\ngetSecondLevelCategoriesFromCatClass (\r\nequipments: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\" #else ,\"$cat\" #end #end] \r\n) {\r\ncat_class\r\nequipment_name\r\nequipment_images\r\n\r\n}\r\n}","variables":{}},
        "headers": {
        "Content-Type": "application/json",
        ##"Authorization": "Bearer $ctx.args.token",
        "x-activationid":"$!{ctx.stash.x-activationid}",
        "guid":"$!{ctx.stash.guid}",
        "access-token":"$!{ctx.stash.access-token}"
        }
        }
        }     
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end

        [

        #foreach( $item in $ctx.prev.result )

        {


        #if( $ctx.result.statusCode==200 )
        #foreach( $imageItem in $util.parseJson($ctx.result.body).data.getSecondLevelCategoriesFromCatClass )
        #set( $catClass = "${item.rentalmanCategory}-${item.rentalmanClass}" )
        #if($imageItem.cat_class =="$!catClass")
        "equipmentImage":$util.toJson($imageItem.equipment_images),
        #end
        #end
        #end

        #if($item.alertCount) "alertCount":${item.alertCount}, #end
        #if($item.coordinates) "coordinates": ${item.coordinates}, #end
        "customEquipmentName":"$!{item.customEquipmentName}",
        "equipmentName":"$!{item.equipmentName}",
        #if($item.fuelLevelPercentage) "fuelLevelPercentage": ${item.fuelLevelPercentage}, #end
        "ignition":"$!{item.ignition}",
        "status":"$!{item.status}",
        "equipmentIC":"$!{item.equipmentIC}"
        },
        #end

        ]

  #-----------------------------------------------------------------------------
  # Function for GetEquipmentsInGeofence_WrapperLambdaFunction
  #-----------------------------------------------------------------------------
  
  GetEquipmentsInGeofenceWrapperLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetEquipmentsInGeofence_WrapperLambdaFunction
      FunctionVersion: 2018-05-29
      Name: GetEquipmentsInGeofence_WrapperLambdaFunction
      RequestMappingTemplate: |
        
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        #set( $geoFenceId = ${ctx.args.id} )
        #if( $geoFenceId=="" )
          $util.error("Geofence ID can't be null")
        #elseif( $geoFenceId==" " )
          $util.error("Geofence ID can't be empty string")
        #else
        #set($var = $util.toJson($ctx.args.input))
        #end
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/$geoFenceId/equipment?page=$ctx.args.page&pageSize=$ctx.args.pageSize"))
        ## $util.qr($lambdaRq.put("requestBody",$var))
        ## $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))
        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $util.toJson($util.parseJson($ctx.result.body).response) 
        #else
            ## If response is not 200, append the response to error block.
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAssignmentDetailsByIC
  #-----------------------------------------------------------------------------
  
  GetAssignmentDetailsByICFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetAssignmentDetailsByIC Function
      FunctionVersion: 2018-05-29
      Name: GetAssignmentDetailsByICFunction
      RequestMappingTemplate: |
        #if( $ctx.args.icNumber.trim()=="" )
          $util.error("icNumber can't be an empty string.")
        #end
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        
        $util.qr($lambdaRq.put("endpoint","https://stgtelemacassignmentapi.hercrentals.com/assignments/assignment-by-ic"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for CreateAssignment
  #-----------------------------------------------------------------------------
  
  CreateAssignmentFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: CreateAssignment Function
      FunctionVersion: 2018-05-29
      Name: CreateAssignmentFunction
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacassignmentapi.hercrentals.com/assignments/create"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
        "operation": "Invoke",
        "payload": $util.toJson($lambdaRq)
        }  

      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        ## If response is 200, return the body.
        $ctx.result.body
        #else
        ## If response is not 200, append the response to error block.
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
      
  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAssignmentDetailsById
  #-----------------------------------------------------------------------------
  
  GetAssignmentDetailsByIdFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetAssignmentDetailsById Function
      FunctionVersion: 2018-05-29
      Name: GetAssignmentDetailsByIdFunction
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacassignmentapi.hercrentals.com/assignments/assignment-by-id"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            #if($util.parseJson($ctx.result.body).httpStatus=="500")
            $util.error($util.parseJson($ctx.result.body).message)
            #end
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end 

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAssignmentByAccount
  #-----------------------------------------------------------------------------
  
  GetAssignmentByAccountFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetAssignmentByAccount Function
      FunctionVersion: 2018-05-29
      Name: GetAssignmentByAccountFunction
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacassignmentapi.hercrentals.com/assignments/assignment-by-account"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }        
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **

        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            #if($util.parseJson($ctx.result.body).httpStatus == 404)
          #return({"assignments": [],"totalCount": "0"})
            #end
            $ctx.result.body
        ##    #end
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for CancelAssignment
  #-----------------------------------------------------------------------------
  
  CancelAssignmentFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: CancelAssignment Function
      FunctionVersion: 2018-05-29
      Name: CancelAssignmentFunction
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacassignmentapi.hercrentals.com/assignments/delete"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }        
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end      

  #-----------------------------------------------------------------------------
  # This is the appsync Function for UpdateAssignment
  #-----------------------------------------------------------------------------
  
  UpdateAssignmentFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: UpdateAssignment Function
      FunctionVersion: 2018-05-29
      Name: UpdateAssignmentFunction
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacassignmentapi.hercrentals.com/assignments/update"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }        
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end      

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetOperatorAssignmentDetailByEmail
  #-----------------------------------------------------------------------------
  
  GetOperatorAssignmentDetailByEmailFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetOperatorAssignmentDetailByEmail Function
      FunctionVersion: 2018-05-29
      Name: GetOperatorAssignmentDetailByEmailFunction
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacoperatorapi.hercrentals.com/operator-tab/operator-tab-assignments-by-email"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body)
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetOperatorGroupDetailByEmail
  #-----------------------------------------------------------------------------
  
  GetOperatorGroupDetailByEmailFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetOperatorGroupDetailByEmail Function
      FunctionVersion: 2018-05-29
      Name: GetOperatorGroupDetailByEmailFunction
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacoperatorapi.hercrentals.com/operator-tab/operator-tab-groups-by-email"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end     

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetOperatorTabDetails
  #-----------------------------------------------------------------------------
  
  GetOperatorTabDetailsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetOperatorTabDetails Function
      FunctionVersion: 2018-05-29
      Name: GetOperatorTabDetailsFunction
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacoperatorapi.hercrentals.com/operator-tab/operator-tab-details"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        #if($ctx.result.statusCode == 200)
        ## If response is 200, return the body.
        #if($util.parseJson($ctx.result.body).httpStatus)
        $util.error($util.parseJson($ctx.result.body).message)
        #else
        $ctx.result.body
        #end
        #elseif($ctx.result.httpStatus == 400 || $ctx.result.httpStatus == 404 || $ctx.result.httpStatus == 500)
        $util.error($util.parseJson($ctx.result.body).message)
        ## If response is not 200, append the response to error block.
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  # Anirudh 26/04/2022

  #-----------------------------------------------------------------------------
  # This is the appsync Function for ValidatePhoneNumber
  #-----------------------------------------------------------------------------
  
  ValidatePhoneNumberFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: ValidatePhoneNumber Function
      FunctionVersion: 2018-05-29
      Name: ValidatePhoneNumberFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/mobile-auth/validate"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end


        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 ||  $ctx.result.statusCode == 500)
          $util.error($util.parseJson($ctx.result.body).error)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 201)
            $util.toJson($ctx.result.body)
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end    
      
  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetMobileAuthorizationStatus
  #-----------------------------------------------------------------------------
  
  GetMobileAuthorizationStatusFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetMobileAuthorizationStatus Function
      FunctionVersion: 2018-05-29
      Name: GetMobileAuthorizationStatusFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        $util.qr($headers.put("X-MobileAuth-MessageId","$ctx.args.XMobileAuthMessageId"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/mobile-auth/status"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $util.toJson($ctx.result.body)
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end 


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetScheduleDetailsByProfileId
  #-----------------------------------------------------------------------------
  
  GetScheduleDetailsByProfileIdFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetScheduleDetailsByProfileId Function
      FunctionVersion: 2018-05-29
      Name: GetScheduleDetailsByProfileIdFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        $util.qr($headers.put("accountId","$ctx.args.accountId"))
        $util.qr($headers.put("divisionCode","$ctx.args.divisionCode"))
        $util.qr($headers.put("profileId","$ctx.args.profileId"))
        $util.qr($headers.put("page","$ctx.args.page"))
        $util.qr($headers.put("pageSize","$ctx.args.pageSize"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/schedule/$ctx.args.profileId"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if( $ctx.result.statusCode == 400 )
          $util.error($util.parseJson($ctx.result.body).error)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200 )
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end 


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetCommandStatus
  #-----------------------------------------------------------------------------
  
  GetCommandStatusFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetCommandStatus Function
      FunctionVersion: 2018-05-29
      Name: GetCommandStatusFunction
      RequestMappingTemplate: |
        #set( $headers = {} )
        #set($query={})
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        #set( $lambdaRq = {} )
        #set( $variable = "," )
        #set( $b = "" )
        #foreach( $item in $ctx.args.manualcommandid )
        #if($velocityCount==1)
        #set($b=$b+$item)
        #else
        #set($b=$b+$variable+$item)
        #end
        #end
        $util.qr($query.put("commandIdList","$b"))
        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/power"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($b)))
        $util.qr($lambdaRq.put("query",$query))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))
        {
        "operation": "Invoke",
        "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if( $ctx.result.statusCode == 500 || $ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 )
          $util.error($util.parseJson($ctx.result.body).error)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
  #-----------------------------------------------------------------------------
  # Function for EquipmentsByBranchIdLambdaFunction
  #-----------------------------------------------------------------------------
  
  EquipmentsByBranchIdLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt EquipmentsByBranchIdLambda.Name
      Description: EquipmentsByBranchIdLambdaFunction
      FunctionVersion: 2018-05-29
      Name: EquipmentsByBranchIdLambdaFunction
      RequestMappingTemplate: |
        $util.qr($context.args.put("teleApiPath","/branch-equipment-summary/fleetmap"))
        #set( $rqBody = {} )
        #set( $body = $context.args )
        #set( $headers = {} )
        $util.qr($headers.put("guid","$ctx.request.headers.guid"))
        $util.qr($headers.put("activationId","$ctx.request.headers.x-amzn-requestid"))
        $util.qr($headers.put("accesstoken","$ctx.request.headers.activationId"))

        $util.qr($rqBody.put("body",$body))
        $util.qr($rqBody.put("headers",$headers))

        $util.qr($ctx.stash.put("rqBody",$rqBody))


        {
          "version" : "2017-02-28",
          "operation": "Invoke",
          "payload": $util.toJson($rqBody)
        }
      
      ResponseMappingTemplate: |
        $util.toJson($context.result.body)

  #-----------------------------------------------------------------------------
  # This is the appsync Function for ToggleLTsInAGroupFunction
  #-----------------------------------------------------------------------------
  
  ToggleLTsInAGroupFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: ToggleLTsInAGroupFunction
      FunctionVersion: 2018-05-29
      Name: ToggleLTsInAGroupFunction
      RequestMappingTemplate: |
        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/power/command/group?profileId=$ctx.args.profileId&commandType=$ctx.args.commandType"))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))
        {
        "operation": "Invoke",
        "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ## $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ## #return
        ## #end



        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 201 then return an error. Else return the body **
        #if($ctx.result.statusCode == 201)
        $ctx.result.body
        #elseif($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500 || $ctx.result.statusCode == 401)
        $util.error($util.parseJson($ctx.result.body).error, "$ctx.result.statusCode")
        #else
        $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetLTMultipleSchedule
  #-----------------------------------------------------------------------------
  
  GetLTMultipleScheduleFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetLTMultipleSchedule Function
      FunctionVersion: 2018-05-29
      Name: GetLTMultipleScheduleFunction
      RequestMappingTemplate: |
        #if($ctx.args.accountID.trim() == "")
        $util.error("accountID cannot be empty")
        #end
        #if($ctx.args.equipmentIC.trim() == "")
        $util.error("equipmentIC cannot be empty")
        #end



        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        $util.qr($headers.put("accountId","$ctx.args.accountID"))
        $util.qr($headers.put("divisionCode","$ctx.args.divisionCode"))
        $util.qr($headers.put("equipmentIC","$ctx.args.equipmentIC"))



        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/getLTMultipleSchedulebyEquipmentID?pageNumber=$context.args.pageNumber&pageSize=$context.args.pageSize"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result=={})
            $util.error("Data does not exist for the following combination of accountID, equipmentIC, divisionCode.")
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #set( $variable = $util.parseJson($ctx.result.body) )
        #if($ctx.result.statusCode == 400)
            $util.error($util.toJson($variable.errors))
        #end
        #if( !$variable.catClass)
            $util.error("Data does not exist for the following combination of accountID, equipmentIC, divisionCode")
        #end    
        #if($ctx.result.statusCode == 200)
            #set( $variable.equipment.powerState = true )
            $util.toJson($variable)
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetLTAndSchedulesList
  #-----------------------------------------------------------------------------
  
  GetLTAndSchedulesListFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetLTAndSchedulesList Function
      FunctionVersion: 2018-05-29
      Name: GetLTAndSchedulesListFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        $util.qr($headers.put("accountId","$ctx.args.accountId"))
        $util.qr($headers.put("divisionCode","$ctx.args.divisionCode"))
        $util.qr($headers.put("profileId","$ctx.args.profileId"))
        $util.qr($headers.put("page","$ctx.args.page"))
        $util.qr($headers.put("pageSize","$ctx.args.pageSize"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/group"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAllLightTowerGroups
  #-----------------------------------------------------------------------------
  
  GetAllLightTowerGroupsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetAllLightTowerGroups Function
      FunctionVersion: 2018-05-29
      Name: GetAllLightTowerGroupsFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/group/all"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetSingleLTScheduleByEquipmentId
  #-----------------------------------------------------------------------------
  
  GetSingleLTScheduleByEquipmentIdFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetSingleLTScheduleByEquipmentId Function
      FunctionVersion: 2018-05-29
      Name: GetSingleLTScheduleByEquipmentIdFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        $util.qr($headers.put("accountId","$ctx.args.accountID"))
        $util.qr($headers.put("divisionCode","$ctx.args.divisionCode"))
        $util.qr($headers.put("equipmentIC","$ctx.args.equipmentIC"))



        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/getSingleLTbyEquipmentID"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 400)
            $util.error("$util.parseJson($ctx.result.body).error")
        #end  
        #if($ctx.result.statusCode == 500)
            $util.error("Data does not exist for the following combination of accountId, equipmentIc, divisonCode")
        #end    
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end                                          


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetSingleLightTowerByAccountId
  #-----------------------------------------------------------------------------
  
  GetSingleLightTowerByAccountIdFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetSingleLightTowerByAccountId Function
      FunctionVersion: 2018-05-29
      Name: GetSingleLightTowerByAccountIdFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        $util.qr($headers.put("accountID","$ctx.args.accountID"))
        $util.qr($headers.put("divisionCode","$ctx.args.divisionCode"))



        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/getSingleLTListbyAccountID?page=$ctx.args.page&pageSize=$ctx.args.pageSize"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.result.statusCode==500 || $ctx.result.statusCode==400 || $ctx.result.statusCode==404 )
          $util.error($util.parseJson($ctx.result.body).error)
        #end
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200 )
            ## If response is 200, return the body.
            #if($util.parseJson($ctx.result.body).totalCount==0)
                $util.error($util.toJson($util.parseJson($ctx.result.body).response))
            #end    
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for LTPowerModalOff/ON
  #-----------------------------------------------------------------------------
  
  LTPowerModalOffONFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: LTPowerModalOff/ON Function
      FunctionVersion: 2018-05-29
      Name: LTPowerModalOffONFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $body ={
        "equipmentICList": $ctx.args.equipmentICList,
        "divisionCode": "$ctx.args.divisionCode",
        "commandType": "$ctx.args.commandType",
        "createdBy": "$ctx.args.createdBy"
        })


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/power/command"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($body)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 )
          $util.error($util.parseJson($ctx.result.body).error)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 201 || $ctx.result.statusCode == 500)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for CreateLightTowerGroup
  #-----------------------------------------------------------------------------
  
  CreateLightTowerGroupFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: CreateLightTowerGroup Function
      FunctionVersion: 2018-05-29
      Name: CreateLightTowerGroupFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/group"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 500 || $ctx.result.statusCode == 400 )
        $util.error($util.toJson($util.parseJson($context.result.body).error))
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 400)
        $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 500)
        $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 201)
        $util.toJson($context.result.body)
        #else
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for EditLightTowerGroup
  #-----------------------------------------------------------------------------
  
  EditLightTowerGroupFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: EditLightTowerGroup Function
      FunctionVersion: 2018-05-29
      Name: EditLightTowerGroupFunction
      RequestMappingTemplate: |
        #if( $ctx.args.input.divisionCode )
          #if( $ctx.args.input.divisionCode=="US")
              #set( $ctx.args.input.divisionCode = "HG" )
            #elseif( $ctx.args.input.divisionCode=="CAN" )
              #set( $ctx.args.input.divisionCode = "CR" )
            #else
              $util.error("Please select either US or CAN as divisionCode only.")
            #end
        #end


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/group"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","PUT"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 500 || $ctx.result.statusCode == 400 )
        $util.error($util.toJson($util.parseJson($context.result.body).error))
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 400)
        $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 500)
        $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 200)
        $util.toJson($context.result.body)
        #else
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end  


  #-----------------------------------------------------------------------------
  # This is the appsync Function for DeleteLightTowerGroup
  #-----------------------------------------------------------------------------
  
  DeleteLightTowerGroupFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DeleteLightTowerGroup Function
      FunctionVersion: 2018-05-29
      Name: DeleteLightTowerGroupFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/group/$ctx.args.groupId"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","DELETE"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 500 || $ctx.result.statusCode == 400)
          $util.error($util.toJson($util.parseJson($context.result.body).error))
        #end   
        #if($ctx.result.statusCode == 200)
            $util.toJson($ctx.result.body)
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
      
  #-----------------------------------------------------------------------------
  # This is the appsync Function for CreateLTSchedule
  #-----------------------------------------------------------------------------
  
  CreateLTScheduleFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: CreateLTSchedule Function
      FunctionVersion: 2018-05-29
      Name: CreateLTScheduleFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/schedule"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 500 || $ctx.result.statusCode == 400 )
        $util.error($util.toJson($util.parseJson($context.result.body).error))
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 400)
            $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 500)
            $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 201)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for EditLTSchedule
  #-----------------------------------------------------------------------------
  
  EditLTScheduleFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: EditLTSchedule Function
      FunctionVersion: 2018-05-29
      Name: EditLTScheduleFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        #set( $ctx.args.input.profileId = $context.args.profileId )
        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/schedule"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","PUT"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 500 || $ctx.result.statusCode == 400 )
        $util.error($util.toJson($util.parseJson($context.result.body).error))
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 400)
            $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 500)
            $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for DeleteLTSchedule
  #-----------------------------------------------------------------------------
  
  DeleteLTScheduleFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DeleteLTSchedule Function
      FunctionVersion: 2018-05-29
      Name: DeleteLTScheduleFunction
      RequestMappingTemplate: |
        #if(!$ctx.args.profileId)
        $util.error("ProfileId of schedule cannot be missing")
        #end


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/schedule/$ctx.args.profileId"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","DELETE"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 500 || $ctx.result.statusCode == 400 )
          $util.error($util.toJson($util.parseJson($context.result.body).error))
        #end   
        #if($ctx.result.statusCode == 200)
            $util.toJson($ctx.result.body)
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for AddLTsToGroup
  #-----------------------------------------------------------------------------
  
  AddLTsToGroupFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: AddLTsToGroup Function
      FunctionVersion: 2018-05-29
      Name: AddLTsToGroupFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/group/add-lt"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","PUT"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 500 || $ctx.result.statusCode == 400 )
        $util.error($util.toJson($util.parseJson($context.result.body).error))
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 400)
        $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 500)
        $util.error($util.toJson($util.parseJson($ctx.result.body).error))
        #end
        #if($ctx.result.statusCode == 200)
        $util.toJson($context.result.body)
        #else
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for DeleteLightTowerFromGroup
  #-----------------------------------------------------------------------------
  
  DeleteLightTowerFromGroupFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DeleteLightTowerFromGroup Function
      FunctionVersion: 2018-05-29
      Name: DeleteLightTowerFromGroupFunction
      RequestMappingTemplate: |
        #if(!$ctx.args.groupId)
          $util.appendError("groupId can't be NULL")
        #end
        #if(!$ctx.args.lightTowerId)
          $util.appendError("lightTowerId can't be NULL")
        #end


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelelighttowerapi.hercrentals.com/light-tower/group/$context.args.groupId/delete-lt/$context.args.lightTowerId"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","PUT"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 500 || $ctx.result.statusCode == 400 || $ctx.result.statusCode == 404)
          $util.error($util.toJson($util.parseJson($context.result.body).error))
        #end   
        #if($ctx.result.statusCode == 200)
            $util.toJson($ctx.result.body)
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
  
  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetTagsForTemperatureMonitoring (Phase-2)
  #-----------------------------------------------------------------------------
  
  GetTagsForTemperatureMonitoringFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetTagsForTemperatureMonitoring Function
      FunctionVersion: 2018-05-29
      Name: GetTagsForTemperatureMonitoringFunction
      RequestMappingTemplate: |
        #if( !$ctx.args.input )
          $util.error("Input can't be null.")
        #end
        #if( !$ctx.args.input.groupProfileId)
          $util.error("groupProfileId can't be an empty string.")
        #end
        #if( $ctx.args.input.userName.trim()=="" )
          $util.error("userName can't be an empty string.")
        #end


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/GetTagsList"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))
        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.result.statusCode, $util.parseJson($ctx.result.body).errorSummary)
        #end
        #if($ctx.result.statusCode == 400||$ctx.result.statusCode == 404||$ctx.result.statusCode == 500)
        $util.error($util.parseJson($ctx.result.body).errorSummary)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetTemperatureMonitoringDetails
  #-----------------------------------------------------------------------------
  
  GetTemperatureMonitoringDetailsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetTemperatureMonitoringDetails Function
      FunctionVersion: 2018-05-29
      Name: GetTemperatureMonitoringDetailsFunction
      RequestMappingTemplate: |
        #if($ctx.args.accountNumber.trim()=="")
        $util.error("accountNumber can not be an empty string!")
        #end
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/GetTemperatureMonitoringDetails"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
          $util.error($util.parseJson($ctx.result.body).title)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetGroupProfileGraphData
  #-----------------------------------------------------------------------------
  
  GetGroupProfileGraphDataFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetGroupProfileGraphData Function
      FunctionVersion: 2018-05-29
      Name: GetGroupProfileGraphDataFunction
      RequestMappingTemplate: |
        #if(!$ctx.args.groupProfileId)
        $util.error("groupProfileId can not be an empty")
        #end
        #if($ctx.args.userName.trim()=="")
        $util.error("userNumber can not be an empty string!")
        #end


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/GetGroupProfileGraphData"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetDashboardData
  #-----------------------------------------------------------------------------
  
  GetDashboardDataFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetDashboardData Function
      FunctionVersion: 2018-05-29
      Name: GetDashboardDataFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/GetDashBoardData"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        $util.qr($ctx.stash.put("dashboardData",$util.parseJson($ctx.result.body)))
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
          $util.error($util.parseJson($ctx.result.body).title)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetHubDetails
  #-----------------------------------------------------------------------------
  
  GetHubDetailsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetHubDetails Function
      FunctionVersion: 2018-05-29
      Name: GetHubDetailsFunction
      RequestMappingTemplate: |
        #if( !$ctx.args.input )
          $util.error("Input can't be null.")
        #end
        #if( !$ctx.args.input.groupProfileId)
          $util.error("groupProfileId can't be an empty string.")
        #end
        #if( $ctx.args.input.userName.trim()=="" )
          $util.error("userName can't be an empty string.")
        #end


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/GetHubsList"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for UpdategroupProfileStatus
  #-----------------------------------------------------------------------------
  
  UpdategroupProfileStatusFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: UpdategroupProfileStatus Function
      FunctionVersion: 2018-05-29
      Name: UpdategroupProfileStatusFunction
      RequestMappingTemplate: |
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/UpdateGroupProfileStatus"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for TMCreateGroupProfile
  #-----------------------------------------------------------------------------
  
  TMCreateGroupProfileFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: TMCreateGroupProfile Function
      FunctionVersion: 2018-05-29
      Name: TMCreateGroupProfileFunction
      RequestMappingTemplate: |
        #if($ctx.args.input.equipmentIC.size()==0)
          $util.error("Equipment Ic cannot be empty")
        #end
        #if($ctx.args.input.tags.size()==0)
          $util.error("tags Ic cannot be empty")
        #end
        #if( $context.args.input.userName.trim() == "" )
          $util.error("userName cannot be empty")
        #end
        #if( $context.args.input.hubId.trim() == "" )
          $util.error("hubId cannot be empty")
        #end
        #if( $context.args.input.accountNumber.trim() == "" )
          $util.error("accountNumber cannot be empty")
        #end 
        #if(!$context.args.input.groupProfileId)
          $util.error("groupProfileId cannot be null")
        #end 
        #if(!$context.args.input.maxThresholdInCelsius)
          $util.error("maxThresholdInCelsius cannot be null")
        #end 
        #if(!$context.args.input.minThresholdInCelsius)
          $util.error("minThresholdInCelsius cannot be null")
        #end


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/CreateGroupProfile"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 500)
          $util.error($util.toJson($util.parseJson($ctx.result.body).errors))
        #end


        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end                  

  #-----------------------------------------------------------------------------
  # This is the appsync Function for TMUpdateGroupProfile
  #-----------------------------------------------------------------------------
  
  TMUpdateGroupProfileFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: TMUpdateGroupProfile Function
      FunctionVersion: 2018-05-29
      Name: TMUpdateGroupProfileFunction
      RequestMappingTemplate: |
        #if($ctx.args.input.tags.size()==0)
          $util.error("tags Ic cannot be empty")
        #end
        #if( $context.args.input.userName.trim() == "" )
          $util.error("userName cannot be empty")
        #end
        #if( $context.args.input.hubId.trim() == "" )
          $util.error("hubId cannot be empty")
        #end 
        #if( $context.args.input.accountNumber.trim() == "" )
          $util.error("accountNumber cannot be empty")
        #end 
        #if(!$context.args.input.groupProfileId)
          $util.error("groupProfileId cannot be null")
        #end 
        #if(!$context.args.input.minThresholdInCelsius)
          $util.error("minThresholdInCelsius cannot be null")
        #end   
        #if(!$context.args.input.maxThresholdInCelsius)
          $util.error("maxThresholdInCelsius cannot be null")
        #end   
        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/CreateGroupProfile"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **


        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 500)
          $util.error($util.toJson($util.parseJson($ctx.result.body).errors))
        #end


        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for TMDeleteGroupProfile
  #-----------------------------------------------------------------------------
  
  TMDeleteGroupProfileFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: TMDeleteGroupProfile Function
      FunctionVersion: 2018-05-29
      Name: TMDeleteGroupProfileFunction
      RequestMappingTemplate: |
        #if( $ctx.args.userName.trim()=="" )
          $util.error("userNumber can't be an empty string.")
        #end
        #if( $ctx.args.accountNumber.trim()=="" )
          $util.error("userNumber can't be an empty string.")
        #end



        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/DeleteGroupProfile"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","DELETE"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
  
  #-----------------------------------------------------------------------------
  # This is the appsync Function for AddEqImage
  #-----------------------------------------------------------------------------
  
  AddEqImageFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: AddEqImageFunction 
      FunctionVersion: 2018-05-29
      Name: AddEqImageFunction
      RequestMappingTemplate: |
        #set($catClasses = [])
        #foreach( $item in $ctx.prev.result)
        #foreach( $lineItem in $item.equipmentDetails )
        #if($lineItem.equipmentCategory && $lineItem.equipmentClass)
        $util.qr( $ctx.stash.put("equipmentCategory",${lineItem.equipmentCategory}))
        $util.qr( $ctx.stash.put("equipmentClass",$!{lineItem.equipmentClass}))
        $util.qr($catClasses.add("${lineItem.equipmentCategory}-${lineItem.equipmentClass}"))
        #end
        #end
        #end

        $util.qr( $ctx.stash.put("catClassList",$catClasses))
        {
        "method": "POST",
        ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
        "resourcePath": "/graphql",
        "params":{
        "body":{"query":"{\r\ngetSecondLevelCategoriesFromCatClass (\r\nequipments: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\" #else ,\"$cat\" #end #end] \r\n) {\r\ncat_class\r\nequipment_name\r\nequipment_images\r\n\r\n}\r\n}","variables":{}},
        "headers": {
        "Content-Type": "application/json",
        ##"Authorization": "Bearer $ctx.args.token",
        "x-activationid":"$!{ctx.stash.x-activationid}",
        "guid":"$!{ctx.stash.guid}",
        "access-token":"$!{ctx.stash.access-token}"
        }
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end



        #foreach( $item in $ctx.prev.result)
        #foreach( $j in $item.equipmentDetails)
        #foreach( $imageItem in $util.parseJson($ctx.result.body).data.getSecondLevelCategoriesFromCatClass )
        #set( $catClass = "${j.equipmentCategory}-${j.equipmentClass}" )
        #if($imageItem.cat_class =="$!catClass")
        #set( $j.equipmentImage=$util.toJson($imageItem.equipment_images) )
        #end
        #end
        #end
        #end



        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        $util.toJson($ctx.prev.result)
        #else
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
  
  #-----------------------------------------------------------------------------
  # This is the appsync Function for UpdateGroupProfileStatusFunction
  #-----------------------------------------------------------------------------
  
  UpdateGroupProfileStatusFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: UpdateGroupProfileStatusFunction 
      FunctionVersion: 2018-05-29
      Name: UpdateGroupProfileStatusFunction
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteletempmonitorapi.hercrentals.com/api/TempMonitoring/UpdateGroupProfileStatus"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
          $util.error($util.parseJson($ctx.result.body).title)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
  
  #-----------------------------------------------------------------------------
  # This is the appsync Function for FetchDeliveryAndPickupListFromTelematics
  #-----------------------------------------------------------------------------
  
  FetchDeliveryAndPickupListFromTelematicsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: FetchDeliveryAndPickupListFromTelematics Function
      FunctionVersion: 2018-05-29
      Name: FetchDeliveryAndPickupListFromTelematicsFunction
      RequestMappingTemplate: |
        #set( $headers = {} )
        ## #set($contractNumbers= [#foreach( $contractNo in $ctx.prev.result.data.getEquipmentFiltersForAccount.contractNumbers ) #if($velocityCount==1) $contractNo #else ,$contractNo #end #end])
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))



        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/branch-equipment-summary/fleetmap"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($query)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
          $util.qr( $ctx.stash.put("jobSites",$ctx.prev.result.data.getEquipmentFiltersForAccount.jobSites))
          ##pushed jobsites as they are from 1st resolver, we use them in 3rd resolver after fetching images    
            
            #set($catClasses = []) ##catclasses to have a list to fetch images in a single api call in next resolver
          
          #foreach( $item in $util.parseJson($ctx.result.body).otgStatusResponses ) 
                $util.qr($catClasses.add("$!{item.catClass}"))
                    ##set( $cat1 = "400-1085" )
                    ##set( $cat2 = "140-2270" )
                    ##$util.qr($catClasses.add("${cat1}"))
                    ##$util.qr($catClasses.add("${cat2}"))


          #end
          $util.qr( $ctx.stash.put("catClassList",$catClasses))


            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for FetchEquipmentImageByCatClassForDelivery
  #-----------------------------------------------------------------------------
  
  FetchEquipmentImageByCatClassForDeliveryFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: FetchEquipmentImageByCatClassForDelivery Function
      FunctionVersion: 2018-05-29
      Name: FetchEquipmentImageByCatClassForDeliveryFunction
      RequestMappingTemplate: |
        #set( $jobsites = "" )
        #foreach( $item in $ctx.prev.result.otgStatusResponses)
          #if($item.jobSiteNumber)
            #if($util.isNullOrEmpty($jobsites))
              #set( $jobsites = "${item.jobSiteNumber}" )
            #else 
              #set( $jobsites = "${jobsites}@~@~@${item.jobSiteNumber}" )
            #end
          #end
        #end
        {
            "method": "POST",
            ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
            "resourcePath": "/graphql",
            "params":{
            ##"body":{ "query":"{\r\n\r\n  products(filter: {sku: {in: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\"  #else ,\"$cat\" #end #end] }}) {\r\n    \r\n    items {\r\n        sku\r\n      equipment_images\r\n    }\r\n\r\n  }\r\n\r\n jobsiteAddress(jobNumber: \"3 - VENTURA YARD - V\") {\r\n      jobsiteNumber\r\n      jobsiteName\r\n      jobsiteAddress\r\n      jobsiteCity\r\n      jobsiteState\r\n      jobsiteZip\r\n      jobsitePhone\r\n      contactName\r\n   }\r\n\r\n\r\n\r\n  }","variables":{}},
            "body":{"query":"{\r\ngetSecondLevelCategoriesFromCatClass (\r\nequipments: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\"  #else ,\"$cat\" #end #end]\r\n) {\r\ncat_class\r\nequipment_images\r\n}\r\n\r\n   jobsiteAddress(jobNumber: \"${jobsites}\") {\r\n      jobsiteNumber\r\n      jobsiteName\r\n      jobsiteAddress\r\n      jobsiteCity\r\n      jobsiteState\r\n      jobsiteZip\r\n      jobsitePhone\r\n      contactName\r\n   }\r\n\r\n\r\n\r\n}","variables":{}},
            "headers":{
                    "Content-Type": "application/json",
                    "Authorization": "${ctx.stash.authorization}",
                    ##"x-activationid":"${ctx.stash.x-activationid}",
                    "guid":"${ctx.stash.guid}"
                  ## "access-token":"$!{ctx.stash.access-token}"
                }
            }
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end


        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200 || $ctx.prev.result.otgStatusResponses.size()>0 )
            #set($jobSites = $util.parseJson($ctx.result.body).data.jobsiteAddress )
            #set($OtgDTO = {})
            
            #set ( $d = '"')
            #set ( $o = '{')
            #set ( $e = '}')
            
            [
        #foreach( $item in $ctx.prev.result.otgStatusResponses ) 
        
                #if($velocityCount==1)
                {
                  ${d}contractNumber${d}:${d}$!{item.contractNumber}${d},
                  ${d}status${d}:${d}$!{item.status}${d},
                  ${d}pickupType${d}:${d}$!{item.pickupType}${d},
                    ${d}scheduledDateTime${d}:${d}$!{item.scheduledDateTime}${d},
                    ${d}deliveryDateTime${d}:${d}$!{item.deliveryDateTime}${d},
                    ${d}branchCode${d}:${d}$!{item.branchCode}${d},
                        
                    #foreach( $jb in $jobSites ) 
                    ##if($jb.jobNumber=="CORPORATE OFFICE")
                      #set( $itemJobNo = $item.jobSiteNumber.replace("+"," ") )
                          #if($jb.jobsiteNumber=="$itemJobNo")
                          ${d}jobsite${d} : {
                              "jobNumber" : "$!{jb.jobsiteNumber}",
                              "jobName" : "$!{jb.jobsiteName}",
                        "jobLoc" :"$!{jb.jobsiteAddress}",
                      "jobCity" : "$!{jb.jobsiteCity}",
                      "jobAddr1" : "$!{jb.jobsiteAddress}",
                              "jobAddr2" : "",
                        "contactName" : "$!{jb.contactName}",
                        "jobPhone" : "$!{jb.jobsitePhone}",
                      "jobState" : "$!{jb.jobsiteState}",
                    "jobZip" : "$!{jb.jobsiteZip}"
                          },
                    #end
                    #end
                    ${d}equipmentInfo${d} : $o
                      ${d}equipmentIC${d}:${d}$!{item.equipmentIC}${d},
                      ${d}catClass${d}:${d}$!{item.catClass}${d},
                ${d}equipmentName${d}:${d}$!{item.equipmentName}${d},
                        ${d}description${d}:${d}$!{item.description}${d},


                        #if( $ctx.result.statusCode==200 )
                        #foreach( $imageItem in $util.parseJson($ctx.result.body).data.getSecondLevelCategoriesFromCatClass )
                              ##if($imageItem.sku=="400-1085")
                          #if($imageItem.cat_class=="${item.catClass}")
                            ${d}equipmentImage${d}:$util.toJson($imageItem.equipment_images),
                              #end
                      #end
                        #end
                        
                    ${d}equipmentCustomName${d}:${d}$!{item.equipmentCustomName}${d}
                      


                    $e
                }
                #else
                , {
                  ${d}contractNumber${d}:${d}$!{item.contractNumber}${d},
                  ${d}status${d}:${d}$!{item.status}${d},
                  ${d}pickupType${d}:${d}$!{item.pickupType}${d},
                    ${d}scheduledDateTime${d}:${d}$!{item.scheduledDateTime}${d},
                    ${d}deliveryDateTime${d}:${d}$!{item.deliveryDateTime}${d},
                    ${d}branchCode${d}:${d}$!{item.branchCode}${d},
                    
                    #foreach( $jb in $jobSites ) 
                    ##if($jb.jobNumber=="CORPORATE OFFICE")
                      #set( $itemJobNo = $item.jobSiteNumber.replace("+"," ") )
                          #if($jb.jobsiteNumber=="$itemJobNo")
                          ${d}jobsite${d} : {
                              "jobNumber" : "$!{jb.jobsiteNumber}",
                              "jobName" : "$!{jb.jobsiteName}",
                        "jobLoc" :"$!{jb.jobsiteAddress}",
                      "jobCity" : "$!{jb.jobsiteCity}",
                      "jobAddr1" : "$!{jb.jobsiteAddress}",
                              "jobAddr2" : "",
                        "contactName" : "$!{jb.contactName}",
                        "jobPhone" : "$!{jb.jobsitePhone}",
                      "jobState" : "$!{jb.jobsiteState}",
                    "jobZip" : "$!{jb.jobsiteZip}"
                          },
                    #end
                    #end
                    ${d}equipmentInfo${d} : $o
                      ${d}equipmentIC${d}:${d}$!{item.equipmentIC}${d},
                      ${d}catClass${d}:${d}$!{item.catClass}${d},
                ${d}equipmentName${d}:${d}$!{item.equipmentName}${d},
                        ${d}description${d}:${d}$!{item.description}${d},


                          #if( $ctx.result.statusCode==200 )
                        #foreach( $imageItem in $util.parseJson($ctx.result.body).data.getSecondLevelCategoriesFromCatClass )
                              ##if($imageItem.sku=="400-1085")
                          #if($imageItem.cat_class=="${item.catClass}")
                            ${d}equipmentImage${d}:$util.toJson($imageItem.equipment_images),
                              #end
                      #end
                        #end
                                      
                    ${d}equipmentCustomName${d}:${d}$!{item.equipmentCustomName}${d}
                        
                    $e
                }
                #end
        #end
            ]
            
        #else
            ## If response is not 200, append the response to error block.
            $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end   


  #-----------------------------------------------------------------------------
  # This is the appsync Function for DeliveryPickupLocationTracker
  #-----------------------------------------------------------------------------
  
  DeliveryPickupLocationTrackerFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DeliveryPickupLocationTracker Function
      FunctionVersion: 2018-05-29
      Name: DeliveryPickupLocationTrackerFunction
      RequestMappingTemplate: |
        #set( $headers = {} )
        ## #set($contractNumbers= [#foreach( $contractNo in $ctx.prev.result.data.getEquipmentFiltersForAccount.contractNumbers ) #if($velocityCount==1) $contractNo #else ,$contractNo #end #end])
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgteledeliverypickupapi.hercrentals.com/deliveries-pickups/contracts/$ctx.args.contractNumber/equipments/$ctx.args.equipmentIc/route"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($body)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for ViewAlerts
  #-----------------------------------------------------------------------------
  
  ViewAlertsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: ViewAlerts Function
      FunctionVersion: 2018-05-29
      Name: ViewAlertsFunction
      RequestMappingTemplate: |
        #if( $!{ctx.args.page} )
          #set( $page = -1 )
        #end
        #if( $!{ctx.args.categories} )
          #set( $categories = "" )
        #end



        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )
        #set( $params = {
        "divisionCode":"$ctx.args.divisionCode",
        "customerNumber":"$ctx.args.customerNumber",
        "page":$!{ctx.args.page},
        "groups":"$!{ctx.args.groups}",
        "isWeekendInclusive":$!{ctx.args.isWeekendInclusive},
        "pageSize":$!{ctx.args.pageSize},
        "startDate":"$!{ctx.args.startDate}",
        "endDate":"$!{ctx.args.endDate}"
        } )
        $util.qr($lambdaRq.put("endpoint","https://stgtelealertapi.hercrentals.com/accounts/alerts?divisionCode=$ctx.args.divisionCode&customerNumber=$ctx.args.customerNumber&page=$!{ctx.args.page}&groups=$!{ctx.args.groups}&isWeekendInclusive=$!{ctx.args.isWeekendInclusive}&pageSize=$!{ctx.args.pageSize}&startDate=$!{ctx.args.startDate}&endDate=$!{ctx.args.endDate}"))
        ## $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ## $util.qr($lambdaRq.put("query",$util.parseJson($params)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        } 
      ResponseMappingTemplate: |
        $util.qr($ctx.stash.put("viewAlerts",$util.parseJson($ctx.result.body)))


        #if($ctx.result.statusCode == 200 )
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for DispatchAlert
  #-----------------------------------------------------------------------------
  
  DispatchAlertFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DispatchAlert Function
      FunctionVersion: 2018-05-29
      Name: DispatchAlertFunction
      RequestMappingTemplate: |
        #if( $ctx.args.input.division=="US")
              #set( $ctx.args.input.division = "HG" )
        #end      
        #if( $ctx.args.input.division=="CAN" )
              #set( $ctx.args.input.division = "CR" )
        #end   


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelealertapi.hercrentals.com/alert-api/dispatchalert"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            #return({
            "message":"SMS has been triggered",
            "statusCode":200
            })
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for DispatchSMS
  #-----------------------------------------------------------------------------
  
  DispatchSMSFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DispatchSMS Function
      FunctionVersion: 2018-05-29
      Name: DispatchSMSFunction
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        #foreach( $item in $ctx.args.input.recipientsDetails )
        #set( $item.preferredNotificationType = ["SMS"] )
        #end
        #if( $ctx.args.input.division=="US")
              #set( $ctx.args.input.division = "HG" )
        #end      
        #if( $ctx.args.input.division=="CAN" )
              #set( $ctx.args.input.division = "CR" )
        #end 


        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelealertapi.hercrentals.com/alert-api/dispatchalert"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }     
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            #return({
            "message":"SMS has been triggered",
            "statusCode":200
            })
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for DispatchEmail
  #-----------------------------------------------------------------------------
  
  DispatchEmailFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DispatchEmail Function
      FunctionVersion: 2018-05-29
      Name: DispatchEmailFunction
      RequestMappingTemplate: |
        #foreach( $item in $ctx.args.input.recipientsDetails )
        #set( $item.preferredNotificationType = ["EMAIL"] )
        #end
        #if( $ctx.args.input.division=="US")
              #set( $ctx.args.input.division = "HG" )
        #end      
        #if( $ctx.args.input.division=="CAN" )
              #set( $ctx.args.input.division = "CR" )
        #end



        #set( $headers = {} )


        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )


        $util.qr($lambdaRq.put("endpoint","https://stgtelealertapi.hercrentals.com/alert-api/dispatchalert"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }       
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            #return({
            "message":"EMAIL has been triggered",
            "statusCode":200
            })
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAllDeliveryPickups
  #-----------------------------------------------------------------------------
  
  GetAllDeliveryPickupsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: GetAllDeliveryPickups Function
      FunctionVersion: 2018-05-29
      Name: GetAllDeliveryPickupsFunction
      RequestMappingTemplate: |
        $util.qr($ctx.stash.put("token",$ctx.args.token)) 
        {
            "method": "POST",
            ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
            "resourcePath": "/graphql",
            "params":{
                "body":{"query":"{\r\ngetEquipmentFiltersForAccount(accountId:[$ctx.args.accountId]) {\r\ncontractNumbers\r\n}\r\n}","variables":{}},
                "headers":{
                    "Content-Type": "application/json",
                    "Authorization": "Bearer $ctx.stash.token",
                    "x-activationid":"${ctx.stash.x-activationid}",
                    "guid":"$ctx.stash.guid",
                    "access-token":"${ctx.stash.access-token}"
                }
            }
        }       
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
        $utils.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)


        #if (!$utils.isNullOrEmpty($utils.parseJson($ctx.result.body).errors))


        $utils.error($utils.parseJson($ctx.result.body).errors[0].message, "HTTP 400")
        #else
        $ctx.result.body
        #end
        #else
        $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end
                                    
  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAlertPreferenceById
  #-----------------------------------------------------------------------------
  
  GetAlertPreferenceByIdFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt GetAlertPreferenceById.Name
      Description: GetAlertPreferenceById Function
      FunctionVersion: 2018-05-29
      Name: GetAlertPreferenceByIdFunction
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        #if( !$ctx.args.id || $ctx.args.id.trim()=="")
          $util.error("id can't be null or empty string.")
        #end


        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))


        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }       
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        $util.toJson($context.result)


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAlertPreferenceByAccountIdAndAlertCategory
  #-----------------------------------------------------------------------------
  
  GetAlertPreferenceByAccountIdAndAlertCategoryFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt GetAlertPreferenceByAccountIdAndAlertCategory.Name
      Description: GetAlertPreferenceByAccountIdAndAlertCategory Function
      FunctionVersion: 2018-05-29
      Name: GetAlertPreferenceByAccountIdAndAlertCategoryFunction
      RequestMappingTemplate: |
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))
        {
        "version" : "2018-05-29",
        "operation": "Invoke",
        "payload": $util.toJson($context.args)
        }       
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result)


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetMacEligibleEquipments
  #-----------------------------------------------------------------------------
  
  GetMacEligibleEquipmentsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt GetMacEligibleEquipments.Name
      Description: GetMacEligibleEquipments Function
      FunctionVersion: 2018-05-29
      Name: GetMacEligibleEquipmentsFunction
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        ##$util.qr($context.args.put("headers",$ctx.request.headers))


        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }       
      ResponseMappingTemplate: |
        #if( $context.result && $context.result.errorMessage )
          $utils.error($context.result.errorMessage, $context.result.errorType)
        #else
          $utils.toJson($context.result)
        #end

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAccountAutoAddEqStatus
  #-----------------------------------------------------------------------------
  
  GetAccountAutoAddEqStatusFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt GetAccountAutoAddEqStatus.Name
      Description: GetAccountAutoAddEqStatus Function
      FunctionVersion: 2018-05-29
      Name: GetAccountAutoAddEqStatusFunction
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))
        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }       
      ResponseMappingTemplate: "$util.toJson($context.result)"


  #-----------------------------------------------------------------------------
  # This is the appsync Function for MacToggleAccountAutoAddEqStatus
  #-----------------------------------------------------------------------------
  
  MacToggleAccountAutoAddEqStatusFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt MacToggleAccountAutoAddEqStatus.Name
      Description: MacToggleAccountAutoAddEqStatus Function
      FunctionVersion: 2018-05-29
      Name: MacToggleAccountAutoAddEqStatusFunction
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))
        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }       
      ResponseMappingTemplate: "$util.toJson($context.result)"


  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetMacEquipments ( Second Phase=2)
  #-----------------------------------------------------------------------------
  
  GetMacEquipmentsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt GetMacEquipmentsMACwrapperLambda.Name
      Description: GetMacEquipments Function
      FunctionVersion: 2018-05-29
      Name: GetMacEquipmentsFunction
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))
        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }       
      ResponseMappingTemplate: "$util.toJson($context.result)"


  #-----------------------------------------------------------------------------
  # This is the appsync Function for MacOperatorRequestAccessToEquipment
  #-----------------------------------------------------------------------------
  
  MacOperatorRequestAccessToEquipmentFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt MACOperatorRequestAccessToEquipment.Name
      Description: MacOperatorRequestAccessToEquipment Function
      FunctionVersion: 2018-05-29
      Name: MacOperatorRequestAccessToEquipmentFunction
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))
        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }       
      ResponseMappingTemplate: "$context.result"

  #-----------------------------------------------------------------------------
  # Function for GetCountLambdaFunction
  #-----------------------------------------------------------------------------
  
  GetCountLambdaFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetCountLambdaFunction
      FunctionVersion: 2018-05-29
      Name: GetCountLambdaFunction
      RequestMappingTemplate: |
        #if(!$ctx.args.accountId || $ctx.args.accountId=="")
        $util.error("accountId can't be null")
        #end
        #if($ctx.args.accountId == " " )
        $util.error("accountId can't be an empty string")
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelegeofenceapi.hercrentals.com/geofence-api/geofences/summary"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      
      ResponseMappingTemplate: |
        
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
        $util.error($ctx.result.body,"$ctx.result.statusCode")
        #end
  
  #-----------------------------------------------------------------------------
  # This is the appsync Function for deleteGroup Phase-3
  #-----------------------------------------------------------------------------
  
  DeleteGroup:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DeleteGroup Function
      FunctionVersion: 2018-05-29
      Name: DeleteGroup
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacgroupapi.hercrentals.com/groups/delete"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
      
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  SaveOrUpdateGroup:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: SaveOrUpdateGroup Function
      FunctionVersion: 2018-05-29
      Name: SaveOrUpdateGroup
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacgroupapi.hercrentals.com/groups/update"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  SaveOrUpdateGroup:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: SaveOrUpdateGroup Function
      FunctionVersion: 2018-05-29
      Name: SaveOrUpdateGroup
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacgroupapi.hercrentals.com/groups/update"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
        


  SaveOrUpdateGroup:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: SaveOrUpdateGroup Function
      FunctionVersion: 2018-05-29
      Name: SaveOrUpdateGroup
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacgroupapi.hercrentals.com/groups/update"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  GetGroupById:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetGroupById Function
      FunctionVersion: 2018-05-29
      Name: GetGroupById
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacgroupapi.hercrentals.com/groups/group-by-id"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
        #if($util.parseJson($ctx.result.body).statusCode)
          $util.error($util.parseJson($ctx.result.body).message)
        #else
            $ctx.result.body
        #end
        #elseif($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
          $util.error($util.parseJson($ctx.result.body).message)
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  GetGroupByAccount:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetGroupByAccount Function
      FunctionVersion: 2018-05-29
      Name: GetGroupByAccount
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacgroupapi.hercrentals.com/groups/group-by-account"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end


        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode ==500)
          $util.error($util.parseJson($ctx.result.body).error)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  createGroup:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: createGroup Function
      FunctionVersion: 2018-05-29
      Name: createGroup
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacgroupapi.hercrentals.com/groups/create"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end


  getEnabledEquipmentByOperator:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getEnabledEquipmentByOperator Function
      FunctionVersion: 2018-05-29
      Name: getEnabledEquipmentByOperator
      RequestMappingTemplate: |
        #if( $ctx.args.pageSize.trim()=="")
          $util.error("pageSize can't be null or empty string.")
        #end
        #if( $ctx.args.currentPage.trim()=="")
          $util.error("currentPage can't be null or empty string.")
        #end
        #if( $ctx.args.operatorEmail.trim()=="")
          $util.error("operatorEmail can't be null or empty string.")
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacequipmentapi.hercrentals.com/equipment/operator"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  FetchMacToggle:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: FetchMacToggle Function
      FunctionVersion: 2018-05-29
      Name: FetchMacToggle
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacequipmentapi.hercrentals.com/equipment/mac"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result.body)


  GetFetchEquipments:
      Type: AWS::AppSync::FunctionConfiguration
      Properties: 
        ApiId: !GetAtt GraphQLApi.ApiId
        DataSourceName: !GetAtt WrapperLambda.Name
        Description: GetFetchEquipments Function
        FunctionVersion: 2018-05-29
        Name: GetFetchEquipments
        RequestMappingTemplate: |
          #set( $headers = {} )
          $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
          $util.qr($headers.put("guid","$ctx.stash.guid"))
          $util.qr($headers.put("access-token","$ctx.stash.access-token"))
          $util.qr($headers.put("customerid","$!{ctx.request.headers.customerid}"))
          $util.qr($headers.put("refreshtoken","$ctx.request.headers.refreshtoken"))
          $util.qr($headers.put("Authorization","$ctx.request.headers.Authorization"))


          #set( $lambdaRq = {} )

          $util.qr($lambdaRq.put("endpoint","https://stgtelemacequipmentapi.hercrentals.com/equipment"))
          $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
          ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
          $util.qr($lambdaRq.put("headers",$!{headers}))
          $util.qr($lambdaRq.put("requestMethod","POST"))

          {
            "operation": "Invoke",
            "payload": $util.toJson($lambdaRq)
          }
        
        ResponseMappingTemplate: |
            ## Raise a GraphQL field error in case of a datasource invocation error
            #if($ctx.error)
              $util.error($ctx.error.message, $ctx.error.type)
            #end
            ## if the response status code is not 200, then return an error. Else return the body **
            #if($ctx.result.statusCode == 200)
                ## If response is 200, return the body.
                $ctx.result.body
            #elseif($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
                ## If response is not 200, append the response to error block.
                $util.error($util.parseJson($ctx.result.body).error, "$ctx.result.statusCode")
            #end

  getequipmentStatusbyCategory:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getequipmentStatusbyCategory Function
      FunctionVersion: 2018-05-29
      Name: getequipmentStatusbyCategory
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipmentStatusbyCategory"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
          ## Raise a GraphQL field error in case of a datasource invocation error
          #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
          #end
          ## If the response is not 200 then return an error. Else return the body **
          #if($ctx.result.statusCode == 200)
              $ctx.result.body
          #else
              $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
          #end

  GetEquipmentListbyJobsiteNumber:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetEquipmentListbyJobsiteNumber Function
      FunctionVersion: 2018-05-29
      Name: GetEquipmentListbyJobsiteNumber
      RequestMappingTemplate: |
        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        #if($ctx.args.divisionCode && $util.str.toUpper($ctx.args.divisionCode.trim()) == "US")
        #set( $cc = "HG" )
        #elseif($ctx.args.divisionCode && $util.str.toUpper($ctx.args.divisionCode.trim()) == "CAN")
        #set( $cc = "CR" )
        #else
        $util.error("Please select either CAN or US as division")
        #end
        #set( $ctx.args.jobNumber = $ctx.args.jobNumber.replace("#", "%23"))
        #set( $query={
        "jobNumber":"$!{ctx.args.jobNumber}",
        "page":$!{ctx.args.page},
        "pageSize":$!{ctx.args.pageSize},
        "customerNumber":"$!{ctx.args.customerNumber}",
        "divisionCode":"$cc"
        })

        ## $util.qr($query.put("jobNumber","$!{ctx.args.jobNumber}"))
        ## $util.qr($query.put("customerNumber","$!{ctx.args.customerNumber}"))
        ## $util.qr($query.put("divisionCode","$cc"))
        ## $util.qr($query.put("page",$!{ctx.args.page}))
        ## $util.qr($query.put("pageSize",$!{ctx.args.pageSize}))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/jobNumber/equipment-details"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($query)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
        $util.error($util.parseJson($ctx.result.body).errorMessage,"$ctx.result.statusCode")
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        $ctx.result.body
        $util.qr($ctx.stash.put("EqList",$ctx.result.body))
        #else
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end
        

  fetchContractTypeRntlTypeJobsiteNO:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt MuleEndpoint.Name
      Description: fetchContractTypeRntlTypeJobsiteNO Function
      FunctionVersion: 2018-05-29
      Name: fetchContractTypeRntlTypeJobsiteNO
      RequestMappingTemplate: |
        #**Make an arbitrary HTTP call when this field is listed in a query selection set.
        The "relativePath" is the resource path relative to the root URL provided when you
        created the HTTP data source. Pass a "params" object to forward headers, body,
        and query parameters to the HTTP endpoint.
        *#

        #set( $endDate = $util.time.nowFormatted("yyyyMMdd"))
        #set( $CustomerNo = $util.parseJson($ctx.stash.EqList).equipmentDetails[0].customerNumber )

        {
          "method": "GET",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/api/contract/credit/summary",
          "params":{
              "query":{
              "companyCode":"$ctx.args.divisionCode",
              "customerNum":"$CustomerNo",
              "contractType":"Open,Overdue",
              "page":1,
              "endDate":"$endDate",
              "startDate":"19000101"
              },
              "headers": {
                  ## "Authorization": "$ctx.stash.mule-token"
              }
          }
        }   
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200 || $ctx.result.statusCode == 500 || $ctx.result.statusCode == 400)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  fetchImageForEquipmentsInJobsite:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: fetchImageForEquipmentsInJobsite Function
      FunctionVersion: 2018-05-29
      Name: fetchImageForEquipmentsInJobsite
      RequestMappingTemplate: |
          #**Make an arbitrary HTTP call when this field is listed in a query selection set.
          The "relativePath" is the resource path relative to the root URL provided when you
          created the HTTP data source. Pass a "params" object to forward headers, body,
          and query parameters to the HTTP endpoint.
          *#

          #set($catClasses = [])
            
                #foreach( $item in $util.parseJson($ctx.stash.EqList).equipmentDetails)
              
              #if($item.rentalmanCategory && $item.rentalmanClass)
                  $util.qr($catClasses.add("${item.rentalmanCategory}-${item.rentalmanClass}"))
                  #end
              
                #end
            
                $util.qr( $ctx.stash.put("catClassList",$catClasses))
          {
            "method": "POST",
            ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
            "resourcePath": "/graphql",
            "params":{
                "body":{"query":"{\r\ngetSecondLevelCategoriesFromCatClass (\r\nequipments: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\"  #else ,\"$cat\" #end #end] \r\n) {\r\ncat_class\r\nequipment_name\r\nequipment_images\r\n\r\n}\r\n}","variables":{}},
                "headers": {
                    "Content-Type": "application/json",
                      ##"Authorization": "Bearer $ctx.args.token",
                      "x-activationid":"$!{ctx.stash.x-activationid}",
                      "guid":"$!{ctx.stash.guid}",
                      "access-token":"$!{ctx.stash.access-token}"
                }
            }
          }
      ResponseMappingTemplate: |
        #set( $cs = "" )
        #set( $rt = "" )
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        {
        "totalCount":$util.parseJson($ctx.stash.EqList).totalCount,
        "equipmentDetails":[
        #foreach( $item in $util.parseJson($ctx.stash.EqList).equipmentDetails )
        #foreach( $itr in $ctx.prev.result.contracts )
        #if( $item.contractNumber == $itr.contractNumber )
        #set($rt = $itr.contractType)
        #end
        #if( $item.contractNumber == $itr.contractNumber )
        #set($cs = $itr.contractSequence)
        #end
        #end
        {
        "equipmentIC":"$!{item.equipmentIC}",
        "equipmentName":"$!{item.equipmentName}",
        "customEquipmentName":"$!{item.equipmentCustomName}",
        "customerNumber":"$!{item.customerNumber}",
        "contractNumber":"$!{item.contractNumber}",
        "rentalmanCategory":"$!{item.rentalmanCategory}",
        "rentalmanClass":"$!{item.rentalmanClass}",
        #if($item.ignitionStaus)
        "ignition":${item.ignitionStaus},
        #end
        #if( $item.fuelLevel )
        "fuelLevelPercentage":${item.fuelLevel},
        #end
        #if( $item.alertCount )
        "alertCount": ${item.alertCount},
        #end
        "coordinates":#if( $!{item.longitude} && $!{item.latitude} )["$!{item.longitude}","$!{item.latitude}"] #else [null,null] #end ,
        "jobName": "$!{item.jobName}",
        "contractSequence":"$cs",
        #if( $ctx.result.statusCode==200 )
        #foreach( $imageItem in $util.parseJson($ctx.result.body).data.getSecondLevelCategoriesFromCatClass )
        #set( $catClass = "${item.rentalmanCategory}-${item.rentalmanClass}" )
        #if($imageItem.cat_class =="$!catClass")
        "equipmentImage":$util.toJson($imageItem.equipment_images),
        #end
        #end
        #end
        "rentalType":"$rt"



        },
        #end

        ]
        }

  getFleetAggregatedView:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getFleetAggregatedView Function
      FunctionVersion: 2018-05-29
      Name: getFleetAggregatedView
      RequestMappingTemplate: |
        #foreach( $item in $ctx.args.input )
        #if(!$item.customerNumber)
        $util.error("customerNumber can not be empty.")
        #end
        #end
        #foreach( $item in $ctx.args.input )
        #if($item.divisionCode.trim()=="")
        $util.error("divisionCode can not be empty string.")
        #end
        #if($util.str.toUpper($item.divisionCode).trim()=="US")
        #set( $item.divisionCode = "HG" )
        #elseif($util.str.toUpper($item.divisionCode).trim()=="CAN")
        #set( $item.divisionCode = "CR" )
        #else
        $util.error("Please select either US or CAN.")
        #end
        #end
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/fleet/fleetAggregatedView?page=$ctx.args.page&pageSize=$ctx.args.pageSize"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 404)
          $util.error($util.parseJson($ctx.result.body).errorMessage,"$ctx.result.statusCode")
        #end    


        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  getequipmentImageforfleetView:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: getequipmentImageforfleetView Function
      FunctionVersion: 2018-05-29
      Name: getequipmentImageforfleetView
      RequestMappingTemplate: |
            #**Make an arbitrary HTTP call when this field is listed in a query selection set.
            The "relativePath" is the resource path relative to the root URL provided when you
            created the HTTP data source. Pass a "params" object to forward headers, body,
            and query parameters to the HTTP endpoint.
            *#
            #set($catClasses = [])
              
                  #foreach( $item in $ctx.prev.result.content)
                
                #if($item.rentalmanCategory && $item.rentalmanClass)
                    $util.qr($catClasses.add("${item.rentalmanCategory}-${item.rentalmanClass}"))
                    #end
                
                  #end
              
                  $util.qr( $ctx.stash.put("catClassList",$catClasses))
            {
              "method": "POST",
              ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
              "resourcePath": "/graphql",
              "params":{
                  "body":{"query":"{\r\ngetSecondLevelCategoriesFromCatClass (\r\nequipments: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\"  #else ,\"$cat\" #end #end] \r\n) {\r\ncat_class\r\nequipment_name\r\nequipment_images\r\n\r\n}\r\n}","variables":{}},
                  "headers": {
                      "Content-Type": "application/json",
                        ##"Authorization": "Bearer $ctx.args.token",
                        "x-activationid":"$!{ctx.stash.x-activationid}",
                        "guid":"$!{ctx.stash.guid}",
                        "access-token":"$!{ctx.stash.access-token}"
                  }
              }
            }   
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        {
        "pageable": {
                "sort": {
                    "empty": $!{ctx.prev.result.pageable.sort.empty},
                    "sorted": $!{ctx.prev.result.pageable.sort.sorted},
                    "unsorted": $!{ctx.prev.result.pageable.sort.unsorted}
                },
                "offset": $!{ctx.prev.result.pageable.offset},
                "pageNumber":  $!{ctx.prev.result.pageable.pageNumber},
                "pageSize":  $!{ctx.prev.result.pageable.pageSize},
                "paged":  $!{ctx.prev.result.pageable.paged},
                "unpaged":  $!{ctx.prev.result.pageable.unpaged}
            },
            "totalElements": $!{ctx.prev.result.totalElements},
            "totalPages": $!{ctx.prev.result.totalPages},
            "last":$!{ctx.prev.result.last},
            "size": $!{ctx.prev.result.size},
            "number": $!{ctx.prev.result.number},
            "sort": {
                "empty": $!{ctx.prev.result.sort.empty},
                "sorted": $!{ctx.prev.result.sort.sorted},
                "unsorted": $!{ctx.prev.result.sort.unsorted}
            },
            "numberOfElements": $!{ctx.prev.result.numberOfElements},
            "first": $!{ctx.prev.result.first},
            "empty": $!{ctx.prev.result.empty},
            
            "content" : [
              #foreach( $item in $ctx.prev.result.content)
              { 
                "equipmentIdentifier": "$!{item.equipmentIdentifier}",
                "customerNumber":"$!{item.customerNumber}",
                "name": "$!{item.name}",
                "customName": "$!{item.customName}",
                "ignitionStatus": $!{item.ignitionStatus},
                "accountName": "$!{item.accountName}", 
                "equipmentName": #if($item.equipmentName) "$item.equipmentName" #else "null" #end ,
                "alertCount": $!{item.alertCount},
            "fuelLevel": $!{item.fuelLevel},
            "equipmentCustomName":"$!{item.equipmentCustomName}",
            "latitude":$!{item.latitude},
            "longitude":$!{item.longitude},
                "rentalmanCategory": #if($item.rentalmanCategory) "$item.rentalmanCategory" #else "null" #end,
                "rentalmanClass": #if($item.rentalmanClass) "$item.rentalmanClass" #else "null" #end,
                "contractNumber": #if($item.contractNumber) "$item.contractNumber" #else "null" #end,
                
                #if( $ctx.result.statusCode==200 )
                #foreach( $imageItem in $util.parseJson($ctx.result.body).data.getSecondLevelCategoriesFromCatClass )
                  #set( $catClass = "${item.rentalmanCategory}-${item.rentalmanClass}" )
                    #if($imageItem.cat_class =="$!catClass")
                          "equipmentImage":$util.toJson($imageItem.equipment_images),
                        #end
                  #end
                  #end
            "jobName": #if($item.jobName) "$item.jobName" #else "null" #end

              },
              #end
            ]
          
        }


  getFleetDiagnosticsByAccountID:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getFleetDiagnosticsByAccountID Function
      FunctionVersion: 2018-05-29
      Name: getFleetDiagnosticsByAccountID
      RequestMappingTemplate: |
        #if(!$ctx.args.equipmentCategory)
          #set( $ctx.args.equipmentCategory  = "" )
        #end
        #if(!$ctx.args.equipmentType)
          #set( $ctx.args.equipmentType  = "" )
        #end
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/account/fleet-diagnostics"))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }       
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end
  #-----------------------------------------------------------------------------
  # This Function for jobsiteNameForFleetDiagnostics
  #-----------------------------------------------------------------------------  
  
  jobsiteNameForFleetDiagnostics:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: jobsiteNameForFleetDiagnostics Function
      FunctionVersion: 2018-05-29
      Name: jobsiteNameForFleetDiagnostics
      RequestMappingTemplate: |
        #set( $eqIcList = [] )
        #foreach( $item in $ctx.prev.result.equipmentDetails)
        #set( $eqIc = {} )
        $util.qr($eqIc.put("equipmentIC","$!{item.equipmentIC}"))
        $util.qr($eqIc.put("division","$!{ctx.args.divisionCode}"))
        $util.qr($eqIcList.add($eqIc))
        #end
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-summary/jobsite"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($eqIcList)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }           
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        ## If response is 200, return the body.
        $ctx.result.body
        #else
        ## If response is not 200, append the response to error block.
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end

  addEquipmentImageForDiagnostics:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: addEquipmentImageForDiagnostics Function
      FunctionVersion: 2018-05-29
      Name: addEquipmentImageForDiagnostics
      RequestMappingTemplate: |
        #set($catClasses = [])

        #foreach( $item in $ctx.stash.response.equipmentDetails)

        #if($item.rentalmanCategory && $item.rentalmanClass)
        $util.qr($catClasses.add("${item.rentalmanCategory}-${item.rentalmanClass}"))
        #end

        #end

        $util.qr( $ctx.stash.put("catClassList",$catClasses))
        {
        "method": "POST",
        ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
        "resourcePath": "/graphql",
        "params":{
        "body":{"query":"{\r\n getSecondLevelCategoriesFromCatClass (\r\nequipments: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\" #else ,\"$cat\" #end #end] \r\n) {\r\ncat_class\r\nequipment_name\r\nequipment_images\r\n\r\n}\r\n}","variables":{}},
        "headers": {
        "Content-Type": "application/json",
        ##"Authorization": "Bearer $ctx.args.token",
        "x-activationid":"$!{ctx.stash.x-activationid}",
        "guid":"$!{ctx.stash.guid}",
        "access-token":"$!{ctx.stash.access-token}"
        }
        }
        }           
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #endppendError($ctx.result.body, "$ctx.result.statusCode")
        #end
        {
        "totalCount": #if($ctx.stash.response.totalCount) $ctx.stash.response.totalCount #else 0 #end,
        "equipmentDetails": [

        #foreach( $item in $ctx.stash.response.equipmentDetails )
        {
        "equipmentIC": "$!{item.equipmentIC}",
        "equipmentName":#if($item.equipmentName) "$item.equipmentName.replace('"','\"')" #else "" #end,
        "equipmentCustomName": #if($item.equipmentCustomName) "$item.equipmentCustomName.replace('"','\"')" #else "" #end,
        "customerNumber": #if($item.customerNumber) $item.customerNumber #else 0 #end,
        "ignitionStatus": #if($item.ignitionStatus) $item.ignitionStatus #else false #end,
        "fuelLevel1": #if($item.fuelLevel1) $item.fuelLevel1 #else 0 #end,
        "fuelLevel2": #if($item.fuelLevel2) $item.fuelLevel2 #else 0 #end,
        "alertCount": #if($item.alertCount) $item.alertCount #else 0 #end,
        "engineCoolantTemp": #if($item.engineCoolantTemp) $item.engineCoolantTemp #else 0 #end,
        "coolantLevel": #if($item.coolantLevel) $item.coolantLevel #else 0 #end,
        "batteryVoltage": #if($item.batteryVoltage) $item.batteryVoltage #else 0.0 #end,

        #foreach( $jobItem in $ctx.prev.result.content)
        #if($item.equipmentIC=="$jobItem.equipmentIC")
        "jobSiteName":"$!{jobItem.jobName}",
        #end
        #end
        #foreach( $imageItem in $util.parseJson($ctx.result.body).data.getSecondLevelCategoriesFromCatClass )
        #set( $catClass = "${item.rentalmanCategory}-${item.rentalmanClass}" )
        #if($imageItem.cat_class =="$!catClass")
        "equipmentImage":$util.toJson($imageItem.equipment_images),
        #end
        #end
        "rentalmanClass": "$!{item.rentalmanClass}",
        "rentalmanCategory": "$!{item.rentalmanCategory}",
        "defLevel": #if($item.defLevel) $item.defLevel #else 0 #end
        },
        #end

        ]
        }

  GetEquipmentByBranchID:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetEquipmentByBranchID Function
      FunctionVersion: 2018-05-29
      Name: GetEquipmentByBranchID
      RequestMappingTemplate: |
        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/branch-equipment-summary/fleetmap"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($query)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))
        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }       
      ResponseMappingTemplate: |
        $util.qr($ctx.stash.put("response",$util.parseJson($ctx.result.body)))

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
          $util.error($util.parseJson($ctx.result.body).errorMessage)
        #end
        ## If the response is not 200 then return an error. Else return the body **

        #if($ctx.result.statusCode == 200)
            #set( $branchNo = [] )
            #set( $equipIC = [] )
            #set( $body = $util.parseJson($ctx.result.body))
            #foreach( $item in $body.equipmentList )
                #set($v = $branchNo.add($item.equipmentBranchNumber))
                #set($w = $equipIC.add($item.equipmentIC))
            #end  
            $util.qr($ctx.stash.put("branchNo",$branchNo))
            $util.qr($ctx.stash.put("equipIC",$equipIC))
            $ctx.result.body    
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  QueryGetEquipmentByBranchID:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: QueryGetEquipmentByBranchID Function
      FunctionVersion: 2018-05-29
      Name: QueryGetEquipmentByBranchID
      RequestMappingTemplate: |
        {
            "method": "POST",
            ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
            "resourcePath": "/graphql",
            "params":{
                "body":{"query":"{ getBranchDetailsByBranchNumber(branchNumber: [#foreach( $item in $ctx.stash.branchNo ) $item, #end]) { branchDetails{ branchname branchcode branchnumber branchtype addresslatitude addresslongitude address phone city state country zip timings branchimageurl } }}"},
                "headers":{
                    "Content-Type": "application/json",
                    ##"Authorization": "$ctx.request.headers.Authorization"
                }
            }
        }       
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        $util.qr($ctx.stash.put("getBranchCityAndState",$util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber))
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #set( $cities = {} )
        #set( $states = {} )
        #foreach( $item in $ctx.stash.response.equipmentList )
          #foreach( $j in $ctx.stash.getBranchCityAndState.branchDetails )
            #if($j.branchnumber==$item.equipmentBranchNumber)
                    #set($v=$cities.put("$item.equipmentBranchNumber","$j.city"))
                    #set($v=$states.put("$item.equipmentBranchNumber","$j.state"))
            #end
          #end
        #end
        $util.qr($ctx.stash.put("cities",$cities))
        $util.qr($ctx.stash.put("states",$states))
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
              $ctx.result.body
        ##     {
        ##       "equipmentList": 
        ##       #if($ctx.stash.response.equipmentList.size()>0)
        ##       [
        ##       #foreach( $item in $ctx.stash.response.equipmentList )
        ##         {
        ##           "equipmentBranchNumber": "$!{item.equipmentBranchNumber}",
        ##           "equipmentIC": "$!{item.equipmentIC}",
        ##           "equipmentName": "$!{item.equipmentName}",
        ##           "equipmentRentalStatus": "$!{item.equipmentRentalStatus}",
        ##           "fuelLevel": "$!{item.fuelLevel}",
        ##           "ignition": "$!{item.ignition}",
        ##           "city":"$!{ctx.stash.cities.get($item.equipmentBranchNumber)}",
        ##           "state":"$!{ctx.stash.states.get($item.equipmentBranchNumber)}",
        ##        "equipmentCategory": "$!{item.equipmentCategory}",
        ##           "equipmentClass": "$!{item.equipmentClass}",
        ##           "latitude": $!{item.latitude},
        ##           "longitude": $!{item.longitude},
        ##           "equipmentImage":"Sample image"
        ##         },
        ##       #end
        ##       ]
        ##       #else
        ##       []
        ##       #end,
        ##       "pageNumber": $!{ctx.stash.response.pageNumber} ,
        ##       "pageSize": $!{ctx.stash.response.pageSize} ,
        ##       "totalElements": $!{ctx.stash.response.totalElements} ,
        ##       "totalPages": $!{ctx.stash.response.totalPages} 
        ##     }
            

        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end                    

  
  getEquipmentImage:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: getEquipmentImage Function
      FunctionVersion: 2018-05-29
      Name: getEquipmentImage
      RequestMappingTemplate: |
        #**Make an arbitrary HTTP call when this field is listed in a query selection set.
        The "relativePath" is the resource path relative to the root URL provided when you
        created the HTTP data source. Pass a "params" object to forward headers, body,
        and query parameters to the HTTP endpoint.
        *#

        #set($catClasses = [])
          
              #foreach( $item in $ctx.stash.response.equipmentList)
            
            #if($item.equipmentCategory && $item.equipmentClass)
                $util.qr($catClasses.add("${item.equipmentCategory}-${item.equipmentClass}"))
                #end
            
              #end
          
              $util.qr( $ctx.stash.put("catClassList",$catClasses))
        {
          "method": "POST",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/graphql",
          "params":{
              "body":{"query":"{\r\ngetSecondLevelCategoriesFromCatClass (\r\nequipments: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\"  #else ,\"$cat\" #end #end] \r\n) {\r\ncat_class\r\nequipment_name\r\nequipment_images\r\n\r\n}\r\n}","variables":{}},
              "headers": {
                  "Content-Type": "application/json",
                    ##"Authorization": "Bearer $ctx.args.token",
                    "x-activationid":"$!{ctx.stash.x-activationid}",
                    "guid":"$!{ctx.stash.guid}",
                    "access-token":"$!{ctx.stash.access-token}"
              }
          }
        }       
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
          {
              "equipmentList": 
              #if($ctx.stash.response.equipmentList.size()>0)
              [
              #foreach( $item in $ctx.stash.response.equipmentList )
                {
                  "equipmentBranchNumber": "$!{item.equipmentBranchNumber}",
                  "equipmentIC": "$!{item.equipmentIC}",
                  "equipmentName": "$!{item.equipmentName}",
                  "equipmentRentalStatus": "$!{item.equipmentRentalStatus}",
                  "fuelLevel": "$!{item.fuelLevel}",
                  "ignition": "$!{item.ignition}",
                  "city":"$!{ctx.stash.cities.get($item.equipmentBranchNumber)}",
                  "state":"$!{ctx.stash.states.get($item.equipmentBranchNumber)}",
              "equipmentCategory": "$!{item.equipmentCategory}",
                  "equipmentClass": "$!{item.equipmentClass}",
                  "latitude": $!{item.latitude},
                  "longitude": $!{item.longitude},
                  #if( $ctx.result.statusCode==200 )
                  #foreach( $imageItem in $util.parseJson($ctx.result.body).data.getSecondLevelCategoriesFromCatClass )
                  #set( $catClass = "${item.equipmentCategory}-${item.equipmentClass}" )
                    #if($imageItem.cat_class =="$!catClass")
                          "equipmentImage":$util.toJson($imageItem.equipment_images),
                    #end
                  #end
                  #end
                },
              #end
              ]
              #else
              []
              #end,
              "pageNumber": $!{ctx.stash.response.pageNumber} ,
              "pageSize": $!{ctx.stash.response.pageSize} ,
              "totalElements": $!{ctx.stash.response.totalElements} ,
              "totalPages": $!{ctx.stash.response.totalPages} 
            }


        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end 

   
  GetFleetAggregatedDeliveriesPickupsByAccountIDs:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetFleetAggregatedDeliveriesPickupsByAccountIDs Function
      FunctionVersion: 2018-05-29
      Name: GetFleetAggregatedDeliveriesPickupsByAccountIDs
      RequestMappingTemplate: |
        ## By default in a before template, all you need is a valid JSON payload.
        ## You can also stash data to be made available to the functions in the pipeline.
        ## Examples:
        ## - $ctx.stash.put("email", $ctx.args.email)
        ## - $ctx.stash.put("badgeNumber", $ctx.args.input.badgeNumber)
        ## - $ctx.stash.put("username", $ctx.identity.username)

        #foreach( $item in $ctx.args.customerIdsAndDivisionCodesCombinations )
        #if($item.customerNumber.trim()=="")
        $util.error("customerNumber can not be empty string.")
        #end
        #end
        #set( $accountIds = "" )
        #foreach( $item in $ctx.args.customerIdsAndDivisionCodesCombinations )
                #if($util.isNullOrEmpty($accountIds))
                    #set( $accountIds = "${item.customerNumber}" )
                #else 
                  #set( $accountIds = "${accountIds},${item.customerNumber}" )
                #end
        #if($item.divisionCode.trim()=="")
        $util.error("divisionCode can not be empty string.")
        #end
        #if($util.str.toUpper($item.divisionCode).trim()=="US")
        #set( $item.divisionCode = "HG" )
        $util.qr($ctx.stash.put("divisionCode","US"))
        #elseif($util.str.toUpper($item.divisionCode).trim()=="CAN")
        #set( $item.divisionCode = "CR" )
        $util.qr($ctx.stash.put("divisionCode","CAN"))
        $util.qr($ctx.stash.put("store","ca"))
        #else
        $util.error("Please select either US or CAN.")
        #end
        #end
        $util.qr($ctx.stash.put("accountIds","$accountIds"))

        {
          "version": "2018-05-29",
          "method": "POST",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/deliveries-pickups/aggregated-equipment-summary?page=$!{ctx.args.page}&pageSize=$!{ctx.args.pageSize}",
        "params":{
        "body":{"customerIdsAndDivisionCodesCombinations": $util.toJson($ctx.args.customerIdsAndDivisionCodesCombinations)},
        "headers":{
        "Content-Type": "application/json",
        ##"Authorization": "$ctx.request.headers.Authorization",
        "x-activationid":"$ctx.stash.x-activationid",
        "guid":"$ctx.stash.guid",
        "access-token":"$ctx.stash.access-token"
        }
        }
        }   
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500 )
            $util.error($util.toJson($util.parseJson($context.result.body).message))
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body)
        #end 

  getJobSiteFromMuleForAggregatedDeliveries:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt MuleEndpoint.Name
      Description: getJobSiteFromMuleForAggregatedDeliveries Function
      FunctionVersion: 2018-05-29
      Name: getJobSiteFromMuleForAggregatedDeliveries
      RequestMappingTemplate: |
        #set( $currentTimeEpoch = $util.time.nowEpochMilliSeconds())
        #set( $fromStartEpoch = $currentTimeEpoch - (1000 * 60 * 60 * 24 *183))
        #set($endDate= $util.time.epochMilliSecondsToFormatted($currentTimeEpoch, "yyyyMMdd"))
        #set($startDate= $util.time.epochMilliSecondsToFormatted($fromStartEpoch, "yyyyMMdd"))



        {
          "method": "GET",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/api/contract/credit/summary",
          "params":{
              "query":{
              "companyCode":"$ctx.stash.divisionCode",
              "customerNum":"$ctx.stash.accountIds",
              "contractType":"Open,Overdue,Closed",
              "page":1,
              "limit":0,
              "endDate":"$endDate",
              "startDate":"$startDate"
              },
              "headers": {
                    "Authorization": "$!{ctx.stash.mule-token}"
              }
          }
        }
      ResponseMappingTemplate: |
        {
        #if($ctx.stash.otgData.totalCount)"totalCount":$ctx.stash.otgData.totalCount, #end
        "otgStatusResponses": [
        #foreach( $item in $ctx.stash.otgData.otgStatusResponses ) 
      
            #if($velocityCount==1)
            {
              "branchCode":"$!{item.branchCode}",
              "contractNumber":"$!{item.contractNumber}",
          "equipmentIC":"$!{item.equipmentIC}",
          "catClass":"$!{item.catClass}",
          "equipmentName":"$!{item.equipmentName}",
          "equipmentCustomName":"$!{item.equipmentCustomName}",
              "status":"$!{item.status}",
              "pickupType":"$!{item.pickupType}",
                "scheduledDateTime":"$!{item.scheduledDateTime}",
                "deliveryDateTime":"$!{item.deliveryDateTime}",
          #if($ctx.result.statusCode == 200 )
                #foreach( $jb in $util.parseJson($ctx.result.body).contracts ) 
                  #set( $itemJobNo = $item.jobSiteNumber.replace("+"," ") )
                      #if($jb.jobLocationDetails.jobNumber=="$itemJobNo")
                      "jobSite" : {
                          "jobNumber" : "$!{jb.jobLocationDetails.jobNumber}",
                          "jobName" : "$!{jb.jobLocationDetails.jobName}",
                    "jobLoc" :"$!{jb.jobLocationDetails.address1}",
                  "jobCity" : "$!{jb.jobLocationDetails.city}",
                  "jobAddr1" : "$!{jb.jobLocationDetails.address1}",
                          "jobAddr2" : "$!{jb.jobLocationDetails.address2}",
                    "contactName" : "$!{jb.orderedBy}",
                    "jobPhone" : "$!{jb.jobLocationDetails.phone}",
                  "jobState" : "$!{jb.jobLocationDetails.state}",
                "jobZip" : "$!{jb.jobLocationDetails.zip}"
                      },
                #end
                #end
              #end
                #foreach( $imageItem in $ctx.prev.result.data.getSecondLevelCategoriesFromCatClass )
                #if($imageItem.cat_class =="$item.catClass")
                      "equipmentImage":$util.toJson($imageItem.equipment_images),
                    #end
              #end
          "jobSiteNumber":"$!{item.jobSiteNumber}"
            }
            #else
            , {
              "branchCode":"$!{item.branchCode}",
              "contractNumber":"$!{item.contractNumber}",
          "equipmentIC":"$!{item.equipmentIC}",
          "catClass":"$!{item.catClass}",
          "equipmentName":"$!{item.equipmentName}",
          "equipmentCustomName":"$!{item.equipmentCustomName}",
              "status":"$!{item.status}",
              "pickupType":"$!{item.pickupType}",
                "scheduledDateTime":"$!{item.scheduledDateTime}",
                "deliveryDateTime":"$!{item.deliveryDateTime}",
                
            #if($ctx.result.statusCode == 200 )
                #foreach( $jb in $util.parseJson($ctx.result.body).contracts ) 
                  #set( $itemJobNo = $item.jobSiteNumber.replace("+"," ") )
                      #if($jb.jobLocationDetails.jobNumber=="$itemJobNo")
                      "jobSite" : {
                          "jobNumber" : "$!{jb.jobLocationDetails.jobNumber}",
                          "jobName" : "$!{jb.jobLocationDetails.jobName}",
                    "jobLoc" :"$!{jb.jobLocationDetails.address1}",
                  "jobCity" : "$!{jb.jobLocationDetails.city}",
                  "jobAddr1" : "$!{jb.jobLocationDetails.address1}",
                          "jobAddr2" : "$!{jb.jobLocationDetails.address2}",
                    "contactName" : "$!{jb.orderedBy}",
                    "jobPhone" : "$!{jb.jobLocationDetails.phone}",
                  "jobState" : "$!{jb.jobLocationDetails.state}",
                "jobZip" : "$!{jb.jobLocationDetails.zip}"
                      },
                #end
                #end
              #end
                #foreach( $imageItem in $ctx.prev.result.data.getSecondLevelCategoriesFromCatClass )
                #if($imageItem.cat_class =="$item.catClass")
                      "equipmentImage":$util.toJson($imageItem.equipment_images),
                    #end
              #end
          "jobSiteNumber":"$!{item.jobSiteNumber}"

            }
            #end
        #end
            ]   
          }

  ImageAndjobSiteForAggregatedDeliveries:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: ImageAndjobSiteForAggregatedDeliveries Function
      FunctionVersion: 2018-05-29
      Name: ImageAndjobSiteForAggregatedDeliveries
      RequestMappingTemplate: |
        #set( $catClassList = [] )
        #foreach( $item in $ctx.prev.result.otgStatusResponses)
        $util.qr($catClassList.add("$!{item.catClass}"))
        #end 
        {
          "method": "POST",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/graphql",
          "params":{
          ##"body":{ "query":"{\r\n\r\n  products(filter: {sku: {in: [ #foreach( $cat in $ctx.stash.catClassList ) #if($velocityCount==1) \"$cat\"  #else ,\"$cat\" #end #end] }}) {\r\n    \r\n    items {\r\n        sku\r\n      equipment_images\r\n    }\r\n\r\n  }\r\n\r\n jobsiteAddress(jobNumber: \"3 - VENTURA YARD - V\") {\r\n      jobsiteNumber\r\n      jobsiteName\r\n      jobsiteAddress\r\n      jobsiteCity\r\n      jobsiteState\r\n      jobsiteZip\r\n      jobsitePhone\r\n      contactName\r\n   }\r\n\r\n\r\n\r\n  }","variables":{}},
          "body":{"query":"{\r\n getSecondLevelCategoriesFromCatClass (\r\nequipments: [ #foreach( $cat in $catClassList ) #if($velocityCount==1) \"$cat\"  #else ,\"$cat\" #end #end]\r\n) {\r\ncat_class\r\n equipment_images\r\n}\r\n\r\n\r\n\r\n}","variables":{}},
          "headers":{
          #if($ctx.stash.store)
                "store":"ca",
                #end
                  "Content-Type": "application/json",
                  ##"Authorization": "Bearer ${ctx.stash.token}",
                  ##"x-activationid":"${ctx.stash.x-activationid}",
                  "guid":"${ctx.stash.guid}",
                ##"Authorization":"${ctx.stash.authorization}"
            }
          }
        }
      ResponseMappingTemplate: |
        $util.qr($ctx.stash.put("otgData",$ctx.prev.result))
        $ctx.result.body

  getFleetUtilizationDetails:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getFleetUtilizationDetails Function
      FunctionVersion: 2018-05-29
      Name: getFleetUtilizationDetails
      RequestMappingTemplate: |
        #**The value of 'payload' after the template has been evaluated
          will be passed as the event to AWS Lambda.
          *#
          #set( $headers = {} )

          $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
          $util.qr($headers.put("guid","$ctx.stash.guid"))
          $util.qr($headers.put("access-token","$ctx.stash.access-token"))

          #set( $lambdaRq = {} )
          $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/account/fleetutilizationdetails"))
          ##$util.qr($lambdaRq.put("requestBody",$var))
          $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
          $util.qr($lambdaRq.put("headers",$!{headers}))
          $util.qr($lambdaRq.put("requestMethod","GET"))

          {
            "operation": "Invoke",
            "payload": $util.toJson($lambdaRq)
          }         
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #elseif($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
            $util.error($util.parseJson($ctx.result.body).errorMessage, "$ctx.result.statusCode")
        #end


  GetFleetAggregatedUtilizationViewByAccountIDs:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetFleetAggregatedUtilizationViewByAccountIDs Function
      FunctionVersion: 2018-05-29
      Name: GetFleetAggregatedUtilizationViewByAccountIDs
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#

        #if( !$ctx.args.input.customerIdsAndDivisionCodesCombinations )
          $util.error("customerIdsAndDivisionCodesCombinations can't be missing.")
        #end
        #if( $ctx.args.input.customerIdsAndDivisionCodesCombinations.size()==0 )
          $util.error("customerIdsAndDivisionCodesCombinations can't be empty.")
        #end

        #foreach( $item in $ctx.args.input.customerIdsAndDivisionCodesCombinations )
          #if( !$item.customerNumber || $item.customerNumber.trim()=="")
              $util.error("customerNumber can't be missing or an empty string..")
          #end
          #if( !$item.divisionCode || $item.divisionCode.trim()=="")
              $util.error("divisionCode can't be missing or an empty string..")
          #end
          #if($item.divisionCode && $util.str.toUpper($item.divisionCode) == "US")
              #set( $item.divisionCode = "HG" )
          #elseif($item.divisionCode && $util.str.toUpper($item.divisionCode) == "CAN")
              #set( $item.divisionCode = "CR" )
          #else
              $util.error("Please select US or CAN as a divisionCode.")
          #end
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        ## $util.qr($query.put("jobNumber","$!{ctx.args.jobNumber}"))
        ## $util.qr($query.put("page",$!{ctx.args.page}))
        ## $util.qr($query.put("pageSize",$!{ctx.args.pageSize}))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/fleet/aggregated-details/utilization"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   

      ResponseMappingTemplate: |

        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 400 || $ctx.result.statusCode == 500)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end



  GetJobsitedetailsbyEquipmentICs:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetJobsitedetailsbyEquipmentICs Function
      FunctionVersion: 2018-05-29
      Name: GetJobsitedetailsbyEquipmentICs
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        ## $util.qr($query.put("jobNumber","$!{ctx.args.jobNumber}"))
        ## $util.qr($query.put("page",$!{ctx.args.page}))
        ## $util.qr($query.put("pageSize",$!{ctx.args.pageSize}))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-summary/jobsite?page=$!{ctx.args.page}&pageSize=$!{ctx.args.pageSize}"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","POST"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
        ## In order to retain the same execution behavior for 2017-02-28 templates
        ## you might have to uncomment the following code below.
        ## For more details about changes from 2017-02-28 to 2018-05-29 see 
        ## https://docs-aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-changelog.html
        ##
        ## #if($ctx.error)
        ##   $util.error($ctx.error.message, $ctx.error.type)
        ## #end
        ## #if($util.isNull($ctx.result))
        ##   #return
        ## #end

        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end


  GetEquipmentSummaryForJobsite:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetEquipmentSummaryForJobsite Function
      FunctionVersion: 2018-05-29
      Name: GetEquipmentSummaryForJobsite
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-jobsite-summary/details"))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }               
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 400 || $ctx.result.statusCode == 500)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end          


  GetDeviceLocationHistory:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetDeviceLocationHistory Function
      FunctionVersion: 2018-05-29
      Name: GetDeviceLocationHistory
      RequestMappingTemplate: |
        #if( $ctx.args.equipmentIC=="" || $ctx.args.equipmentIC==" ")
        $util.error("equipmentIC Number can't be empty")

        #elseif( $ctx.args.customerNumber=="" || $ctx.args.customerNumber==" ")
        $util.error("Customer Number can't be empty")
        
        #else 

        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        ## $util.qr($query.put("jobNumber","$!{ctx.args.jobNumber}"))
        ## $util.qr($query.put("page",$!{ctx.args.page}))
        ## $util.qr($query.put("pageSize",$!{ctx.args.pageSize}))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-summary/devicehistory"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   

        #end                
      ResponseMappingTemplate: |           
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end


  GetEquipmentUtilizationTimeline:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetDeviceLocationHistory Function
      FunctionVersion: 2018-05-29
      Name: GetDeviceLocationHistory
      RequestMappingTemplate: |
        #if($util.str.toUpper($ctx.args.divisionCode) == "CAN")
        #set($ctx.args.divisionCode = "CR")
        #elseif($util.str.toUpper($ctx.args.divisionCode) == "US")
        #set( $ctx.args.divisionCode = "HG" )
        #else
        $util.error("Please select either CAN or US as divisionCode")
        #end
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-summary/utilizationtimelinegraph"))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }               
      ResponseMappingTemplate: |           
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        $ctx.result.body
        #elseif($ctx.result.statusCode == 400)
        $util.error("Please check input parameters")
        #else
        $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  GetBranchCode:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetBranchCode Function
      FunctionVersion: 2018-05-29
      Name: GetBranchCode
      RequestMappingTemplate: |
        #if( $ctx.args.contractNumber==" " ||  $ctx.args.contractNumber=="") 
        $util.error("Contract Number can't be empty")

        #elseif( $ctx.args.equipmentIC==" " ||  $ctx.args.equipmentIC=="") 
        $util.error("Equipment IC can't be empty")

        #else
        #if($ctx.args.divisionCode && $util.str.toUpper($ctx.args.divisionCode) == "CAN")
        #set($ctx.args.divisionCode = "CR")
        #else
        #set( $ctx.args.divisionCode = "HG" )
        #end
        #set( $div = $ctx.args.divisionCode )
        #set( $contractNumber = $ctx.args.contractNumber )
        #set( $equipmentIC = $ctx.args.equipmentIC )
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteledeliverypickupapi.hercrentals.com/deliveries-pickups/contracts/$contractNumber/equipments/$equipmentIC/divisionCode/$div"))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
        #end
      ResponseMappingTemplate: |           
        ## Raise a GraphQL field error in case of a datasource invocation error
        $util.qr($ctx.stash.put("equipmentStatusAndInfo",$util.parseJson($ctx.result.body)))

        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        $ctx.result.body
        #elseif( $ctx.result.statusCode==400 || $ctx.result.statusCode==404)
        $util.error("Data Not found for given contract Number and equipmentIC. Please check the contract Number and equipmentIC")
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end
  
  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetAccountAutoAddEqStatus
  #-----------------------------------------------------------------------------

  GetMuleDataForPickUps:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt MuleEndpoint.Name
      Description: GetMuleDataForPickUps Function
      FunctionVersion: 2018-05-29
      Name: GetMuleDataForPickUps
      RequestMappingTemplate: |
        {
            "method": "GET",
            ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/api/scheduledpickups?companyCode=${ctx.args.divisionCode}&customerNumber=${ctx.args.accountId}&contractNumber=${ctx.args.contractNumber}",
            "params":{
                "headers": {
                    "Authorization": "$ctx.prev.result.access_token"
                }
            }
        }
      ResponseMappingTemplate: |

        {
            "method": "GET",
            ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/api/scheduledpickups?companyCode=${ctx.args.divisionCode}&customerNumber=${ctx.args.accountId}&contractNumber=${ctx.args.contractNumber}",
            "params":{
                "headers": {
                    "Authorization": "$ctx.prev.result.access_token"
                }
            }
        }

  GetServicingBranchDetails:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: GetServicingBranchDetails Function
      FunctionVersion: 2018-05-29
      Name: GetServicingBranchDetails
      RequestMappingTemplate: |
        {
          "method": "POST",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/graphql",
          "params":{
              ##"body": {"query":"\r\n{\r\n getBranchDetailsByBranchNumber(branchNumber:[$ctx.stash.equipmentStatusAndInfo.branchCode]) {\r\nbranchDetails{\r\nbranchname\r\nbranchcode\r\nbranchnumber\r\nbranchtype\r\naddresslatitude\r\naddresslongitude\r\naddress\r\nphone\r\ncity\r\nstate\r\ncountry\r\nzip\r\ntimings\r\nbranchimageurl\r\n}\r\n} getJobsiteOnsiteBranchDetails (accountNumber:\"$!{ctx.args.accountId}\",customerId:\"$!{ctx.stash.customerId}\")\r\n    {\r\n    companyCode\r\n    jobsiteDetails {\r\n        jobsiteNumber\r\n        jobsiteName\r\n        jobsiteAddress\r\n        jobsiteCity\r\n        jobsiteLoc\r\n        jobsiteState\r\n        jobsiteZip\r\n        addresslatitude\r\n        addresslongitude\r\n        jobsitePhone\r\n        contactName\r\n    }\r\n    }\r\n\r\n\r\n\r\n}","variables":{}},
              ##"body": {"query":"\r\n{\r\ngetBranchDetails(branchCode:[112]) {\r\nbranchDetails{\r\nbranchname\r\nbranchcode\r\nbranchnumber\r\nbranchtype\r\naddresslatitude\r\naddresslongitude\r\naddress\r\nphone\r\ncity\r\nstate\r\ncountry\r\nzip\r\ntimings\r\nbranchimageurl\r\n}\r\n} jobsiteAddress(jobNumber: \"${ctx.stash.equipmentStatusAndInfo.jobSiteNumber}\") {\r\n      jobsiteNumber\r\n      jobsiteName\r\n      jobsiteAddress\r\n      jobsiteCity\r\n      jobsiteState\r\n      jobsiteZip\r\n      jobsitePhone\r\n      contactName\r\n   }\r\n\r\n\r\n\r\n}","variables":{}},
              "body":  {"query":"{\r\n  getJobsiteOnsiteBranchDetails (accountNumber:\"$!{ctx.args.accountId}\",customerId:\"$!{ctx.stash.customerId}\")\r\n    {\r\n    companyCode\r\n    jobsiteDetails {\r\n        jobsiteNumber\r\n        jobsiteName\r\n        jobsiteAddress\r\n        jobsiteCity\r\n        jobsiteLoc\r\n        jobsiteState\r\n        jobsiteZip\r\n        addresslatitude\r\n        addresslongitude\r\n        jobsitePhone\r\n        contactName\r\n    }\r\n    }\r\n\r\n    \r\n  getBranchDetailsByBranchNumber(branchNumber:[$ctx.stash.equipmentStatusAndInfo.branchCode]) \r\n  { \r\n  branchDetails\r\n  {  \r\n  branchname \r\n  branchcode \r\n  branchnumber  \r\n  branchtype  \r\n  addresslatitude\r\n  addresslongitude  \r\n  address \r\n  phone  \r\n  city  \r\n  state  \r\n  country  \r\n  zip  \r\n  timings  \r\n  branchimageurl \r\n  } \r\n  } \r\n}","variables":{}},
              "headers": {
                  "Content-Type": "application/json",
                  "Authorization":"$ctx.stash.authorization"
              }
          }
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        {
          "branchCode": "$!{ctx.stash.equipmentStatusAndInfo.branchCode}",
          "rentalAgreement":  "$!{ctx.stash.equipmentStatusAndInfo.contractNumber}",
          "equipmentIC":  "$!{ctx.stash.equipmentStatusAndInfo.equipmentIC}",
          "catClass":  "$!{ctx.stash.equipmentStatusAndInfo.catClass}",
          "equipmentName":  "$!{ctx.stash.equipmentStatusAndInfo.equipmentName}",
          "equipmentCustomName":  "$!{ctx.stash.equipmentStatusAndInfo.equipmentCustomName}",
          "jobSiteNumber":  "$!{ctx.stash.equipmentStatusAndInfo.jobSiteNumber}",
          "status":  "$!{ctx.stash.equipmentStatusAndInfo.status}",
          "pickupType":  "$!{ctx.stash.equipmentStatusAndInfo.pickupType}",
          "scheduledDateTime":  "$!{ctx.stash.equipmentStatusAndInfo.scheduledDateTime}",
          "deliveryDateTime":   "$!{ctx.stash.equipmentStatusAndInfo.deliveryDateTime}",
          "deliveryInstructions":  "$!{ctx.stash.equipmentStatusAndInfo.deliveryOrPickupNote}",

          
          #foreach( $pickUpItem in $ctx.prev.result )
          #foreach( $equipItem in $pickUpItem.equipmentDetails )
            #if($ctx.stash.equipmentStatusAndInfo.equipmentIC=="${equipItem.equipNumber}")
              "pickupDetails":{
              "ticketNum": $!{pickUpItem.pickupTicket},
              "contractNum":  $!{pickUpItem.contractNum},
              ##"contractSeq":  $!{pickUpItem.contractSeq},
              "pickupStatus": "$!{pickUpItem.pickupStatus}",
              "equipCatClass":  "$!{equipItem.equipCatClass}",
              "iCNumber":  "$!{equipItem.equipNumber}",
              ##"comments":  "$!{pickUpItem.comments}",
              "releasedBy": "$!{pickUpItem.orderedBy}",
              "date":  $!{pickUpItem.pickupDate},
              "time":  $!{pickUpItem.pickupTime}
                },
          #end
          #end
          #end
              
        
          #if($ctx.result.statusCode == 200)
          #set($jobSites = $util.parseJson($ctx.result.body).data.getJobsiteOnsiteBranchDetails.jobsiteDetails )
            #foreach( $jb in $jobSites )
            #if($jb.jobsiteNumber == "$ctx.stash.equipmentStatusAndInfo.jobSiteNumber")
                      "jobSite" : {
                          "jobNumber" : "$!{jb.jobsiteNumber}",
                          "jobName" : "$!{jb.jobsiteName}",
                    "jobLoc" :"$!{jb.jobsiteLoc}",
                  "jobCity" : "$!{jb.jobsiteCity}",
                  "jobAddr1" : "$!{jb.jobsiteAddress}",
                          "jobAddr2" : "",
                    "contactName" : "$!{jb.contactName}",
                    "jobPhone" : "$!{jb.jobsitePhone}",
                  "jobState" : "$!{jb.jobsiteState}",
                "jobZip" : "$!{jb.jobsiteZip}",
                        "addressLatitude": "$!{jb.addresslatitude}",
                        "addressLongitude": "$!{jb.addresslongitude}"
                      },
                    #end
                #end
          #end
          "driverInfo": {
            "driverId": "$!{ctx.stash.equipmentStatusAndInfo.driverInfo.driverId}",
            "firstName":  "$!{ctx.stash.equipmentStatusAndInfo.driverInfo.firstName}",
            "lastName":  "$!{ctx.stash.equipmentStatusAndInfo.driverInfo.lastName}",
            "phone":  "$!{ctx.stash.equipmentStatusAndInfo.driverInfo.phone}",
            "truckType":  "$!{ctx.stash.equipmentStatusAndInfo.driverInfo.truckType}",
            "isHauler":  "$!{ctx.stash.equipmentStatusAndInfo.driverInfo.hauler}"
          },
          "equipmentInfo": {
              "equipmentId": "$!{ctx.stash.equipmentStatusAndInfo.equipmentInfo.equipmentId}",
              "equipmentNumber": "$!{ctx.stash.equipmentStatusAndInfo.equipmentInfo.equipmentNumber}",
              "make": "$!{ctx.stash.equipmentStatusAndInfo.equipmentDetails.make}",
              "model": "$!{ctx.stash.equipmentStatusAndInfo.equipmentDetails.model}",
              "serialNumber": "$!{ctx.stash.equipmentStatusAndInfo.equipmentDetails.serialNumber}",
              "catClass": "$!{ctx.stash.equipmentStatusAndInfo.equipmentInfo.catClass}",
              "quantity": $!{ctx.stash.equipmentStatusAndInfo.equipmentInfo.quantity},
              "condition": "$!{ctx.stash.equipmentStatusAndInfo.equipmentInfo.condition}",
              "deliveryImages": [
                  #foreach( $image in  $ctx.stash.equipmentStatusAndInfo.equipmentInfo.images )
                  {
                      "imageUri": "$!{image.imageUri}",
                      "imageName": "$!{image.imageName}",
                      "photoTakenAt": "$!{image.photoTakenAt}",
                      "latLong": "$!{image.latLong}"
                  },
              #end
              ]
          },
          "description": "$!{ctx.stash.equipmentStatusAndInfo.description}",
          "servingBranch": 
          #if($util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails.size()>0)
          {
              "address": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].address}",
              "addressLatitude": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].addresslatitude}",
              "addressLongitude": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].addresslongitude}",
              "branchName": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].branchname}",
              "branchNumber": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].branchnumber}",
              "branchType": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].branchtype}",
              "city": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].city}",
              "country": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].country}",
              "phone": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].phone}",
              "state": "$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].state}",
              "zip":"$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].zip}",
              "image":"$!{util.parseJson($ctx.result.body).data.getBranchDetailsByBranchNumber.branchDetails[0].branchimageurl}"

        }
          #else
          {
              "address": "",
              "addressLatitude": "",
              "addressLongitude": "",
              "branchName": "",
              "branchNumber": "",
              "branchType": "",
              "city": "",
              "country": "",
              "phone": "",
              "state": "",
              "zip":"",
              "image":""
        
          }
          #end
        }

  getEquipmentLocation:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getEquipmentLocation Function
      FunctionVersion: 2018-05-29
      Name: getEquipmentLocation
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
            "EquipmentIdentifier": $util.dynamodb.toDynamoDBJson($ctx.args.ic),
            }
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
            $util.appendError($ctx.error.message, $ctx.error.type)
        #end
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)

  getEquipmentDiagnosticsAndSafety:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getEquipmentDiagnosticsAndSafety Function
      FunctionVersion: 2018-05-29
      Name: getEquipmentDiagnosticsAndSafety
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-summary"))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
        #if($ctx.result.statusCode == 400)
        $util.error("BAD REQUEST")
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        {
        "deviceInfo": {
        "batteryLifeRemaining": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].batteryLifeRemaining) $util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].batteryLifeRemaining #else null #end,
        "engineRPM": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].engineRPM)$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].engineRPM #else null #end,
        "fuelEconomyAverage":#if($util.parseJson($ctx.result.body).diagnostics.equipment[0].fuelEconomyAverage)$util.parseJson($ctx.result.body).diagnostics.equipment[0].fuelEconomyAverage #else null #end,
        "hardBrakingCount": #if($util.parseJson($ctx.result.body).diagnostics.equipment[0].hardBrakingCount)$util.parseJson($ctx.result.body).diagnostics.equipment[0].hardBrakingCount #else null #end,
        "hardAccelarationCount":#if($util.parseJson($ctx.result.body).diagnostics.equipment[0].hardAccelarationCount)$util.parseJson($ctx.result.body).diagnostics.equipment[0].hardAccelarationCount #else null #end,
        "gpsunit": "$!{util.parseJson($ctx.result.body).diagnostics.equipment[0].gpsunit}",
        "gpsmake":"$!{util.parseJson($ctx.result.body).diagnostics.equipment[0].gpsmake}",
        "oilLevel": #if($util.parseJson($ctx.result.body).diagnostics.equipment[0].oilLevel) $util.parseJson($ctx.result.body).diagnostics.equipment[0].oilLevel #else null #end,
        "oilPressure": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].oilPressure) $util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].oilPressure #else null #end,
        "coolantLevel": #if($util.parseJson($ctx.result.body).diagnostics.equipment[0].coolantLevel)$util.parseJson($ctx.result.body).diagnostics.equipment[0].coolantLevel #else null #end,
        "oilTemperature": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].oilTemperature)$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].oilTemperature #else null #end,
        "fuelRange": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].fuelRange)"$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].fuelRange" #else null #end,
        "seatBeltLatched": "$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].seatbeltLatched",
        "temperature": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].temperature) $util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].temperature #else null #end,
        "tirePressure":{
        "tirePressureLF":#if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].tirepressure.tirePressureLF) $util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].tirepressure.tirePressureLF #else null #end,
        "tirePressureLR":#if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].tirepressure.tirePressureLR)$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].tirepressure.tirePressureLR #else null #end,
        "tirePressureRF":#if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].tirepressure.tirePressureRF)$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].tirepressure.tirePressureRF #else null #end,
        "tirePressureRR":#if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].tirepressure.tirePressureRR)$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].tirepressure.tirePressureRR #else null #end
        } ,
        "humidity": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].humidity)"$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].humidity" #else null #end,
        "ambientAirTemperature": "$!{util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].ambientAirTemperature}"
        },
        "equipment": [
        {
        "name": "$!{util.parseJson($ctx.result.body).equipmentName}",
        "ignition": $!{util.parseJson($ctx.result.body).diagnostics.equipment[0].ignitionStatus},
        "batteryVoltage": #if($util.parseJson($ctx.result.body).diagnostics.equipment[0].batteryVoltage)$util.parseJson($ctx.result.body).diagnostics.equipment[0].batteryVoltage #else null #end,
        "engineCoolantTemp": "$!{util.parseJson($ctx.result.body).diagnostics.equipment[0].engineCoolanttemp}",
        "engineLoad": #if($util.parseJson($ctx.result.body).diagnostics.equipment[0].engineLoad)$util.parseJson($ctx.result.body).diagnostics.equipment[0].engineLoad #else null #end,
        "fuelConsumption": #if($util.parseJson($ctx.result.body).diagnostics.equipment[0].fuelConsumption)$util.parseJson($ctx.result.body).diagnostics.equipment[0].fuelConsumption #else null #end,
        "fuelLevel": #if($util.parseJson($ctx.result.body).diagnostics.equipment[0].fuelLevel)$util.parseJson($ctx.result.body).diagnostics.equipment[0].fuelLevel #else null #end,
        "defLevel": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].defLevel)$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].defLevel #else null #end,
        "oilLevel": #if($util.parseJson($ctx.result.body).diagnostics.equipment[0].oilLevel)$util.parseJson($ctx.result.body).diagnostics.equipment[0].oilLevel #else null #end,
        "Latitude": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].latitude)$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].latitude #else 0 #end,
        "Longitude": #if($util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].longitude)$util.parseJson($ctx.result.body).diagnostics.devicePeriodicMessages[0].longitude #else 0 #end,
        "equipmentCustomName":#if($util.parseJson($ctx.result.body).equipmentCustomName)"$!util.parseJson($ctx.result.body).equipmentCustomName" #else null #end,
        "alertCount": $!util.parseJson($ctx.result.body).alerts.size()
        }
        ]
        }
        #else
        $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end
         
  EquipmentlistInAccount:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt EquipmentlistInAccountlambda.Name 
      Description: EquipmentlistInAccount Function
      FunctionVersion: 2018-05-29
      Name: EquipmentlistInAccount
      RequestMappingTemplate: |
        #set( $body = {} )

        $util.qr($body.put("customerNumber","$context.args.customerNumber"))
        $util.qr($body.put("contractType","Open,Overdue"))
        $util.qr($body.put("page","$context.args.page"))
        $util.qr($body.put("pageSize","$context.args.pageSize"))
        $util.qr($body.put("divisionCode","$context.args.divisionCode"))
        $util.qr($body.put("teleApiPath","/account/equipment-details"))
        #if( $context.args.divisionCode =="HG" )
        $util.qr($body.put("companyCode","US"))
        #end
        #if( $context.args.divisionCode =="CR" )
        $util.qr($body.put("companyCode","CAN"))
        #end

        #set( $header = {} )
        $util.qr($header.put("guid","$ctx.stash.guid"))
        $util.qr($header.put("activationId","$ctx.stash.x-activationid"))
        $util.qr($header.put("accesstoken","$ctx.stash.access-token"))

        #set( $rq = {} )
        $util.qr($rq.put("headers",$header))
        $util.qr($rq.put("body",$body))


        {
          "version" : "2017-02-28",
          "operation": "Invoke",
          "payload": $util.toJson($rq)
        }
      ResponseMappingTemplate: |
        #if($context.result.statusCode==200)
        $util.toJson($context.result.body)
        #else
        $utils.error("$ctx.result.body.errorMessage", "$ctx.result.statusCode")
        #end

  fetchAlertsByCustomerNumberAndIC:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: fetchAlertsByCustomerNumberAndIC Function
      FunctionVersion: 2018-05-29
      Name: fetchAlertsByCustomerNumberAndIC
      RequestMappingTemplate: |
        #if( $ctx.args.customerNumber==""  || $ctx.args.customerNumber==" " )
          $util.error("Account ID can't be null or empty")
        #end

        #if( $ctx.args.ic=="" || $ctx.args.ic==" " )
          $util.error("IC Number can't be null or empty")
        #end
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-summary"))
        ##$util.qr($lambdaRq.put("requestBody",$var))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($context.result)

  getEquipmentUtilizationDetails:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getEquipmentUtilizationDetails Function
      FunctionVersion: 2018-05-29
      Name: getEquipmentUtilizationDetails
      RequestMappingTemplate: |
        #if( !$ctx.args.customerNumber || $ctx.args.customerNumber.trim()=="")
        $util.error("customerNumber is missing or empty")
        #end
        #if( !$ctx.args.equipmentIC || $ctx.args.equipmentIC.trim()=="")
        $util.error("equipmentIC is missing or empty")
        #end
        #if( !$ctx.args.divisionCode || $ctx.args.divisionCode.trim()=="")
        $util.error("divisionCode is missing or empty")
        #end
        #if( !$ctx.args.startDate || $ctx.args.startDate.trim()=="")
        $util.error("startDate is missing or empty")
        #end
        #if( !$ctx.args.endDate || $ctx.args.endDate.trim()=="")
        $util.error("endDate is missing or empty")
        #end



        #if($util.str.toUpper($ctx.args.divisionCode) == "CAN")
        #set($ctx.args.divisionCode = "CR")
        #elseif($util.str.toUpper($ctx.args.divisionCode) == "US")
        #set( $ctx.args.divisionCode = "HG" )
        #else
        $util.error("Please select either CAN or US as divisionCode")
        #end
                #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-summary/utilizationdetails"))
        ##$util.qr($lambdaRq.put("requestBody",$var))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 200)
        #return($util.parseJson($context.result.body))
        #elseif($ctx.result.statusCode == 400)
        $util.error("Please check input parameters.")
        #else
        $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  getDiagnosticTroubleCode:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getDiagnosticTroubleCode Function
      FunctionVersion: 2018-05-29
      Name: getDiagnosticTroubleCode
      RequestMappingTemplate: |
        #if($util.str.toUpper($ctx.args.divisionCode) == "CAN")
        #set($ctx.args.divisionCode = "CR")
        #elseif($util.str.toUpper($ctx.args.divisionCode) == "US")
        #set( $ctx.args.divisionCode = "HG" )
        #else
        $util.error("Please select either CAN or US as division")
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/dtc-api/diagnostic-trouble-codes"))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end          

  GetFleetUtilization:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetFleetUtilization Function
      FunctionVersion: 2018-05-29
      Name: GetFleetUtilization
      RequestMappingTemplate: |
        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/account/fleetutilizationsummary"))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }       
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.error($ctx.result.body, "$ctx.result.statusCode")
        #end 

  GetJobSiteDetailsbyAccountID:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetJobSiteDetailsbyAccountID Function
      FunctionVersion: 2018-05-29
      Name: GetJobSiteDetailsbyAccountID
      RequestMappingTemplate: |
        #if($ctx.args.accountId.trim()=="")
        $util.error("accountId can't be null or empty string.")
        #end
        #if($ctx.args.divisionCode.trim()=="")
        $util.error("divisionCode can't be null or empty string.")
        #end
        #if($ctx.args.jobNumber.trim()=="")
        $util.error("jobNumber can't be null or empty string.")
        #end

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/equipment-jobsite-summary"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }           
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #set( $jobsite = [] )
        #if($ctx.result.statusCode == 200)
            $context.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end

  GetBranchEquipmentDetails:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: GetBranchEquipmentDetails Function
      FunctionVersion: 2018-05-29
      Name: GetBranchEquipmentDetails
      RequestMappingTemplate: |
        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/branch-equipment-summary/equipmentdetails"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400||$ctx.result.statusCode==404)
        $util.error($util.parseJson($ctx.result.body).errorMessage)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end     

  getEquipmentSummaryFromRentalMan:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt EquipmentSummaryRentalManDataLambda.Name  ##DataSource
      Description: getEquipmentSummaryFromRentalMan Function
      FunctionVersion: 2018-05-29
      Name: getEquipmentSummaryFromRentalMan
      RequestMappingTemplate: |
        #if(!$ctx.args.equipmentIC)
        $util.error("equipmentId must be present in query.")
        #end
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))
        $util.qr($context.stash.put("accountId",$context.args.accountId))
        $util.qr($context.args.remove("accountId"))
        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": {
          "equipmentIC":"$context.args.equipmentIC"
          }
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  fetchContractRentalForRentalman:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt MuleEndpoint.Name  ##DataSource
      Description: fetchContractRentalForRentalman Function
      FunctionVersion: 2018-05-29
      Name: fetchContractRentalForRentalman
      RequestMappingTemplate: |
        #if($ctx.args.divisionCode && $util.str.toUpper($ctx.args.divisionCode) == "CAN")
        #set($ctx.args.divisionCode = "CAN")
        #elseif($ctx.args.divisionCode && $util.str.toUpper($ctx.args.divisionCode) == "US")
        #set( $ctx.args.divisionCode = "US" )
        #end
        #set( $endDate = $util.time.nowFormatted("yyyyMMdd"))

        {
          "method": "GET",
          ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
          "resourcePath": "/api/contract/credit/summary",
          "params":{
              "query":{
              "companyCode":"$ctx.args.divisionCode",
              "customerNum":"$ctx.stash.accountId",
              "contractType":"Open,Overdue",
              "page":1,
              "limit":-1,
              "endDate":"$endDate",
              "startDate":"19000101"
              },
              "headers": {
                  ## "Authorization": "$ctx.stash.muleToken"
              }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #set( $cs = "" )
        #set( $rt = "" )
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200||$ctx.result.statusCode == 404||$ctx.result.statusCode == 400||$ctx.result.statusCode == 500||$ctx.result.statusCode == 505)
        ## If response is 200, return the body.
        #foreach( $itr in $util.parseJson($ctx.result.body).contracts )
        #if( $ctx.prev.result.equipmentSummaryDto.contract.contractNumber == $itr.contractNumber )
        #set( $cs = $itr.contractSequence )
        #end
        #if( $ctx.prev.result.equipmentSummaryDto.contract.contractNumber == $itr.contractNumber )
        #set( $rt = $itr.contractType )
        #end
        #end
        $util.qr($ctx.prev.result.equipmentSummaryDto.contract.put("contractSequence",$cs))
        $util.qr($ctx.prev.result.equipmentSummaryDto.contract.put("rentalType",$rt))
        #end
        $util.toJson($ctx.prev.result)   

  getJobSiteForRentalMan:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: getJobSiteForRentalMan Function
      FunctionVersion: 2018-05-29
      Name: getJobSiteForRentalMan
      RequestMappingTemplate: |
        #set( $jobNumber = $ctx.prev.result.equipmentSummaryDto.contract.jobNumber)
        #set( $accountId = $ctx.stash.accountId )
        ## { getJobsite(accountNumber: \"$accountId\", jobNumber:\"$jobNumber\")
        {
        "method": "POST",
        ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
        "resourcePath": "/graphql",
        "params":{
        "body":{"query":"{ getJobsite(accountNumber: \"$accountId\", jobNumber:\"$jobNumber\") {\r\n jobSites{\r\n jobNumber\r\n jobName\r\n jobAddr1\r\n jobAddr2\r\n jobCity\r\n jobLoc\r\n jobState\r\n jobZip\r\n jobPhone\r\n contactName\r\n }\r\n \r\n }\r\n \r\n}","variables":{}},
        "headers":{
        #if($ctx.args.divisionCode && $util.str.toUpper($ctx.args.divisionCode) == "CAN")
        "store":"ca",
        #end
        "Content-Type": "application/json",
        "Authorization": "$ctx.stash.authorization",
        "x-activationid":"$!{ctx.stash.x-activationid}",
        "guid":"$!{ctx.stash.guid}",
        "access-token":"$!{ctx.stash.access-token}"
        }
        }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 )
        $util.error($util.parseJson($ctx.result).errorMessage)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        ## If response is 200, return the body.
        $util.qr($ctx.prev.result.equipmentSummaryDto.customer.put("jobSite",$util.parseJson($ctx.result.body).data.getJobsite.jobSites))
        #end
        $util.toJson($ctx.prev.result)
       

  #-----------------------------------------------------------------------------
  # This is for functions phase-5
  #-----------------------------------------------------------------------------
  
  getFleetAggregatedAlertsByAccountId:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: getFleetAggregatedAlertsByAccountId Function
      FunctionVersion: 2018-05-29
      Name: getFleetAggregatedAlertsByAccountId
      RequestMappingTemplate: |
        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelealertapi.hercrentals.com/fleet/aggregated-details/alert"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
          #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
          #end
          #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
            $util.error($util.parseJson($ctx.result.body).error)
          #end
          ## If the response is not 200 then return an error. Else return the body **
          #if($ctx.result.statusCode == 200)
              $ctx.result.body
          #else
              $util.error($ctx.result.body, "$ctx.result.statusCode")
          #end

  DeliveryPickUpDetailsFromTelematics:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: DeliveryPickUpDetailsFromTelematics Function
      FunctionVersion: 2018-05-29
      Name: DeliveryPickUpDetailsFromTelematics
      RequestMappingTemplate: |
        #if( $ctx.args.contractNumber==" " ||  $ctx.args.contractNumber=="") 
        $util.error("Contract Number can't be empty")

        #elseif( $ctx.args.equipmentIc==" " ||  $ctx.args.equipmentIc=="") 
        $util.error("Equipment IC can't be empty")

        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        $util.qr($headers.put("accountId","$ctx.args.accountID"))
        $util.qr($headers.put("divisionCode","$ctx.args.divisionCode"))
        $util.qr($headers.put("equipmentIC","$ctx.args.equipmentIC"))


        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgteledeliverypickupapi.hercrentals.com//deliveries-pickups/contracts/$ctx.args.contractNumber/equipments/$ctx.args.equipmentIc"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }   
      ResponseMappingTemplate: |                       
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $util.error($ctx.result.body , "$ctx.result.statusCode")
            ##$utils.appendError($util.toJson($ctx.result.body), "$ctx.result.statusCode")
        #end            

  JobSiteServingBranchImageaftertelematicsdeliverypickup:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt CommerceDs.Name
      Description: JobSiteServingBranchImageaftertelematicsdeliverypickup Function
      FunctionVersion: 2018-05-29
      Name: JobSiteServingBranchImageaftertelematicsdeliverypickup
      RequestMappingTemplate: |
        #set( $jobNumber = $ctx.prev.result.jobSiteNumber.replace(" ", "+") )
        #set( $catClass = $ctx.prev.result.catClass )
        #set( $branchCode = $ctx.prev.result.branchCode )
        #set( $accountId = $ctx.args.accountId )

        ##set( $jobNumber = "CORPORATE+OFFICE" )
        ##set( $catClass = "400-1085")
        ##set( $branchCode = "112" )
        ##set( $accountId = "459830" )
        {
            "method": "POST",
            ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
            "resourcePath": "/graphql",
            "params":{
                "body":{"query":"{\r\n\r\n\r\n  products(filter: {sku: {in: [\"$catClass\"]}}) {\r\n    items {\r\n      equipment_images\r\n    }\r\n  }\r\n\r\n\r\ngetBranchDetails(branchCode:[$branchCode]) {\r\nbranchDetails{\r\nbranchname\r\nbranchcode\r\nbranchnumber\r\nbranchtype\r\naddresslatitude\r\naddresslongitude\r\naddress\r\nphone\r\ncity\r\nstate\r\ncountry\r\nzip\r\ntimings\r\n}\r\n}\r\n\r\n  getJobsite(accountNumber: \"$accountId\", jobNumber:\"$jobNumber\") {\r\n              jobSites{\r\n    jobNumber\r\n    jobName\r\n    jobAddr1\r\n    jobAddr2\r\n    jobCity\r\n    jobLoc\r\n    jobState\r\n    jobZip\r\n    jobPhone\r\n    contactName\r\n    }\r\n \r\n          }\r\n  \r\n}","variables":{}},
              ##"body": {"query":"{\r\n\r\n\r\n  products(filter: {sku: {in: [\"400-1085\"]}}) {\r\n    items {\r\n      equipment_images\r\n    }\r\n  }\r\n\r\n\r\ngetBranchDetails(branchCode:[112]) {\r\nbranchDetails{\r\nbranchname\r\nbranchcode\r\nbranchnumber\r\nbranchtype\r\naddresslatitude\r\naddresslongitude\r\naddress\r\nphone\r\ncity\r\nstate\r\ncountry\r\nzip\r\ntimings\r\n}\r\n}\r\n\r\n  getJobsite(accountNumber: \"459830\", jobNumber:\"CORPORATE+OFFICE\") {\r\n              jobSites{\r\n    jobNumber\r\n    jobName\r\n    jobAddr1\r\n    jobAddr2\r\n    jobCity\r\n    jobLoc\r\n    jobState\r\n    jobZip\r\n    jobPhone\r\n    contactName\r\n    }\r\n \r\n          }\r\n  \r\n}","variables":{}},
              "headers":{
                    "Content-Type": "application/json",
                    ##"Authorization": "Bearer $ctx.args.token",
                    "x-activationid":"$!{ctx.stash.x-activationid}",
                    "guid":"$!{ctx.stash.guid}",
                    "access-token":"$!{ctx.stash.access-token}"
                }
            }
        }   
      ResponseMappingTemplate: |                       
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end

        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            #set($jobSites = $ctx.stash.jobSites )
            #set($OtgDTO = {})
            
            #set ( $d = '"')
            #set ( $o = '{')
            #set ( $e = '}')
            
          
        
                {
                  ${d}contractNumber${d}:${d}$!{ctx.prev.result.contractNumber}${d},
                  ${d}status${d}:${d}$!{ctx.prev.result.status}${d},
                  ${d}pickupType${d}:${d}$!{ctx.prev.result.pickupType}${d},
                    ${d}scheduledDateTime${d}:${d}$!{ctx.prev.result.scheduledDateTime}${d},
                    ${d}deliveryDateTime${d}:${d}$!{ctx.prev.result.deliveryDateTime}${d},
                    ${d}branchCode${d}:${d}$!{ctx.prev.result.branchCode}${d},
                    ${d}deliveryOrPickupNote${d}:${d}$!{ctx.prev.result.deliveryOrPickupNote}${d},
                    
                    ${d}driverInfo${d} : $util.toJson($!{ctx.prev.result.driverInfo}),
                    ${d}pickupDetails${d} : $util.toJson($!{ctx.prev.result.pickupDetails}),
                    
                #foreach( $branchItem in $util.parseJson($ctx.result.body).data.getBranchDetails.branchDetails )
                        ${d}servingBranch${d}: $util.toJson($branchItem),
                    #end
                    
                    ${d}jobsite${d} : $util.toJson($util.parseJson($ctx.result.body).data.getJobsite.jobSites),

                    ${d}equipmentInfo${d} : $o
                      ${d}equipmentIC${d}:${d}$!{ctx.prev.result.equipmentIC}${d},
                      ${d}catClass${d}:${d}$!{ctx.prev.result.catClass}${d},
                ${d}equipmentName${d}:${d}$!{ctx.prev.result.equipmentName}${d},
                        ${d}make${d}:${d}$!{ctx.prev.result.equipmentDetails.make}${d},
                        ${d}model${d}:${d}$!{ctx.prev.result.equipmentDetails.model}${d},
                        ${d}deliveryImages${d} : $util.toJson($!{ctx.prev.result.equipmentInfo.images}),
                        
                        ${d}quantity${d} : ${d}$!{ctx.prev.result.equipmentInfo.quantity}${d},
                        ${d}condition${d} : ${d}$!{ctx.prev.result.equipmentInfo.condition}${d},
                        ${d}equipmentId${d} :${d}$!{ctx.prev.result.equipmentInfo.equipmentId}${d},
                        ${d}equipmentNumber${d} : ${d}$!{ctx.prev.result.equipmentInfo.equipmentNumber}${d},


                        ${d}serialNumber${d}:${d}$!{ctx.prev.result.equipmentDetails.serialNumber}${d},
                        #foreach( $imageItem in $util.parseJson($ctx.result.body).data.products.items )
                            ${d}equipmentImage${d}:$util.toJson($imageItem.equipment_images),
                      #end
                    ${d}equipmentCustomName${d}:${d}$!{ctx.prev.result.equipmentCustomName}${d}
                        $e
                }

        #elseif( $ctx.result.statusCode==400 || $ctx.result.statusCode==404)
        $util.error("Data Not found for given contract Number and equipmentIC. Please check the contract Number and equipmentIC")
        #else
            ## If response is not 200, append the response to error block.
            $util.error($ctx.result.body , "$ctx.result.statusCode")
        #end

  SaveCustomerToDeviceToken:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt UserDeviceTokenRegistrationDS.Name
      Description: SaveCustomerToDeviceToken Function
      FunctionVersion: 2018-05-29
      Name: SaveCustomerToDeviceToken
      RequestMappingTemplate: |
        #if( $ctx.args.userEmailId.trim()=="" )
          $util.error("userEmailId can't be an empty string.")
        #end
        #if( $ctx.args.deviceToken.trim()=="" )
          $util.error("deviceToken can't be an empty string.")
        #end
        #if( $ctx.args.platform.trim()=="" )
          $util.error("platform can't be an empty string.")
        #end
        #if( $ctx.args.platform.trim()!="ios" && $ctx.args.platform.trim()!="android" )
          $util.error("Please choose either ios or android")
        #end
        #if( $ctx.args.operationType.trim()=="" )
          $util.error("operationType can't be an empty string.")
        #end

        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))

        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)                    
  
  DeleteCutomerDeviceToken:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt UserDeviceTokenRegistrationDS.Name
      Description: DeleteCutomerDeviceToken Function
      FunctionVersion: 2018-05-29
      Name: DeleteCutomerDeviceToken
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#

        #if( $ctx.args.deviceToken.trim()=="" )
          $util.error("deviceToken can't be an empty string.")
        #end
        #if( $ctx.args.operationType.trim()=="" )
          $util.error("operationType can't be an empty string.")
        #end

        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))

        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  RetrieveUserDeviceTokens:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt RetrieveUserDeviceTokensDS.Name
      Description: RetrieveUserDeviceTokens Function
      FunctionVersion: 2018-05-29
      Name: DeleteCutomerDeviceToken
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#

        #if( $ctx.args.userEmailIds.size() == 0 )
          $util.error("userEmailids cannot be empty")
        #end  
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))
        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  ApplicationMACToggle:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name
      Description: ApplicationMACToggle Function
      FunctionVersion: 2018-05-29
      Name: ApplicationMACToggle
      RequestMappingTemplate: |
        #set( $headers = {} )

        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))

        #set( $lambdaRq = {} )

        $util.qr($lambdaRq.put("endpoint","https://stgtelemacequipmentapi.hercrentals.com/equipment/mac"))
        $util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","PUT"))

        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## if the response status code is not 200, then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            ## If response is 200, return the body.
            $ctx.result.body
        #else
            ## If response is not 200, append the response to error block.
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end 

  SaveAlertPreference:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt SaveOrUpdatePreferenceDS.Name
      Description: SaveAlertPreference Function
      FunctionVersion: 2018-05-29
      Name: SaveAlertPreference
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        #if( !$ctx.args.input.accountNumber || $ctx.args.input.accountNumber.trim()=="")
          $util.error("accountNumber can't be null or empty string.")
        #end
        #if( !$ctx.args.input.alertCategory || $ctx.args.input.alertCategory.trim()=="")
          $util.error("alertCategory can't be null or empty string.")
        #end
        #if( !$ctx.args.input.divisionCode || $ctx.args.input.divisionCode.trim()=="")
          $util.error("divisionCode can't be null or empty string.")
        #end
        #set( $ctx.args.input.operationType = "SAVE" )

        $util.qr($context.args.input.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.input.put("guid",$ctx.stash.guid))
        $util.qr($context.args.input.put("access-token",$ctx.stash.access-token))

        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args.input)
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  UpdateAlertPrefernce:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt SaveOrUpdatePreferenceDS.Name
      Description: UpdateAlertPrefernce Function
      FunctionVersion: 2018-05-29
      Name: UpdateAlertPrefernce
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        #if( !$ctx.args.input.accountNumber || $ctx.args.input.accountNumber.trim()=="")
          $util.error("accountNumber can't be null or empty string.")
        #end
        #if( !$ctx.args.input.alertCategory || $ctx.args.input.alertCategory.trim()=="")
          $util.error("alertCategory can't be null or empty string.")
        #end
        #if( !$ctx.args.input.id || $ctx.args.input.id.trim()=="")
          $util.error("id can't be null or empty string.")
        #end
        #if( !$ctx.args.input.divisionCode || $ctx.args.input.divisionCode.trim()=="")
          $util.error("divisionCode can't be null or empty string.")
        #end
        #set( $ctx.args.input.operationType = "UPDATE" )

        $util.qr($context.args.input.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.input.put("guid",$ctx.stash.guid))
        $util.qr($context.args.input.put("access-token",$ctx.stash.access-token))

        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args.input)
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  SaveCustomEquipmentName:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt SaveOrUpdatePreferenceDS.Name
      Description: SaveCustomEquipmentName Function
      FunctionVersion: 2018-05-29
      Name: SaveCustomEquipmentName
      RequestMappingTemplate: |
        #foreach( $item in $context.args.equipmentCustomNameRequestList)
        #if($item.divisionCode && $util.str.toUpper($item.divisionCode) == "CAN")
        #set($item.divisionCode = "CR")
        #elseif($item.divisionCode && $util.str.toUpper($item.divisionCode) == "US")
        #set( $item.divisionCode = "HG" )
        #end
        #end




        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))



        {
        "version" : "2018-05-29",
        "operation": "Invoke",
        "payload": $util.toJson($context.args)
        }
      ResponseMappingTemplate: |
        #foreach( $item in $context.result )
        #if($item.errorType)
        $util.appendError("$item.errorMessage", "$item.errorType")
        #end
        #end
        $utils.toJson($context.result)

  UpdateCustomEquipmentName:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt SaveOrUpdatePreferenceDS.Name
      Description: UpdateCustomEquipmentName Function
      FunctionVersion: 2018-05-29
      Name: UpdateCustomEquipmentName
      RequestMappingTemplate: |
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))



        {
        "version" : "2018-05-29",
        "operation": "Invoke",
        "payload": $util.toJson($context.args)
        }
      ResponseMappingTemplate: |
        #if($context.result.errorType)
        $util.appendError("$context.result.errorMessage", "$context.result.errorType")
        #end
        $utils.toJson($context.result) 

  SaveEquipmentName:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt SaveEquipmentNameDS.Name
      Description: SaveEquipmentName Function
      FunctionVersion: 2018-05-29
      Name: SaveEquipmentName
      RequestMappingTemplate: |
        #**
        The value of 'payload' after the template has been evaluated
        will be passed as the event to AWS Lambda.
        *#
        $util.qr($context.args.put("x-activationid",$ctx.stash.x-activationid))
        $util.qr($context.args.put("guid",$ctx.stash.guid))
        $util.qr($context.args.put("access-token",$ctx.stash.access-token))
        {
          "version" : "2018-05-29",
          "operation": "Invoke",
          "payload": $util.toJson($context.args)
        }
      ResponseMappingTemplate: |
        #if( $context.result && $context.result.errorMessage )
          $util.appendError($context.result.errorMessage, $context.result.errorType)
        #else
          $util.toJson($context.result)
        #end
  
  #-----------------------------------------------------------------------------
  # This is the http resolver
  #-----------------------------------------------------------------------------
  
  UpdateTermsConditionsAcceptance:
    Type: "AWS::AppSync::Resolver"
    DependsOn: GraphQLSchema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: UpdateTermsConditionsAcceptance
      DataSourceName: !GetAtt DummyDataSource.Name
      RequestMappingTemplate: |
        ## #set( $variable = "Bearer " )
        {
            "version": "2018-05-29",
            "method": "POST",
            ## E.G. if full path is https://api.xxxxxxxxx.com/posts then resourcePath would be /posts **
            "resourcePath": "/graphql",
            "params":{
                "body":{"query":"query {updateTermsConditionsAcceptance{isAcceptanceTerms}}"},
                "headers":{
                    "Content-Type": "application/json",
                    ## "Authorization": "${variable}${ctx.request.headers.Authorization}" 
                    "Authorization": "${ctx.request.headers.Authorization}"  
                }
            }
        }

      #ResponseMappingTemplate: "$util.toJson($ctx.result)"
      ResponseMappingTemplate: |
        ## Raise a GraphQL field error in case of a datasource invocation error
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $ctx.result.body
        #else
            $util.error($ctx.result.body, "$ctx.result.statusCode")
        #end
  
  #-----------------------------------------------------------------------------
  # This is the Resolver pipeline
  #-----------------------------------------------------------------------------

  ToggleLTsInAGroupPipeline:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: ToggleLTsInAGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt ToggleLTsInAGroupFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($context.result)"


  CreatePostPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: addGeofence
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt AddGeofenceWrapperLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($context.result)"

  GetAssignmentDetailsByICPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAssignmentDetailsByIc
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetAssignmentDetailsByICFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  CreateAssignmentPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: CreateAssignment
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt CreateAssignmentFunction.FunctionId
      RequestMappingTemplate: |
        ## By default in a before template, all you need is a valid JSON payload.
        ## You can also stash data to be made available to the functions in the pipeline.
        ## Examples: 
        ## - $ctx.stash.put("email", $ctx.args.email)
        ## - $ctx.stash.put("badgeNumber", $ctx.args.input.badgeNumber)
        ## - $ctx.stash.put("username", $ctx.identity.username)
        #if(!$ctx.args.input)
        $util.error("You must provide input.")
        #end
        #if( !$ctx.args.input.customerNum)
        $util.error("customerNum can't be missing.")
        #end
        #if( $ctx.args.input.customerNum.trim()=="")
        $util.error("customerNum can't be null or empty string.")
        #end
        #if($ctx.args.input.companyCode.trim()=="")
        $util.error("companyCode can not be an empty string!")
        #end
        {}
      ResponseMappingTemplate: "$util.toJson($ctx.result)"      

  GetAssignmentDetailsByIdPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAssignmentDetailsbyId
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt GetAssignmentDetailsByIdFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetAssignmentByAccountPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAssignmentsByAccount
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetAssignmentByAccountFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  CancelAssignmentPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DeleteAssignment
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt CancelAssignmentFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"  

  UpdateAssignmentPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: UpdateAssignment
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt UpdateAssignmentFunction.FunctionId
      RequestMappingTemplate: |
        ## By default in a before template, all you need is a valid JSON payload.
        ## You can also stash data to be made available to the functions in the pipeline.
        ## Examples: 
        ## - $ctx.stash.put("email", $ctx.args.email)
        ## - $ctx.stash.put("badgeNumber", $ctx.args.input.badgeNumber)
        ## - $ctx.stash.put("username", $ctx.identity.username)
        #if(!$ctx.args.input)
        $util.error("You must provide input.")
        #end
        #if($ctx.args.input.companyCode.trim()=="")
        $util.error("companyCode can not be an empty string!")
        #end
        {}      
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetOperatorAssignmentDetailByEmailPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getOperatorAssignmentDetailByEmail
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetOperatorAssignmentDetailByEmailFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetOperatorGroupDetailByEmailPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getOperatorGroupDetailByEmail
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetOperatorGroupDetailByEmailFunction.FunctionId
      RequestMappingTemplate: |
        ## By default in a before template, all you need is a valid JSON payload.
        ## You can also stash data to be made available to the functions in the pipeline.
        ## Examples: 
        ## - $ctx.stash.put("email", $ctx.args.email)
        ## - $ctx.stash.put("badgeNumber", $ctx.args.input.badgeNumber)
        ## - $ctx.stash.put("username", $ctx.identity.username)

        #if( $ctx.args.countryCode.trim()=="" )
          $util.error("countryCode can't be an empty string.")
        #end
        #if( $ctx.args.customerNumber.trim()=="" )
          $util.error("customerNumber can't be an empty string.")
        #end
        #if( $ctx.args.operatorEmail.trim()=="" )
          $util.error("operatorEmail can't be an empty string.")
        #end
        {}      
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetOperatorTabDetailsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getOperatorTabDetails
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetOperatorTabDetailsFunction.FunctionId
      RequestMappingTemplate: |
        ## By default in a before template, all you need is a valid JSON payload.
        ## You can also stash data to be made available to the functions in the pipeline.
        ## Examples: 
        ## - $ctx.stash.put("email", $ctx.args.email)
        ## - $ctx.stash.put("badgeNumber", $ctx.args.input.badgeNumber)
        ## - $ctx.stash.put("username", $ctx.identity.username)

        #if( $ctx.args.customerNumber.trim()=="" )
          $util.error("customerNumber can't be an empty string.")
        #end
        #if( $ctx.args.countryCode.trim()=="" )
          $util.error("countryCode can't be an empty string.")
        #end

        {}
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  #Anirudh - 26/04/2022 LightTower

  ValidatePhoneNumberPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: ValidatePhoneNumber
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            # - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt ValidatePhoneNumberFunction.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetMobileAuthorizationStatusPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetMobileAuthorizationStatus
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetMobileAuthorizationStatusFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"   

  GetScheduleDetailsByProfileIdPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetScheduleDetailsbyProfileID
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetScheduleDetailsByProfileIdFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetCommandStatusPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetCommandStatus
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetCommandStatusFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"   


  GetLTMultipleScheduleResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getLTMultipleSchedule
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetLTMultipleScheduleFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetLTAndSchedulesListResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getLTAndSchedulesList
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetLTAndSchedulesListFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetAllLightTowerGroupsResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllLightTowerGroups
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetAllLightTowerGroupsFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 


  GetSingleLTScheduleByEquipmentIdResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getSingleLTScheduleByEquipmentId
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetSingleLTScheduleByEquipmentIdFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetSingleLightTowerByAccountIdResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetSingleLightTowerbyAccountId
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetSingleLightTowerByAccountIdFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  LTPowerModalOffONPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: LTPowerModalOff
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt LTPowerModalOffONFunction.FunctionId
      RequestMappingTemplate: "{}"      
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 


  CreateLightTowerGroupPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: CreateLightTowerGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt CreateLightTowerGroupFunction.FunctionId
      RequestMappingTemplate: "{}"      
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  EditLightTowerGroupPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: EditLightTowerGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          #- !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt EditLightTowerGroupFunction.FunctionId
      RequestMappingTemplate: |
        #if( !$ctx.args.input.profileId )
          $util.error("profileId can't be missing.")
        #end
        #if( $ctx.args.input.profileId.trim()=="" )
          $util.error("profileId can't be an empty string.")
        #end
        #if( !$ctx.args.input.recurrence )
          $util.error("recurrence can't be missing.")
        #end
        #if( $ctx.args.input.recurrence.trim()=="" )
          $util.error("recurrence can't be an empty string.")
        #end
        {}            
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  DeleteLightTowerGroupPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DeleteLightTowerGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt DeleteLightTowerGroupFunction.FunctionId
      RequestMappingTemplate: "{}"            
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 


  CreateLTSchedulePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: CreateLTSchedule
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt CreateLTScheduleFunction.FunctionId
      RequestMappingTemplate: "{}"            
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  EditLTSchedulePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: EditLTSchedule
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt EditLTScheduleFunction.FunctionId
      RequestMappingTemplate: "{}"            
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  DeleteLTSchedulePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DeleteLTSchedule
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt DeleteLTScheduleFunction.FunctionId
      RequestMappingTemplate: "{}"            
      ResponseMappingTemplate: "$util.toJson($ctx.result)"
      
  AddLTsToGroupPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: AddLTsToGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt AddLTsToGroupFunction.FunctionId
      RequestMappingTemplate: "{}"            
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  DeleteLightTowerFromGroupPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DeleteLightTowerFromGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt DeleteLightTowerFromGroupFunction.FunctionId
      RequestMappingTemplate: "{}"            
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  #-----------------------------------------------------------------------------
  # This is the appsync Function for GetMacEquipments ( Second Phase=2)
  #-----------------------------------------------------------------------------

  GetTagsForTemperatureMonitoringPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetTagsforTemperatureMonitoring
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetTagsForTemperatureMonitoringFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetTemperatureMonitoringDetailsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetTemperatureMonitoringDetails
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetTemperatureMonitoringDetailsFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"  


  GetGroupProfileGraphDataPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetGroupProfileGraphData
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetGroupProfileGraphDataFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetDashboardDataPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetDashboardData
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetDashboardDataFunction.FunctionId
          - !GetAtt AddEqImageFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"
      
  GetHubDetailsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetHubDetails
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetHubDetailsFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  UpdateGroupProfileStatusPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: UpdateGroupProfileStatus
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          #- !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt UpdateGroupProfileStatusFunction.FunctionId
      RequestMappingTemplate: "{}"            
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  TMCreateGroupProfilePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: TMCreateGroupProfile
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt TMCreateGroupProfileFunction.FunctionId
      RequestMappingTemplate: "{}"            
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  TMUpdateGroupProfilePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: TMUpdateGroupProfile
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt TMUpdateGroupProfileFunction.FunctionId
      RequestMappingTemplate: |
        #if( $context.args.input.divisionCode.trim() == "" )
            $util.error("Division Code cannot be empty")
        #end    
        {}                  
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  TMDeleteGroupProfilePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: TMDeleteGroupProfile
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt TMDeleteGroupProfileFunction.FunctionId
      RequestMappingTemplate: "{}"                  
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  ViewAlertsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetViewAlertsByAccountID
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt ViewAlertsFunction.FunctionId
      RequestMappingTemplate: |
        #if( $ctx.args.divisionCode.trim()=="" )
          $util.error("divisionCode can't be an empty string.")
        #end
        #if( $ctx.args.customerNumber.trim()=="" )
          $util.error("customerNumber can't be an empty string.")
        #end
        {}      
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  DispatchAlertPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DispatchAlert
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt DispatchAlertFunction.FunctionId
      RequestMappingTemplate: "{}"                  
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  ExportAlertsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: ExportAlerts
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt ExportAlertsMutationFunction.FunctionId
      RequestMappingTemplate: |
        #if( !$ctx.args.input.divisionCode || $ctx.args.input.divisionCode.trim()=="" )
        $util.error("divisionCode cannot be empty or null")
        #end
        {}
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  DispatchSMSPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DispatchSMS
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt DispatchSMSFunction.FunctionId
      RequestMappingTemplate: "{}"                  
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  DispatchEmailPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DispatchEmail
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt DispatchEmailFunction.FunctionId
      RequestMappingTemplate: "{}"                  
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetAllDeliveryPickupsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllDeliveryPickups
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt GetAllDeliveryPickupsLambdaFunction.FunctionId

      RequestMappingTemplate: |
        #if( $ctx.args.divisionCode.trim()=="" )
          $util.error("divisionCode can't be an empty string.")
        #end
        #if( $ctx.args.customerNumber.trim()=="" )
          $util.error("customerNumber can't be an empty string.")
        #end
        {}      
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetRouteUpdatesPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getRouteUpdates
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt DeliveryPickupLocationTrackerFunction.FunctionId
      RequestMappingTemplate: "{}"      
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetAlertPreferenceByIdPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetAlertPreferenceById
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetAlertPreferenceByIdFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetAlertPreferenceByAccountIdAndAlertCategoryPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetAlertPreferenceByAccountNumberandAlertCategory
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetAlertPreferenceByAccountIdAndAlertCategoryFunction.FunctionId
      RequestMappingTemplate: |
        #if( !$ctx.args.accountNumber)
        $util.error("accountNumber can't be missing.")
        #end
        #if( !$ctx.args.divisionCode)
        $util.error("divisionCode can't be missing.")
        #end
        #if( $ctx.args.accountNumber.trim()=="")
        $util.error("accountNumber can't be null or empty string.")
        #end
        #if( $ctx.args.divisionCode.trim()=="")
        $util.error("divisionCode can't be null or empty string.")
        #end
        {}      
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetMacEligibleEquipmentsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getMacEligibleEquipments
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetMacEligibleEquipmentsFunction.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetAccountAutoAddEqStatusPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetAccountAutoAddEqStatus
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetAccountAutoAddEqStatusFunction.FunctionId
      RequestMappingTemplate: |
        #if( $ctx.args.accountNumber.trim()=="")
          $util.error("accountNumber can't be an empty string.")
        #end
        #if( $ctx.args.countryCode.trim()=="" )
          $util.error("countryCode can't be an empty string.")
        #end
        {}      
      ResponseMappingTemplate: "$ctx.result"


  MacToggleAccountAutoAddEqStatusPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: MacToggleAccountAutoAddEqStatus
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt MacToggleAccountAutoAddEqStatusFunction.FunctionId
      RequestMappingTemplate: |
        #if( $ctx.args.accountNumber.trim()=="")
          $util.error("accountNumber can't be an empty string.")
        #end
        #if( $ctx.args.countryCode.trim()=="" )
          $util.error("countryCode can't be an empty string.")
        #end
        #if( $ctx.args.autoAddStatus.trim()=="" )
          $util.error("autoAddStatus can't be an empty string.")
        #end
        {}      
      ResponseMappingTemplate: "$ctx.result"


  GetMacEquipmentsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetMacEquipments
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetMacEquipmentsFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  MacOperatorRequestAccessToEquipmentPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: MACOperatorRequestAccesstoEquipment
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt MacOperatorRequestAccessToEquipmentFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetAlertsByGeofencePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: FindAlertsByGeofence
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetAlertsByGeofenceWrapperLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  AddBulkGeofencePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: addBulkGeofence
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt AddBulkGeofenceWrapperLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 


  UpdateGeofencePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: updateGeofence
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt UpdateGeofenceWrapperLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  AddEquipmentToGeofencePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: addEquipmentToGeofence
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt AddEquipmentToGeofenceWrapperLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  DeleteGeofencePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: deleteGeofence
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt DeleteGeofenceWrapperLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetGeofenceByAccountPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getGeofenceByAccount
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetGeofenceByAccountLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetGeofenceByIdPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getGeofenceById
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          # - !GetAtt GetCountlambdaFunction.FunctionId          
          - !GetAtt GetGeofenceByIdWrapperLambdafunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetGeofenceSummeryPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getGeofenceSummery
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          # - !GetAtt GetCountlambdaFunction.FunctionId          
          - !GetAtt GetGeofenceSummeryWrapperLambda.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetEquipmentsInGeofencePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getEquipmentsInGeofence
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          # - !GetAtt GetCountlambdaFunction.FunctionId          
          - !GetAtt GetEquipmentsInGeofenceWrapperLambdaFunction.FunctionId
          - !GetAtt fetchImagesForGeofenceEquips.FunctionId

      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"
  
  #-----------------------------------------------------------------------------
  # This is the appsync Resolvers Phase-3
  #-----------------------------------------------------------------------------
  
  DeleteGroupPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: deleteGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt DeleteGroup.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  
  SaveOrUpdateGroupPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: saveOrUpdateGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt SaveOrUpdateGroup.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  getGroupByIdPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getGroupById
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt GetGroupById.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  getGroupByAccountPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getGroupByAccount
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetGroupByAccount.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  createGroupPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: createGroup
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt createGroup.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  getEnabledEquipmentByOperatorPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getEnabledEquipmentByOperator
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt getEnabledEquipmentByOperator.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  FetchMacTogglePipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: FetchMacToggle
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt FetchMacToggle.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$ctx.result"

  GetFetchEquipmentsPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getFetchEquipments
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt GetFetchEquipments.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($context.result)"

  GetFetchEquipmentsFMACPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getFetchEquipments_FMAC
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt GetFetchEquipments.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($context.result)"

  GetFetchEquipmentsAMPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getFetchEquipments_AM
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt GetFetchEquipments.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($context.result)"

  GetequipmentStatusbyCategoryPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getequipmentStatusbyCategory
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt getequipmentStatusbyCategory.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEquipmentListByJobsiteNumberPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetEquipmentListbyJobsiteNumber
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt GetEquipmentListbyJobsiteNumber.FunctionId
            - !GetAtt fetchContractTypeRntlTypeJobsiteNO.FunctionId
            - !GetAtt fetchImageForEquipmentsInJobsite.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetFleetAggregatedViewPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getFleetAggregatedView
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt getFleetAggregatedView.FunctionId
            - !GetAtt getequipmentImageforfleetView.FunctionId
        RequestMappingTemplate: |
          #if( $ctx.args.input.divisionCode.trim()=="" )
          $util.error("divisionCode can't be empty")
          #end {}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)


  GetFleetDiagnosticsByAccountIDPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getFleetDiagnosticsByAccountID
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt CheckRegionFunction.FunctionId  
            - !GetAtt getFleetDiagnosticsByAccountID.FunctionId         
            - !GetAtt jobsiteNameForFleetDiagnostics.FunctionId
            - !GetAtt addEquipmentImageForDiagnostics.FunctionId    
        RequestMappingTemplate: |
          #if( $ctx.args.divisionCode.trim()=="")
          $util.error("divisionCode can't be empty")
          #end
          #if( $ctx.args.customerNumber.trim()=="")
          $util.error("customerNumber can't be empty")
          #end {}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)


  GetEquipmentByBranchIDPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetEquipmentByBranchIDs
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt EquipmentsByBranchIdLambdaFunction.FunctionId            
        RequestMappingTemplate: |
          #if( !$ctx.args.branches )
            $util.error("branches missing in parameters.")
          #end
          {}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)


  GetFleetAggregatedDeliveriesPickupsByAccountIDPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetFleetAggregatedDeliveriesPickupsByAccountIDs
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt GetFleetAggregatedDeliveriesPickupsByAccountIDs.FunctionId         
            - !GetAtt ImageAndjobSiteForAggregatedDeliveries.FunctionId
            - !GetAtt getJobSiteFromMuleForAggregatedDeliveries.FunctionId  
        RequestMappingTemplate: |
          #foreach( $item in $ctx.args.customerIdsAndDivisionCodesCombinations )
          #if(!$item.divisionCode)
          $util.error("divisionCode can not be missing.")
          #end
          #end
          {}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)

  getFleetUtilizationDetailsPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetFleetUtilizationDetails
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt CheckRegionFunction.FunctionId         
            - !GetAtt getFleetUtilizationDetails.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"       


  GetFleetAggregatedUtilizationViewByAccountIDsPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetFleetAggregatedUtilizationViewByAccountIDs
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId  
            - !GetAtt GetFleetAggregatedUtilizationViewByAccountIDs.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"       

  GetJobsitedetailsbyEquipmentICsPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetJobsitedetailsbyEquipmentICs
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId  
            - !GetAtt GetJobsitedetailsbyEquipmentICs.FunctionId     
        RequestMappingTemplate: |
          #foreach( $item in $ctx.args.input )
          #if($item.division && $util.str.toUpper($item.division) == "CAN")
          #set( $item.division = "CR" )
          #elseif($item.division && $util.str.toUpper($item.division) == "US")
          #set( $item.division = "HG" )
          #else
          $util.error("Please select either CAN or US as division!")
          #end
          #end
          {}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)    

  GetEquipmentSummaryForJobsitePipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetEquipmentSummaryForJobsite
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId  
            - !GetAtt GetEquipmentSummaryForJobsite.FunctionId     
        RequestMappingTemplate: |
          #if( $ctx.args.divisionCode.trim()=="" )
          $util.error("divisionCode can't be an empty string.")
          #end
          #if( $ctx.args.accountId.trim()=="" )
            $util.error("accountId can't be an empty string.")
          #end
          #if( $ctx.args.equipmentId.trim()=="" )
            $util.error("equipmentId can't be an empty string.")
          #end{}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)

  GetDeviceLocationHistoryPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getDeviceLocationHistory
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt CheckRegionFunction.FunctionId 
            - !GetAtt GetDeviceLocationHistory.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEquipmentUtilizationTimelinePipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetEquipmentUtilizationTimeline
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt GetEquipmentUtilizationTimeline.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"                              

  GetEquipmentStatusAndInfoPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentStatusAndInfo
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt GetBranchCode.FunctionId
            - !GetAtt getDeliveryAndPickupFromM2.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)" 

  GetEquipmentStatusAndInfoFVPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentStatusAndInfo_FV
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt GetBranchCode.FunctionId
            - !GetAtt getDeliveryAndPickupFromM2.FunctionId
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEquipmentStatusAndInfoFLPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentStatusAndInfo_FL
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt GetBranchCode.FunctionId
            - !GetAtt getDeliveryAndPickupFromM2.FunctionId  
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"      


  GetEquipmentDiagnosticsAndSafetyPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentDiagnosticsAndSafety
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt getEquipmentDiagnosticsAndSafety.FunctionId     
        RequestMappingTemplate: |
          #if( $ctx.args.customerNumber.trim()=="")
          $util.error("customerNumber can not be empty.")
          #end
          #if( $ctx.args.divisionCode.trim()=="")
            $util.error("divisionCode can not be empty.")
          #end
          #if( $ctx.args.ic.trim()=="")
            $util.error("ic can not be empty.")
          #end
          {}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)

  GetEquipmentsInAccountPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentsInAccount
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt EquipmentlistInAccount.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"      


  GetAlertsByAccountIdPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getAlertsByAccountId
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt fetchAlertsByCustomerNumberAndIC.FunctionId    
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"


  GetEquipmentUtilizationDetailsPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentUtilizationDetails
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt getEquipmentUtilizationDetails.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"    

  GetDiagnosticTroubleCodePipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getDiagnosticTroubleCode
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt getDiagnosticTroubleCode.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"  

  GetFleetUtilizationPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetFleetUtilization
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt GetFleetUtilization.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)" 


  GetJobSiteDetailsbyAccountIDPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getJobSiteDetailsbyAccountID
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt CheckRegionFunction.FunctionId
            - !GetAtt GetJobSiteDetailsbyAccountID.FunctionId     
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetBranchEquipmentDetailsPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetBranchEquipmentDetails
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt GetBranchEquipmentDetails.FunctionId
            - !GetAtt getBranchDetailsFromM2Function.FunctionId
        RequestMappingTemplate: |
          #if( $ctx.args.ic.trim()=="" )
          $util.error("ic can't be an empty string.")
          #end
          #if( $ctx.args.division.trim()=="" )
            $util.error("division can't be an empty string.")
          #end{}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result) 

  GetEquipmentSummaryFromRentalManPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentSummaryFromRentalMan
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt getEquipmentSummaryFromRentalMan.FunctionId
            - !GetAtt getJobSiteForRentalMan.FunctionId
            - !GetAtt fetchContractRentalForRentalman.FunctionId
        RequestMappingTemplate: |
          #if( $ctx.args.ic.trim()=="" )
          $util.error("ic can't be an empty string.")
          #end
          #if( $ctx.args.division.trim()=="" )
            $util.error("division can't be an empty string.")
          #end{}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)                 

  GetEquipmentSummaryFromRentalManFVPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentSummaryFromRentalMan_FV
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt getEquipmentSummaryFromRentalMan.FunctionId
            - !GetAtt getJobSiteForRentalMan.FunctionId
            - !GetAtt fetchContractRentalForRentalman.FunctionId    
        RequestMappingTemplate: |
          #if( $ctx.args.ic.trim()=="" )
          $util.error("ic can't be an empty string.")
          #end
          #if( $ctx.args.division.trim()=="" )
            $util.error("division can't be an empty string.")
          #end{}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)

  GetEquipmentSummaryFromRentalManFLPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: getEquipmentSummaryFromRentalMan_FL
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId 
            - !GetAtt getEquipmentSummaryFromRentalMan.FunctionId
            - !GetAtt getJobSiteForRentalMan.FunctionId
            - !GetAtt fetchContractRentalForRentalman.FunctionId    
        RequestMappingTemplate: |
          #if( $ctx.args.ic.trim()=="" )
          $util.error("ic can't be an empty string.")
          #end
          #if( $ctx.args.division.trim()=="" )
            $util.error("division can't be an empty string.")
          #end{}
        ResponseMappingTemplate: |
          $util.toJson($ctx.result)

    
  MacReportingFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name 
      Description: MacReportingFunction
      FunctionVersion: 2018-05-29
      Name: MacReportingFunction
      RequestMappingTemplate: |
        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        $util.qr($headers.put("customerid","$!{ctx.request.headers.customerid}"))
        $util.qr($headers.put("refreshtoken","$ctx.request.headers.refreshtoken"))
        $util.qr($headers.put("Authorization","$ctx.request.headers.Authorization"))
        #set($reportType = $ctx.args.reportType.trim())
        #set($accountNumber = $ctx.args.accountNumber.trim())



        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgtelemacreporttabapi.hercrentals.com/report/$reportType/$accountNumber/$ctx.args.countryCode"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args)))
        ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))



        {
        "version": "2018-05-29",
        "operation": "Invoke",
        "payload": $util.toJson($lambdaRq)
        }
        
      ResponseMappingTemplate: |                       
        #if($ctx.error)
        $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
        $ctx.result.body
        #else
        $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end 

  GetEmergencyKey:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name 
      Description: GetEmergencyKey
      FunctionVersion: 2018-05-29
      Name: GetEmergencyKey
      RequestMappingTemplate: |
        #set( $headers = {} )
        $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
        $util.qr($headers.put("guid","$ctx.stash.guid"))
        $util.qr($headers.put("access-token","$ctx.stash.access-token"))
        #set( $lambdaRq = {} )
        $util.qr($lambdaRq.put("endpoint","https://stgtelemacequipmentapi.hercrentals.com/pincode"))
        ##$util.qr($lambdaRq.put("requestBody",$util.toJson($ctx.args.input)))
        $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
        $util.qr($lambdaRq.put("headers",$!{headers}))
        $util.qr($lambdaRq.put("requestMethod","GET"))


        {
          "operation": "Invoke",
          "payload": $util.toJson($lambdaRq)
        }

        
      ResponseMappingTemplate: |                       
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        ## If the response is not 200 then return an error. Else return the body **
        #if($ctx.result.statusCode == 200)
            $util.toJson($ctx.result.body)
        #else
            $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
        #end  

  GetBranchUtilizationDetails:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name 
      Description: GetBranchUtilizationDetails
      FunctionVersion: 2018-05-29
      Name: GetBranchUtilizationDetails
      RequestMappingTemplate: |
            #set( $headers = {} )
            $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
            $util.qr($headers.put("guid","$ctx.stash.guid"))
            $util.qr($headers.put("access-token","$ctx.stash.access-token"))

            #set( $lambdaRq = {} )

            $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/branch-equipment-summary/utilizationdetails"))
            $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
            ##$util.qr($lambdaRq.put("query",$util.toJson($query)))
            $util.qr($lambdaRq.put("headers",$!{headers}))
            $util.qr($lambdaRq.put("requestMethod","GET"))
            {
              "operation": "Invoke",
              "payload": $util.toJson($lambdaRq)
            }
            
      ResponseMappingTemplate: |                       
            #if($ctx.error)
              $util.error($ctx.error.message, $ctx.error.type)
            #end
            ## If the response is not 200 then return an error. Else return the body **
            #if($ctx.result.statusCode == 200)
                $ctx.result.body
            #else
                $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
            #end  

  GetBranchUtilizationTimelineGraph:
    Type: AWS::AppSync::FunctionConfiguration
    Properties: 
      ApiId: !GetAtt GraphQLApi.ApiId
      DataSourceName: !GetAtt WrapperLambda.Name 
      Description: GetBranchUtilizationTimelineGraph
      FunctionVersion: 2018-05-29
      Name: GetBranchUtilizationTimelineGraph
      RequestMappingTemplate: |
            #set( $headers = {} )

            $util.qr($headers.put("x-activationid","$!{ctx.request.headers.x-amzn-trace-id}"))
            $util.qr($headers.put("guid","$ctx.stash.guid"))
            $util.qr($headers.put("access-token","$ctx.stash.access-token"))

            #set( $lambdaRq = {} )

            $util.qr($lambdaRq.put("endpoint","https://stgteleequipmentsummaryapi.hercrentals.com/branch-equipment-summary/utilizationtimelinegraph"))
            $util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
            ##$util.qr($lambdaRq.put("query",$util.toJson($ctx.args)))
            $util.qr($lambdaRq.put("headers",$!{headers}))
            $util.qr($lambdaRq.put("requestMethod","GET"))

            {
              "operation": "Invoke",
              "payload": $util.toJson($lambdaRq)
            }
                        
      ResponseMappingTemplate: |                       
            #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
            #end
            #if($ctx.result.statusCode == 400 || $ctx.result.statusCode == 404 || $ctx.result.statusCode == 500)
              $util.error($util.parseJson($ctx.result.body).errorMessage)
            #end
            ## If the response is not 200 then return an error. Else return the body **
            #if($ctx.result.statusCode == 200)
                $ctx.result.body
            #else
                $utils.appendError($ctx.result.body, "$ctx.result.statusCode")
            #end              
          
  
  #---------------------------------pipeline-----------------------------
  # This is for resolvers Phase-4 28th apr 2022
  #---------------------------------pipeline-----------------------------

  GetEquipmentsInAccountFVPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getEquipmentsInAccount_FV
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt EquipmentlistInAccount.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEquipmentsInAccountFLPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getEquipmentsInAccount_FL
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt EquipmentlistInAccount.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEquipmentsInAccountFGFPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getEquipmentsInAccount_FGF
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt EquipmentlistInAccount.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEquipmentsInAccountFLTPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getEquipmentsInAccount_FLT
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt EquipmentlistInAccount.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEquipmentsInAccountFTMPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getEquipmentsInAccount_FTM
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt EquipmentlistInAccount.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEquipmentsInAccountAMPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getEquipmentsInAccount_AM
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt EquipmentlistInAccount.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"                  

  GetMacEquipmentsFMACPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetMacEquipments_FMAC
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetMacEquipmentsFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetMacEquipmentsFVPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetMacEquipments_FV
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetMacEquipmentsFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetGeofenceByAccountFGFPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getGeofenceByAccount_FGF
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          #- !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetGeofenceByAccountLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetGeofenceByAccountFLTPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getGeofenceByAccount_FLT
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          #- !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetGeofenceByAccountLambdaFunction.FunctionId
      RequestMappingTemplate: "{}"     
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  DispatchAlertBEPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DispatchAlert_BE
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          # - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt DispatchAlertFunction.FunctionId
      RequestMappingTemplate: "{}"                  
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetAlertPreferenceByAccountIdAndAlertCategoryBEPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetAlertPreferenceByAccountNumberandAlertCategory_BE
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt GetAlertPreferenceByAccountIdAndAlertCategoryFunction.FunctionId
      RequestMappingTemplate: |
        #if( !$ctx.args.accountNumber)
        $util.error("accountNumber can't be missing.")
        #end
        #if( !$ctx.args.divisionCode)
        $util.error("divisionCode can't be missing.")
        #end
        #if( $ctx.args.accountNumber.trim()=="")
        $util.error("accountNumber can't be null or empty string.")
        #end
        #if( $ctx.args.divisionCode.trim()=="")
        $util.error("divisionCode can't be null or empty string.")
        #end
        {}             
      ResponseMappingTemplate: "$util.toJson($ctx.result)"    
  
  GetFleetAggregatedAlertsByAccountIdPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetFleetAggregatedAlertsByAccountId
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt getFleetAggregatedAlertsByAccountId.FunctionId
      RequestMappingTemplate: |
        #foreach( $item in $ctx.args.input )
        #if($item.divisionCode && $util.str.toUpper($item.divisionCode) == "US")
        #set( $item.divisionCode = "HG" )
        #elseif($item.divisionCode && $util.str.toUpper($item.divisionCode) == "CAN")
        #set( $item.divisionCode = "CR" )
        #else
        $util.error("Please select either CAN or US as divisionCode.")
        #end
        #end
        {}
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetDeliveryPickUpDetailsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getDeliveryPickUpDetails
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId 
          - !GetAtt DeliveryPickUpDetailsFromTelematics.FunctionId
          - !GetAtt JobSiteServingBranchImageaftertelematicsdeliverypickup.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 

  SaveCustomerToDeviceTokenPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: SaveCustomerToDeviceToken
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId 
          - !GetAtt SaveCustomerToDeviceToken.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"  

  DeleteCutomerDeviceTokenPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: DeleteCutomerDeviceToken
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt DeleteCutomerDeviceToken.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 

  RetrieveUserDeviceTokensPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: RetrieveUserDeviceTokens
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId 
          - !GetAtt RetrieveUserDeviceTokens.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"  

  ApplicationMacTogglePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: ApplicationMacToggle
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt ApplicationMACToggle.FunctionId
      RequestMappingTemplate: |
        #if( (!$ctx.args.icNumber && $ctx.args.macIcLevel) || ($ctx.args.icNumber && !$ctx.args.macIcLevel))
        $util.error("icNumber and macIcLevel should co-exist.")
        #end
        {}
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 

  SaveAlertPreferencePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: SaveAlertPreference
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt SaveAlertPreference.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  UpdateAlertPreferencePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: UpdateAlertPrefernce
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId
          - !GetAtt UpdateAlertPrefernce.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"  

  SaveCustomEquipmentNamePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: saveCustomEquipmentName
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt SaveCustomEquipmentName.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 

  UpdateCustomEquipmentNamePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: updateCustomEquipmentName
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId 
          - !GetAtt UpdateCustomEquipmentName.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)" 

  SaveEquipmentNamePipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: saveEquipmentName
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt SaveEquipmentName.FunctionId
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  MACReportingPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: MacReporting
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId 
          - !GetAtt MacReportingFunction.FunctionId  
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetEmergencyKeyPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetEmergencyKey
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId 
          - !GetAtt GetEmergencyKey.FunctionId  
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetBranchUtilizationDetailsPipelineResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: GetBranchUtilizationDetails
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt HercAppSyncAuthorizer.FunctionId
          - !GetAtt CheckRegionFunction.FunctionId  
          - !GetAtt GetBranchUtilizationDetails.FunctionId  
      RequestMappingTemplate: "{}"
      ResponseMappingTemplate: "$util.toJson($ctx.result)"

  GetBranchUtilizationTimelineGraphPipelineResolver:
      Type: "AWS::AppSync::Resolver"
      Properties:
        ApiId: !GetAtt GraphQLApi.ApiId
        TypeName: Query
        FieldName: GetBranchUtilizationTimelineGraph
        Kind: PIPELINE
        PipelineConfig:
          Functions:
            - !GetAtt HercAppSyncAuthorizer.FunctionId
            - !GetAtt CheckRegionFunction.FunctionId 
            - !GetAtt GetBranchUtilizationTimelineGraph.FunctionId  
        RequestMappingTemplate: "{}"
        ResponseMappingTemplate: "$util.toJson($ctx.result)" 
  
  #-----------------------------------------------------------------------------
  # This is the appsync.consolidated.api Schema
  #-----------------------------------------------------------------------------
  
  GraphQLSchema:
    Type: "AWS::AppSync::GraphQLSchema"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Definition: |-
        input ActionDetailsInput {
          action: String
          actionedBy: String
          actionDateTime: String
        }

        type ActiveSchedule {
          scheduleList: [ScheduleListSingleLT]
        }

        input AddLTsToGroupInput {
          accountID: String!
          divisionCode: String!
          profileId: Int!
          equipmentICList: [String]!
        }

        type Alert {
          totalElements: Int
          totalPages: Int
          last: Boolean
          size: Int
          number: Int
          numberOfElements: Int
          first: Boolean
          empty: Boolean
          sort: Sort
          pageable: Pageable
          content: [Content]
        }

        input AlertDispatcherInput {
          source: String
          division: String
          drivingLicenseNumber: String
          drivingLicenseState: String
          customerNumber: String
          deliveryConfirmationRequired: String
          toBeSentBefore: String
          recipientsDetails: [RecipientsDetailsInput]
          alertOrNotificationDetails: AlertOrNotificationDetailsInput
          actionDetails: ActionDetailsInput
        }

        type AlertDispatcherResponse {
          message: String
          statusCode: Int
        }

        type AlertEquipmentConfig {
          key: String
          value: String
        }

        input AlertEquipmentConfigInput {
          key: String
          value: String
        }

        type AlertInfoMap {
          DESCRIPTION: String
          GEOFENCE_NAME: String
          GEOFENCE_ID: String
          EVENT_TYPE: String
          EQUIPMENT_CUSTOM_TAG: String
          LINK: String
          FUEL_LEVEL: Float
          VOLTAGE_LEVEL: Float
          DEF_LEVEL: Float
          LIGHT_TOWER_STATUS: String
          TEMPERATURE: Float
          HUB_NUMBER: String
          GROUP_NAME: String
          LAST_KNOWN_DATE_TIME: String
          DTC_CODE: String
          DTC_DESCRIPTION: String
          IGNITION_STATUS: String
          DATE_TIME: String
          THRESHOLD: Float
          DAYS: Float
          RESERVATION_NUMBER: String
          RESERVATION_URL: String
          RENTAL_AGREEMENT_NUMBER: String
          ESTIMATED_END_DATE: String
          RENTAL_AGREEMENT_LINK: String
          RELEASE_NUMBER: String
          RELEASE_LINK: String
          TRACKING_LINK: String
          DELIVERY_LINK: String
          OPERATOR_NAME: String
          EQUIPMENT_IC: String
          PO_NUMBER: String
          ACCOUNT_NUMBER: String
          REMAINING_AMOUNT: String
          PO_LINK: String
          REMAINING_DAYS: String
        }

        input AlertInfoMapInput {
          key: String
          value: String
        }

        type AlertList {
          totalElements: Int
          totalPages: Int
          last: Boolean
          size: Int
          number: Int
          numberOfElements: Int
          first: Boolean
          empty: Boolean
          sort: Sort
          pageable: Pageable
          content: [Contentt]
        }

        input AlertOrNotificationDetailsInput {
          category: String
          subCategory: String
          type: String
          severity: String
          attachments: [String]
          equipmentDetails: [EquipmentDetailsInput]
          alertInfoMap: [AlertInfoMapInput]
        }

        type AlertPreference {
          divisionCode: String
          id: String
          isActive: Boolean
          accountNumber: String
          alertCategory: String
          applyToAllEquipment: Boolean
          alertTriggerType: String
          manualRecipientPhoneList: [ManualRecipientPhoneList]
          manualRecipientEmailList: [ManualRecipientEmailList]
          existingAppRecipients: [ExistingAppRecipients]
          alertTriggerTiming: [String]
          deliveryMode: [String]
          equipmentList: [EquipmentList]
          allEquipmentConfig: [AllEquipmentConfig]
          subCategories: [String]
        }

        type AlertPreferenceById {
          statusCode: Int
          message: String
          alertPreference: AlertPreference
        }

        input AlertPreferenceGeofenceInput {
          isActive: Boolean
          id: String
          moduleId: String
          active: Boolean
          alertCategory: String
          alertTriggerType: String
          deliveryMode: [String]
          manualRecipientPhoneList: [ManualRecipientPhoneListInput]
          manualRecipientEmailList: [ManualRecipientEmailListInput]
          existingAppRecipients: [ExistingAppRecipientsInput]
          allEquipmentConfig: [AllEquipmentConfigInput]
          alertTriggerTiming: [String]
        }

        type AlertPreferenceGeofenceResponse {
          isActive: Boolean
          active: Boolean
          id: String
          moduleId: String
          alertCategory: String
          alertTriggerType: String
          deliveryMode: [String]
          manualRecipientPhoneList: [ManualRecipientPhoneList]
          manualRecipientEmailList: [ManualRecipientEmailList]
          existingAppRecipients: [ExistingAppRecipients]
          allEquipmentConfig: [AllEquipmentConfig]
          alertTriggerTiming: [String]
        }

        input AlertPreferenceInput {
          operationType: String
          divisionCode: String
          isActive: Boolean
          accountNumber: String
          alertCategory: String
          applyToAllEquipment: Boolean
          alertTriggerType: String
          manualRecipientPhoneList: [ManualRecipientPhoneListInput]
          manualRecipientEmailList: [ManualRecipientEmailListInput]
          existingAppRecipients: [ExistingAppRecipientsInput]
          alertTriggerTiming: [String]
          deliveryMode: [String]
          equipmentList: [EquipmentListInput]
          allEquipmentConfig: [AllEquipmentConfigInput]
        }

        type AlertPreferenceResponse {
          divisionCode: String
          id: String
          statusCode: String
          message: String
        }

        type AlertRedirectionResponse {
          alertGroup: String
          category: String
          title: String
          description: String
          equipmentIC: String
          isTriggeredOnWeekend: Boolean
          triggeredTime: String
          accountId: String
          divisionCode: String
          companyId: String
          accountType: String
        }

        type AlertResponse {
          alerts: [Alerts]
        }

        type Alerts {
          id: Int
          customerNumber: String
          timeStamp: String
          equipmentIdentifier: String
          alerType: String
          alertMessage: String
        }

        type AlertsInGeofence {
          alertId: String
          alertType: String
          alertTriggerTime: String
          equipmentNumber: String
          coordinates: [Float]
        }

        type AllEquipmentConfig {
          key: String
          value: String
        }

        input AllEquipmentConfigInput {
          key: String
          value: String
        }

        type ApplicationMacToggleResponse {
          statusCode: String
          message: String
        }

        type Assignments {
          assignmentId: String
          assignmentName: String
          assignmentStartDate: String
          assignmentEndDate: String
        }

        input AuthToken {
          accessToken: String
          guid: String
        }

        enum AutoAddEquipOfType {
          CATEGORY
          EQUIPMENT_TYPE
          CAT_CLASS
          JOBSITE
          PO
          RENTED_ON_THIS_ACCOUNT
        }

        type Branch {
          branchnumber: String
          branchname: String
          branchtype: String
          address: String
          streetAddress: String
          addresslatitude: String
          addresslongitude: String
          city: String
          state: String
          country: String
          zip: String
          phone: String
          branchimageurl: String
          branchcode: String
          timings: String
        }

        type BranchEquipmentDetailsResponse {
          equipmentGPSInfo: EquipmentGpsInfo
          equipmentMakeInfo: EquipmentMakeInfo
          rentalInfo: RentalInfo
          equipmentOperationalInfo: EquipmentOperationalInfo
          diagnostics: Diagnostics
          jobsite: JobSite
          branch: Branch
          equipmentBranchInfoResponse: EquipmentBranchInfoResponse
        }

        type BranchViewDTCResponse {
          totalCount: Int
          xactivationid: String
          diagnosticTroubleCode: [DiagnosticTroubleCode]
        }

        type BulkGeofenceOutput {
          geofenceId: [String]
          errorMessage: String
        }

        type Categories {
          categoryName: String
          equipmentList: [Equipments]
        }

        type CommandStatusResponse {
          manualCommandId: Int
          equipmentIC: String
          status: String
        }

        type CompanyUsersList {
          list: [List]
        }

        type CompanyUsersListMain {
          data: CompanyUsersListType
        }

        type CompanyUsersListType {
          companyUsersList: CompanyUsersList
        }

        type Content {
          id: String
          timeStamp: String
          alertType: String
          alertMessage: String
          alertTitle: String
        }

        type Contentt {
          alertGroup: String
          category: String
          title: String
          description: String
          equipmentIC: String
          isTriggeredOnWeekend: Boolean
          triggeredTime: String
          alertInfoMap: AlertInfoMap
        }

        type Contenttt {
          equipmentIC: String
          division: String
          jobName: String
          jobNumber: String
          jobLocation: String
        }

        type Contract {
          contractNumber: String
          poNumber: String
          startDate: String
          endDate: String
          rentalBranchCode: String
          rentalBranchDetails: RentalBranchDetails
        }

        type ContractRentalMan {
          contcustomerId: Int
          purchaseOrderNumber: String
          serviceLevel: String
          contractNumber: String
          startDate: String
          shiftDifferential: String
          orderedBy: String
          pickupDate: String
          estimatedReturnDate: String
          contractCreatedBy: String
          jobNumber: String
          contractCreatedDate: String
          contractModifiedDate: String
          deliveryInstructions: String
          isCustomerOwnedContract: Boolean
          rentalType: String
          contractSequence: String
        }

        input CreateLightTowerGroupInput {
          customerNumber: String
          divisionCode: String
          profileName: String
          recurrence: String
          startDate: String
          endDate: String
          onTime: String
          offTime: String
          isActive: Int
          equipmentIC: [String]
          timeZone: String
        }

        type Customer {
          customerId: Int
          custDivisionId: Int
          customerNumber: String
          name: String
          phoneNumber: String
          address: String
          jobSite: JobSite
          branchId: Int
          customerCreatedBy: String
          customerCreatedDate: String
          customerModifiedDate: String
          isPaying: Boolean
          narpContractNumber: Int
          narpParentCust: Int
        }

        input CustomerIdsAndDivisionCodesCombination {
          customerNumber: String
          divisionCode: String
        }

        input CustomerIdsAndDivisionCodesCombinations {
          customerNumber: String
          divisionCode: String
        }

        input CustomerIdsAndDivisionCodesCombinationsInput {
          customerNumber: String!
          divisionCode: String!
        }

        type DailySummary {
          date: String
          avgUtilization: Float
          avgMileage: Float
          avgHoursUsed: Float
        }

        type DashboardData {
          hubNumber: String
          hubReportingStatus: Int
          hubLastReportedDate: String
          groupName: String
          isActive: Int
          isAlert: Int
          hubBatteryVoltage: String
          hubTemperature: String
          hubHumidity: String
          equipmentsCount: Int
          tagsCount: Int
          currentTemperature: Float
          minThresholdInCelsius: Float
          maxThresholdInCelsius: Float
          equipmentDetails: [EquipmentDetailsDashboardData]
          tagDetails: [TagDetails]
          manualPhoneRecipient: [ManualRecipientPhoneList]
          manualEmailRecipient: [ManualRecipientEmailList]
          existingRecipient: [ExistingAppRecipients]
          note: String
        }

        type Data {
          profileId: Int
        }

        type Dataa {
          getSecondLevelCategoriesFromCatClass: [GetSecondLevelCategoriesFromCatClass]
        }

        type DeliveryImage {
          imageUri: String
          imageName: String
          photoTakenAt: String
          latLong: String
        }

        type DeviceInfo {
          batteryLifeRemaining: Int
          engineRPM: Float
          fuelEconomyAverage: Float
          hardBrakingCount: Int
          hardAccelarationCount: Int
          gpsunit: String
          gpsmake: String
          oilLevel: Int
          oilPressure: Float
          oilTemperature: Float
          coolantLevel: Float
          fuelRange: String
          seatBeltLatched: Boolean
          temperature: Float
          tirePressure: DeviceInfoTirePressure
          humidity: String
          ambientAirTemperature: String
        }

        type DeviceInfoTirePressure {
          tirePressureLF: Float
          tirePressureLR: Float
          tirePressureRF: Float
          tirePressureRR: Float
        }

        type DevicePeriodicMessage {
          equipmentID: String
          accountID: String
          contractNumber: String
          engineCoolantTemp: String
          engineHours: Float
          engineLoad: Float
          fuelConsumption: Float
          fuelLevel: Float
          coolantLevel: Float
          defLevel: Float
          dayOfUnused: Float
          gPSunit: Int
          heading: String
          oilLevel: Float
          name: String
          monthlymileage: Float
          hardBrakingCount: Int
          hardAccelarationCount: Int
          ignition: String
          lastTransmissionTime: String
          longitude: Float
          licensePlate: String
          latitude: Float
          healthStatus: String
          lastKnownLocation: String
          lastLocationDate: String
          fuelpercentage: Float
          lifetimeKMPerHour: Float
          tirePressure: Float
          engineIdleHours: Float
          hardBraking: Boolean
          hardaccelarations: Boolean
          batteryPercentage: Float
          temperature: Float
          oilPressure: Float
          oilTemperature: Float
          batteryLifeRemaining: Float
          idleTime: Float
          lowBatteryCondition: Float
          isVehicleinMotion: Boolean
          onOff: String
          fuelEconomyAverage: String
          fuelRange: String
          humidity: String
          ambientAirTemperature: String
          seatBeltLatched: Boolean
          seatBeltUnlatched: Boolean
          speed: Float
          engineRPM: Float
        }

        type DevicePeriodicMessages {
          ambientAirTemperature: Float
          batteryLifeRemaining: Float
          oilTemperature: Float
          oilPressure: Float
          seatbeltLatched: Boolean
          engineRPM: Float
          defLevel: Float
          fuelRange: Float
          temperature: Float
          humidity: String
          tirepressure: Tirepressure
        }

        type DeviceTokens {
          deviceToken: String
          platform: String
        }

        type DiagnosticTroubleCode {
          code: String
          description: String
          dateOfTrigger: String
        }

        type DiagnosticTroubleCodeResponse {
          totalCount: Int
          diagnosticTroubleCode: [DiagnosticTroubleCode]
        }

        type Diagnostics {
          devicePeriodicMessages: [DevicePeriodicMessages]
          equipment: [Equipment_BranchDetails]
        }

        type Driver {
          driverId: String
          firstName: String
          lastName: String
          phone: String
          truckType: String
          isHauler: Boolean
        }

        type DriverInfo {
          driverId: String
          firstName: String
          lastName: String
          phone: String
          truckType: String
          isHauler: Boolean
        }

        input EditLightTowerGroupInput {
          customerNumber: String
          divisionCode: String
          profileId: Int
          profileName: String
          recurrence: String
          timeZone: String
          startDate: String
          endDate: String
          onTime: String
          offTime: String
          isActive: Int
          equipmentIC: [String]
        }

        type EligibleEquipmentsData {
          eligibleEquipmentDetails: [MACeligibleEquipment]
        }

        type Equip {
          equipmentIC: String
          customName: String
          commerceEquipmentName: String
          powerState: Boolean
          coordinate: [String]
        }

        type EquipInfo {
          equipmentID: String
          accountID: String
          contractNumber: String
          pONumber: String
          startDate: String
          endDate: String
          rentalBranchCode: String
          registrationState: String
          batteryVoltage: Float
          branchCode: String
          catClass: String
          contractEndDate: String
          equipmentName: String
          customName: String
          reportingStatus: String
          description: String
          fuelType: String
          yearPurchase: Int
          vIN: String
          serial: String
          registrationEndDate: String
          modelofEquipment: String
          makeofEquipment: String
          modelYear: Int
          jobsiteName: String
          jobSiteID: Int
        }

        type EquipSummary {
          ##equipmentID: Int
          ##########################################################################################################################################################################################################################################################################################################################################################################errorMessage: String
          equpmentDetails: EquipInfo
          ##errorType: String
          devicePeriodicMessage: DevicePeriodicMessage
          alerts: String
          equipmentID: String
          excludeWeekend: Boolean
          jobsite: JobSite
          utilizationDetails: UtilizationDetails
          contractInfo: Contract
          equipmentMasterInfo: EquipmentCommerceData
          ##alerts: [Alerts]
          alertCount: Int
          equipmentOperatorInfo: EquipmentOperatorInfo
          equipmentImage: String
          deliveryImages: [Image]
        }

        type Equipment {
          equipmentName: String
          customEquipmentName: String
          icNumber: String
        }

        type EquipmentBranchInfoResponse {
          branchCode: String
          name: String
          address: String
          streetAddress: String
          city: String
          state: String
          zip: String
        }

        type EquipmentByBranchIDsResponse {
          totalElements: Int
          pageNumber: Int
          pageSize: Int
          totalPages: Int
          equipmentList: [EquipmentListResponse]
        }

        type EquipmentCategories {
          categoryName: String
          equipmentList: [equipmentDetailsMAC]
        }

        type EquipmentCategoryClass {
          equipmentCategoryClassId: Int
          equipCategory: Int
          catclass: Int
          equipCateDivisionId: Int
          category1: String
          as400Description: String
        }

        type EquipmentCommerceData {
          catClass: String
          equipmentCategory: [String]
          equipmentType: String
        }

        type EquipmentCustomName {
          customerNumber: String
          contractNumber: String
          equipmentIC: String
          customEquipmentName: String
          divisionCode: String
          errorMessage: String
          errorType: String
        }

        input EquipmentCustomNames {
          customerNumber: String!
          contractNumber: String
          equipmentIC: String!
          customEquipmentName: String!
          divisionCode: String!
        }

        type EquipmentDataInList {
          equipmentIC: String
          coordinates: [Float]
          equipmentName: String
          customEquipmentName: String
          fuelLevelPercentage: Float
          ignition: String
          alertCount: Int
          status: String
          equipmentImage: String
        }

        type EquipmentDataInListFilteredResponse {
          equipmentIC: String
          coordinates: [Float]
          equipmentName: String
          customEquipmentName: String
          fuelLevelPercentage: String
          ignition: Boolean
          alertCount: Int
          customerNumber: String
          jobName: String
          rentalmanCategory: String
          rentalmanClass: String
          contractNumber: String
          contractSequence: String
          rentalType: String
          equipmentImage: String
          commerceCategory: String
          commerceType: String
          equipmentMake: String
          equipmentModel: String
          gpsStatus: String
          branchNumber: String
        }

        type EquipmentDeliveryDetails {
          branchCode: String
          rentalAgreement: String
          equipmentIC: String
          catClass: String
          equipmentName: String
          equipmentCustomName: String
          jobSiteNumber: String
          status: String
          pickupType: String
          scheduledDateTime: String
          deliveryDateTime: String
          deliveryInstructions: String
          pickupDetails: PickupDetails
          driverInfo: DriverInfo
          equipmentInfo: EquipmentInfo
          servingBranch: ServingBranch
          description: String
          jobSite: JobSite
          pickupAddress: PickupAddress
        }

        type EquipmentDetails {
          equipmentIC: String
          equipmentName: String
          equipmentCustomName: String
          customerNumber: Int
          ignitionStatus: Boolean
          fuelLevel1: String
          fuelLevel2: String
          alertCount: Int
          engineCoolantTemp: Int
          jobSiteName: String
          coolantLevel: Int
          batteryVoltage: Float
          defLevel: Int
          equipmentImage: String
          rentalmanClass: String
          rentalmanCategory: String
        }

        type EquipmentDetailsDashboardData {
          equipmentName: String
          equipmentCustomName: String
          equipmentIdentifier: String
          make: String
          model: String
          fleetType: String
          jobName: String
          equipmentCategory: Int
          equipmentClass: Int
          equipmentImage: String
        }

        input EquipmentDetailsInput {
          equipmentIC: String
          deviceId: String
          make: String
          model: String
          catClass: String
          description: String
          branch: String
          currentStatus: String
          year: String
          raNumber: String
          jobNumber: String
          jobName: String
          jobLocation: String
          poNumber: String
          deliveryInstructions: String
          orderedBy: String
          estimatedReturnDate: String
          rentalStartDate: String
          lastReportedDateTime: String
          location: String
          threshold: String
          days: String
          makeModelYear: String
        }

        type EquipmentDetailsbyJobsiteNumber {
          equipmentIC: String
          equipmentName: String
          customEquipmentName: String
          customerNumber: String
          contractNumber: String
          rentalmanCategory: String
          rentalmanClass: String
          ignition: Boolean
          fuelLevelPercentage: String
          alertCount: Int
          jobName: String
          contractSequence: String
          rentalType: String
          coordinates: [String]
          equipmentImage: String
        }

        type EquipmentDiagnosticsAndSafety {
          deviceInfo: DeviceInfo
          equipment: [EquipmentInfoDiagnosticsAndSafety]
        }

        type EquipmentGpsInfo {
          equipmentGPSUnitSerialNumber: String
          equipmentGPSUnitMake: String
        }

        type EquipmentInfo {
          equipmentId: String
          equipmentNumber: String
          make: String
          model: String
          description: String
          serialNumber: String
          catClass: String
          quantity: Int
          condition: String
          deliveryImages: [DeliveryImage]
        }

        type EquipmentInfoDiagnosticsAndSafety {
          batteryVoltage: Float
          engineCoolantTemp: String
          engineLoad: Float
          fuelConsumption: Float
          fuelLevel: Float
          defLevel: Float
          oilLevel: Float
          Latitude: String
          Longitude: String
          ignition: Boolean
          name: String
          equipmentCustomName: String
          alertCount: Int
        }

        type EquipmentLTAndSchedulesList {
          equipmentIC: String
          customName: String
          commerceEquipmentName: String
          powerState: Boolean
          coordinate: Float
        }

        type EquipmentList {
          equipmentIC: String
          alertEquipmentConfig: [AlertEquipmentConfig]
        }

        input EquipmentListInput {
          equipmentIC: String
          alertEquipmentConfig: [AlertEquipmentConfigInput]
        }

        type EquipmentListResponse {
          equipmentIC: String
          equipmentName: String
          equipmentRentalStatus: String
          equipmentBranchNumber: String
          ignition: String
          fuelLevel: String
          city: String
          state: String
          equipmentCategory: String
          equipmentClass: String
          longitude: Float
          latitude: Float
          equipmentImage: String
        }

        type EquipmentListSchema {
          equipmentDetails: [EquipmentDataInListFilteredResponse]
          totalCount: Int
        }

        type EquipmentListbyJobsiteNumberResponse {
          totalCount: Int
          equipmentDetails: [EquipmentDetailsbyJobsiteNumber]
        }

        type EquipmentMac {
          equipmentName: String
          customEquipmentName: String
          equipmentIC: String
        }

        type EquipmentMakeInfo {
          equipmentMake: String
          equipmentModel: String
          equipmentMfgYear: String
          equipmentVinOrSerial: String
        }

        type EquipmentName {
          rentalManCategory: String
          rentalManClass: String
          commerceEquipmentName: String
          commerceType: String
          commerceCategory: [commerceCategoryOutput]
          description: String
          division: String
          errorMessage: String
          errorType: String
        }

        input EquipmentNames {
          rentalManCategory: String
          rentalManClass: String
          commerceEquipmentName: String
          description: String
          division: String
          commerceType: String
          commerceCategory: [commerceCategoryInput]
        }

        type EquipmentOperationalInfo {
          equipmentIC: String
          equipmentName: String
          ignition: String
          reportingStatus: String
        }

        type EquipmentOperatorInfo {
          equipmentID: String
          contractNumber: String
          operators: [Operator]
          previousOperators: [Operator]
        }

        type EquipmentRentalMan {
          equipmentId: Int
          divisionId: Int
          category: Int
          equipCatClass: Int
          assignedBranchId: Int
          currentBranchId: Int
          equipmentCustomerId: Int
          equipmentIdentifier: String
          serial: String
          isServiceVehicle: Boolean
          meterSeed: Float
          meterDate: String
          isMeterInHours: Boolean
          equipmentStatusId: Int
          equipmentFleetTypeId: Int
          make: String
          model: String
          year: Int
          acquiredDate: String
          lastMaintenanceDate: String
          warrantyExpirationDate: String
          cost: Float
          isDeleted: Boolean
          createdBy: String
          modifiedDate: String
          goal: Int
          engineType: String
          customMeterSeed: Int
          customSeedDate: String
          registrationExpiryDate: String
          registrationStateCode: String
          licensePlate: String
        }

        type EquipmentRentalManData {
          equipmentId: Int
          equipmentSummaryDto: EquipmentSummaryDto
        }

        type EquipmentStatusbyCategoryResponse {
          isAvailable: Boolean
        }

        type EquipmentSummaryDto {
          equipment: EquipmentRentalMan
          customer: Customer
          contract: ContractRentalMan
          equipmentCategoryClass: EquipmentCategoryClass
          deviceCurrentStatus: deviceCurrentStatus
        }

        type EquipmentSummaryForJobsite {
          equipment: EquipmentSummaryForJobsiteEquipment
          errorMessage: String
        }

        type EquipmentSummaryForJobsiteEquipment {
          ic: Int
          name: String
          customName: String
          latitude: Float
          longitude: Float
          ignition: String
          fuelLevel: Float
          alertCount: Int
          jobSite: String
        }

        type EquipmentUtilizationTimeline {
          reportDate: String
          ignitionStatus: Boolean
        }

        type EquipmentUtilizationWidget {
          avgUtilization: Float
          avgDailyHoursUsed: Float
        }

        type Equipment_BranchDetails {
          ignitionStatus: Boolean
          batteryVoltage: Float
          fuelLevel: Float
          fuelConsumption: Float
          oilLevel: Float
          engineLoad: Float
          engineHours: Float
          coolantLevel: Int
          engineCoolanttemp: String
          hardBrakingCount: Int
          hardAccelarationCount: Int
          gpsmake: String
          gpsunit: String
        }

        type Equipments {
          catClass: String
          icNumber: String
          hercEquipmentName: String
          hercCustomName: String
          rmContractStartDate: String
          rmContractEndDate: String
          imageUrl: String
          macSwitchState: String
          equipmentType: String
          jobName: String
          jobNumber: String
          jobLocation: String
        }

        type EquipmentsData {
          equipmentDetails: [EquipmentMac]
          errorMessage: String
        }

        type EquipmentsbyOperator {
          ic_number: String
          asset_id: String
          assignment_start_date: String
          assignment_end_date: String
          hercEquipmentName: String
          customEquipmenName: String
          account_number: String
          account_country: String
          admin_name: String
          admin_phone: String
          admin_email: String
        }

        type ExistingAppRecipients {
          firstName: String
          lastName: String
          email: String
          phoneNumber: String
        }

        input ExistingAppRecipientsInput {
          firstName: String
          lastName: String
          email: String
          phoneNumber: String
        }

        input ExistingRecipientEmail {
          firstName: String
          lastName: String
          email: AWSEmail
        }

        input ExportAlertsRequest {
          accountNumber: String
          accountName: String
          divisionCode: String
          manualRecipientEmailList: [ManualRecipientEmail]
          existingRecipientEmailList: [ExistingRecipientEmail]
          viewAlertsFilters: ViewAlertsFilters
        }

        type ExportAlertsResponse {
          divisionCode: String
          statusCode: Int
          message: String
        }

        type FetchEquipments {
          customerNumber: Int
          categories: [Categories]
        }

        input FleetAggregatedAlertsByAccountIdInput {
          customerNumber: String
          divisionCode: String
        }

        type FleetAggregatedAlertsResponse {
          alertGroup: String
          category: String
          title: String
          description: String
          equipmentIC: String
          isTriggeredOnWeekend: Boolean
          triggeredTime: String
        }

        type FleetAggregatedDeliveriesPickupsByAccountIDsResponse {
          totalCount: Int
          otgStatusResponses: [OtgStatusResponses]
        }

        input FleetAggregatedUtilizationViewByAccountIDsInput {
          startDate: String!
          endDate: String!
          excludeWeekends: Boolean
          customerIdsAndDivisionCodesCombinations: [CustomerIdsAndDivisionCodesCombinationsInput]!
        }

        type FleetAggregatedUtilizationViewByAccountIDsResponse {
          avgUtilization: Float
          avgDailyHoursUsed: Float
          errorMessage: String
        }

        input FleetAggregatedViewInput {
          divisionCode: String!
          customerNumber: String!
        }

        type FleetDiagnosticSchema {
          totalCount: Int
          equipmentDetails: [EquipmentDetails]
        }

        type FleetUtilizationDetails {
          avgUtilization: Float
          avgDailyHoursUsed: Float
          avgDailyMileage: Float
          avgDailyEngHours: Float
          dailySummary: [DailySummary]
        }

        type GeoFence {
          accountId: String
          active: Boolean
          autoAddEquipOfType: String
          autoAddEquipment: Boolean
          geofenceId: String
          name: String
          notes: String
          status: String
          totalEntrances: Int
          totalExits: Int
          equipmentCount: Int
          alertCount: Int
          divisionCode: String
          runningCount: Int
          shape: ShapeSchema
          equipmentsToAdd: [String]
          equipmentsToRemove: [String]
          autoAddEquipTypeValues: [String]
          alertPreference: AlertPreferenceGeofenceResponse
        }

        input GeoFenceInput {
          accountId: String
          active: Boolean
          divisionCode: String
          autoAddEquipOfType: AutoAddEquipOfType
          autoAddEquipment: Boolean
          name: String
          notes: String
          status: StatusType
          totalEntrances: Int
          totalExits: Int
          shape: ShapeInput
          autoAddEquipTypeValues: [String]
          equipmentsToAdd: [String]
          equipmentsToRemove: [String]
          alertPreference: AlertPreferenceGeofenceInput
        }

        type GeofenceSummery {
          engineHoursOff: Float
          engineHoursOn: Float
          entrances: Int
          exits: Int
          totalTimeInMins: Int
          totalTimeOutMins: Int
          utilizationPercentage: String
        }

        type GetAccountAutoAddEqStatusResponse {
          id: Int
          accountNumber: Int
          autoAddStatus: Int
          countryCode: String
        }

        type GetAssignmentDetailsById {
          assignmentName: String
          assignmentStartDate: String
          assignmentEndDate: String
          userMappings: UserMappings
          useRmEndDate: Boolean
          equipmentCategories: [EquipmentCategories]
        }

        type GetBranchUtilizationDetailsResponse {
          lastStart: String
          usageToday: Int
          utilizationPercentage: Float
          lastTransmissionDate: String
          usageLast5Weekdays: Int
          engineHours: Float
          engineidleHours: Int
          mileage: Int
        }

        type GetBranchUtilizationTimelineGraphResponse {
          reportDate: String
          ignitionStatus: Boolean
        }

        type GetEnabledEquipmentByOperator {
          access_token: String
          operator_id: String
          totalCount: String
          equipments: [EquipmentsbyOperator]
        }

        input GetJobsitedetailsbyEquipmentICsInput {
          equipmentIC: String!
          division: String!
        }

        type GetLTAndSchedulesListResponse {
          totalCount: String
          response: [LTAndSchedulesList]
        }

        type GetOperatorTab {
          totalCount: String
          operatorDetail: [OperatorTabDetail]
        }

        type GetSecondLevelCategoriesFromCatClass {
          cat_class: String
          equipment_name: String
          equipment_images: String
          equipment_type: String
          categories: [SecondLevelCategoriesFromCatClassCategories]
        }

        type GetTermsConditionsAcceptance {
          isAcceptanceTerms: Boolean
        }

        type Group {
          groupId: String
          groupName: String
          operatorCount: String
        }

        type GroupDetails {
          groupId: String
          groupName: String
          customerNumber: String
          mappedBy: AWSEmail
          operatorEmail: [AWSEmail]
        }

        type GroupProfileGraphData {
          computeDate: String
          temperature: Float
        }

        type GroupProfileLists {
          groupProfileId: String
          groupName: String
          noofEquipment: String
          noofTags: String
          isActive: String
          minThresholdInCelsius: String
          maxThresholdInCelsius: String
          hubName: String
        }

        type GroupResponse {
          totalCount: String
          groups: [Group]
        }

        type HttpStatus {
          statusCode: Int
          message: String
        }

        type HubDetailsResponse {
          hubId: String
          hubName: String
          lastReportedDate: String
          isSelected: Int
        }

        type Image {
          imageName: String
          imageUri: String
          latLong: String
          photoTakenAt: String
        }

        type JobSite {
          id: String
          jobNumber: String
          jobName: String
          jobAddr1: String
          jobAddr2: String
          jobCity: String
          jobLoc: String
          jobState: String
          jobZip: String
          jobPhone: String
          contactName: String
          addressLatitude: String
          addressLongitude: String
        }

        type JobSiteAndBranchDetails {
          jobName: String
          jobNumber: String
          jobLocation: String
          branchCode: String
          branchName: String
          branchAddress: String
          errorMessage: String
        }

        type JobSiteDetailsContent {
          jobNumber: String
          jobName: String
          equipmentCount: Int
          alertCount: Int
        }

        type JobSiteDetailsPaginatedResponse {
          totalElements: Int
          totalPages: Int
          last: Boolean
          size: Int
          number: Int
          numberOfElements: Int
          first: Boolean
          empty: Boolean
          sort: Sort
          pageable: Pageable
          content: [JobSiteDetailsContent]
        }

        type JobsiteDetailsByEquipmentICsResponse {
          totalElements: Int
          totalPages: Int
          last: Boolean
          size: Int
          number: Int
          numberOfElements: Int
          first: Boolean
          empty: Boolean
          sort: Sort
          pageable: Pageable
          content: [Contenttt]
        }

        type LTAndSchedulesList {
          catClass: String
          schedule: Schedule
          equipment: EquipmentLTAndSchedulesList
        }

        type LTFilterResponse {
          catClass: String
          powerAndScheduleData: PowerAndScheduleData
          equip: Equip
        }

        type LTPowerModalOffResponse {
          equipmentIC: String
          manualCommandID: Int
        }

        input LightTowerFilterInput {
          accountID: String!
          divisionCode: String!
          geofenceId: String!
          contractNumber: String!
          jobNumber: String!
          page: Int
          limit: Int
        }

        type LightTowerFilterResponse {
          totalCount: Int
          response: [LTFilterResponse]
        }

        type LightTowerGroup {
          profileId: Int
          profileName: String
          equipmentCount: Int
          startDate: String
          endDate: String
          currentlyOn: Boolean
          schedule: ScheduleList
        }

        type LightTowerGroupResponse {
          totalCount: Int
          response: [LightTowerGroup]
        }

        type LightTowerMultipleSchedule {
          catClass: String
          equipment: Equip
          scheduleList: [ScheduleListWithProfileID]
          totalCount: Int
        }

        type LightTowerSingleSchedule {
          catClass: String
          equipment: Equip
          schedule: ScheduleList
        }

        type List {
          email_id: String
          phone: String
          role_name: String
          name: String
        }

        type MACeligibleEquipment {
          equipmentIC: String
          assetId: String
          serial: String
          active: Boolean
        }

        type MacAssignmentResponse {
          httpStatus: Int
          message: String
        }

        input MacCreateAssignmentInput {
          customerNum: String!
          companyCode: String!
          assignmentName: String
          assignmentStartDate: String!
          assignmentEndDate: String!
          useRmEndDate: Boolean!
          mappedBy: String
          equipment: [String]
          allSelectedCategory: [String]
          userMappings: UserMappingsInput
        }

        type MacFetchAssignmentsByAccount {
          totalCount: String
          assignments: [Assignments]
        }

        type MacReportingResponse {
          s3Url: String
        }

        type MacToggle {
          macToggle: String
        }

        type MacToggleAccountAutoAddEqStatusResponse {
          statusCode: Int
          message: String
        }

        input MacUpdateAssignmentInput {
          assignmentId: String!
          customerNum: String!
          companyCode: String!
          assignmentName: String
          assignmentStartDate: String!
          assignmentEndDate: String!
          useRmEndDate: Boolean!
          mappedBy: String
          equipment: [String]
          allSelectedCategory: [String]
          userMappings: UserMappingsInput
        }

        input ManualRecepientEmailListsInput {
          name: String
          email: String
        }

        input ManualRecipientEmail {
          email: AWSEmail
        }

        type ManualRecipientEmailList {
          name: String
          email: String
        }

        input ManualRecipientEmailListInput {
          name: String
          email: String
        }

        type ManualRecipientPhoneList {
          name: String
          phoneNumber: String
        }

        input ManualRecipientPhoneListInput {
          name: String
          phoneNumber: String
        }

        input ManualRecipientPhoneListsInput {
          name: String
          phoneNumber: String
        }

        type Mutation {
          ToggleLTsInAGroup(
            profileId: Int,
            commandType: String,
            customerNumber: String,
            divisionCode: String
          ): [ToggleLTsInAGroupResponse]
          UpdateGroupProfileStatus(
            groupProfileId: Int,
            isActive: Int,
            accountNumber: String,
            userName: String
          ): UpdateGroupProfileStatusResponse
          MACOperatorRequestAccesstoEquipment(
            traceId: String,
            requestId: String,
            accountNumber: String,
            countryCode: String,
            icNumber: String,
            operatorEmail: AWSEmail,
            operatorName: String,
            adminEmail: AWSEmail
          ): HttpStatus
          LTPowerModalOff(
            commandType: String!,
            createdBy: String!,
            divisionCode: String!,
            equipmentICList: [String]!
          ): [LTPowerModalOffResponse]
          TMDeleteGroupProfile(
            accountNumber: String!,
            userName: String!,
            divisionCode: String!,
            groupProfileId: Int!
          ): TemperatureMonitoringGroupProfileResponse
          TMCreateGroupProfile(input: TemperatureMonitoringGroupProfileInput): TemperatureMonitoringGroupProfileResponse
          TMUpdateGroupProfile(input: TemperatureMonitoringGroupProfileInput): TemperatureMonitoringGroupProfileResponse
          ApplicationMacToggle(
            macAccountLevel: String!,
            customerNumber: String!,
            countryCode: String!,
            icNumber: String,
            macIcLevel: String
          ): ApplicationMacToggleResponse
          SaveCustomerToDeviceToken(
            userEmailId: AWSEmail!,
            deviceToken: String!,
            platform: String!,
            operationType: String!
          ): UserDeviceTokenRegistrationResponse
          DeleteCutomerDeviceToken(deviceToken: String!, operationType: String!): UserDeviceTokenRegistrationResponse
          ExportAlerts(input: ExportAlertsRequest): ExportAlertsResponse
          AddLTsToGroup(input: AddLTsToGroupInput): String
          EditLightTowerGroup(input: EditLightTowerGroupInput): String
          CreateLightTowerGroup(input: CreateLightTowerGroupInput): String
          createGroup(
            groupName: String!,
            customerNum: String!,
            mappedBy: AWSEmail!,
            countryCode: String!,
            operators: [AWSEmail]!
          ): HttpStatus
          saveOrUpdateGroup(
            groupId: String!,
            groupName: String!,
            customerNum: String!,
            mappedBy: AWSEmail!,
            countryCode: String!,
            operators: [AWSEmail]!
          ): HttpStatus
          deleteGroup(groupId: String!): HttpStatus
          SaveAlertPreference(input: AlertPreferenceInput): AlertPreferenceResponse
          addBulkGeofence(accountId: String!, divisionCode: String!, geofences: [GeoFenceInput]): BulkGeofenceOutput
          saveCustomEquipmentName(equipmentCustomNameRequestList: [EquipmentCustomNames]): [EquipmentCustomName]
          updateCustomEquipmentName(
            customerNumber: String!,
            equipmentIC: String!,
            customEquipmentName: String!,
            divisionCode: String!
          ): EquipmentCustomName
          addGeofence(input: GeoFenceInput!): GeoFence
          deleteGeofence(input: String!): String
          UpdateAlertPrefernce(input: UpdateAlertPreferenceInput): AlertPreferenceResponse
          updateGeofence(input: UpdateGeoFenceInput, geofenceId: String!): UpdateStatus
          DeleteLightTowerGroup(groupId: Int!): String
          DeleteLightTowerFromGroup(lightTowerId: String!, groupId: Int!): String
          CreateAssignment(input: MacCreateAssignmentInput): MacAssignmentResponse
          UpdateAssignment(input: MacUpdateAssignmentInput): MacAssignmentResponse
          DeleteAssignment(assignmentId: String!): MacAssignmentResponse
          addEquipmentToGeofence(geofenceId: String!, equipmentNumber: String!): String
          saveEquipmentName(equipmentCustomNameRequestList: [EquipmentNames]): [EquipmentName]
          DispatchAlert(input: AlertDispatcherInput): AlertDispatcherResponse
          DispatchEmail(input: AlertDispatcherInput): AlertDispatcherResponse
          DispatchSMS(input: SMSDispatcherInput): AlertDispatcherResponse
          CreateLTSchedule(input: ScheduleInput): ScheduleResponse
          EditLTSchedule(input: ScheduleInput, profileId: Int!): ScheduleResponse
          DeleteLTSchedule(profileId: Int): String
          DispatchAlert_BE(input: AlertDispatcherInput): AlertDispatcherResponse
        }

        type OTGEquipmentDetails {
          equipmentId: String
          equipmentNumber: String
          catClass: String
          quantity: String
          condition: String
          make: String
          model: String
          serialNumber: String
          equipmentIC: String
          equipmentName: String
          equipmentCustomName: String
          description: String
          equipmentImage: String
          alertCount: Int
          deliveryImages: [Image]
        }

        type Operator {
          name: String
          date: String
        }

        type OperatorAssignment {
          assignmentId: Int
          assignmentName: String
          assignmentStartDate: String
          assignmentEndDate: String
        }

        type OperatorAssignmentDetail {
          totalCount: String
          assignments: [OperatorAssignment]
        }

        type OperatorGroupDetail {
          groupId: Int
          groupName: String
        }

        type OperatorGroupDetailByEmail {
          totalCount: String
          groups: [OperatorGroupDetail]
        }

        type OperatorGroups {
          groupId: String
          groupName: String
        }

        type OperatorTabDetail {
          email: String
          groups: Int
          equipment: Int
        }

        type OtgDTO {
          branchCode: String
          contractNumber: String
          equipmentInfo: OTGEquipmentDetails
          status: String
          pickupType: String
          scheduledDateTime: String
          deliveryDateTime: String
          jobsite: JobSite
          pickupDetails: PickupDetails
          deliveryOrPickupNote: String
          driverInfo: Driver
          servingBranch: Branch
          contractSequence: String
          contractType: String
          returnedDateTime: String
        }

        type OtgStatusResponses {
          branchCode: String
          contractNumber: String
          equipmentIC: String
          catClass: String
          equipmentName: String
          equipmentCustomName: String
          jobSiteNumber: String
          status: String
          jobSite: JobSite
          pickupType: String
          scheduledDateTime: String
          deliveryDateTime: String
          equipmentImage: String
        }

        type Pageable {
          offset: Int
          pageNumber: Int
          pageSize: Int
          paged: Boolean
          unpaged: Boolean
          sort: Sort
        }

        type PickupAddress {
          pickupAddressInfo: String
          pickupAddresslatitude: String
          pickupAddresslongitude: String
          pickupPhone: String
          pickupContact: String
        }

        type PickupDetails {
          ticketNum: String
          contractNum: Int
          contractSeq: Int
          equipCatClass: String
          iCNumber: String
          comments: String
          releasedBy: String
          date: String
          time: String
          pickupStatus: String
        }

        type PowerAndScheduleData {
          activeSchedule: ActiveSchedule
        }

        input PrimaryUsers {
          email: String
          phoneNumber: String
        }

        type Query {
          GetBranchViewDTCCodes(
            equipmentIc: String,
            divisionCode: String,
            page: Int,
            pageSize: Int
          ): BranchViewDTCResponse
          MacReporting(reportType: String!, accountNumber: String!, countryCode: String!): MacReportingResponse
          GetBranchUtilizationDetails(
            equipmentIC: String,
            division: String,
            isWeekendExcluded: Boolean,
            startDate: String,
            endDate: String
          ): GetBranchUtilizationDetailsResponse
          GetBranchUtilizationTimelineGraph(
            equipmentIC: String,
            divisionCode: String,
            isWeekendExcluded: Boolean,
            startDate: String,
            endDate: String
          ): [GetBranchUtilizationTimelineGraphResponse]
          GetEmergencyKey: String
          AlertRedirectionByAlertId(alertId: String!): AlertRedirectionResponse
          getCompanyUsersList: CompanyUsersListMain
          UpdateTermsConditionsAcceptance: UpdateTermsConditionsAcceptanceMain
          getTermsConditionsAcceptance: TermsConditionsAcceptanceMain
          getequipmentStatusbyCategory(customerNumber: String, divisionCode: String, categories: [String]): EquipmentStatusbyCategoryResponse
          getMacEligibleEquipments(assignedDate: String): EligibleEquipmentsData
          GetEquipmentListbyJobsiteNumber(
            jobNumber: String!,
            divisionCode: String,
            customerNumber: String,
            page: Int,
            pageSize: Int
          ): EquipmentListbyJobsiteNumberResponse
          getSecondLevelCategoriesFromCatClass(equipments: [String]!): SecondLevelCategoriesFromCatClassResponse
          GetBranchEquipmentDetails(ic: String!, division: String!): BranchEquipmentDetailsResponse
          GetEquipmentByBranchIDs(page: Int, pageSize: Int, branches: [String]): EquipmentByBranchIDsResponse
          GetFleetUtilizationDetails(
            customerNumber: String!,
            division: String!,
            startDate: String!,
            endDate: String!,
            isWeekendExcluded: Boolean!,
            equipmentType: String,
            equipmentCategory: String
          ): FleetUtilizationDetails
          GetFleetAggregatedDeliveriesPickupsByAccountIDs(customerIdsAndDivisionCodesCombinations: [CustomerIdsAndDivisionCodesCombination], page: Int, pageSize: Int): FleetAggregatedDeliveriesPickupsByAccountIDsResponse
          FindAlertsByGeofence(startDate: String!, id: String!, endDate: String): [AlertsInGeofence]
          ValidatePhoneNumber(mobileNumber: String!, customerNumber: String, divisionCode: String): String
          GetMobileAuthorizationStatus(XMobileAuthMessageId: String!): String
          GetAccountAutoAddEqStatus(accountNumber: String!, countryCode: String!): GetAccountAutoAddEqStatusResponse
          MacToggleAccountAutoAddEqStatus(accountNumber: String!, countryCode: String!, autoAddStatus: String!): MacToggleAccountAutoAddEqStatusResponse
          GetScheduleDetailsbyProfileID(profileId: Int!): ScheduleDetailsbyProfileIdResponse
          GetCommandStatus(manualcommandid: [Int!]): [CommandStatusResponse]
          GetFleetAggregatedAlertsByAccountId(input: [FleetAggregatedAlertsByAccountIdInput]): [FleetAggregatedAlertsResponse]
          GetFleetAggregatedUtilizationViewByAccountIDs(input: FleetAggregatedUtilizationViewByAccountIDsInput): FleetAggregatedUtilizationViewByAccountIDsResponse
          GetJobsitedetailsbyEquipmentICs(input: [GetJobsitedetailsbyEquipmentICsInput], page: Int, pageSize: Int): JobsiteDetailsByEquipmentICsResponse
          FetchMacToggle(customerNumber: String!, companyCode: String!): MacToggle
          GetTemperatureMonitoringDetails(
            accountNumber: String!,
            divisionCode: String,
            page: Int!,
            pageSize: Int!
          ): TemperaturMonitoringDetails
          GetGroupProfileGraphData(groupProfileId: Int!, userName: String!, offsetMinutes: Int): [GroupProfileGraphData]
          GetDashboardData(groupProfileId: Int!, accountNumber: String!, divisionCode: String): [DashboardData]
          GetHubDetails(input: TemperatureMonitoringInput): [HubDetailsResponse]
          GetTagsforTemperatureMonitoring(input: TemperatureMonitoringInput): [TagsforTemperatureMonitoringResponse]
          GetEquipmentSummaryForJobsite(divisionCode: String!, accountId: String!, equipmentId: String!): EquipmentSummaryForJobsite
          getOperatorAssignmentDetailByEmail(
            currentPage: String,
            pageSize: String,
            customerNumber: String!,
            countryCode: String!,
            operatorEmail: AWSEmail!
          ): OperatorAssignmentDetail
          getOperatorGroupDetailByEmail(
            currentPage: String,
            pageSize: String,
            customerNumber: String!,
            countryCode: String!,
            operatorEmail: AWSEmail!
          ): OperatorGroupDetailByEmail
          getOperatorTabDetails(
            currentPage: String,
            pageSize: String,
            customerNumber: String!,
            countryCode: String!
          ): GetOperatorTab
          getAssignmentDetailsByIc(
            currentPage: String,
            pageSize: String,
            icNumber: String!,
            accountNumber: String!,
            countryCode: String
          ): OperatorAssignmentDetail
          getFleetDiagnosticsByAccountID(
            divisionCode: String!,
            customerNumber: String!,
            page: Int,
            pageSize: Int,
            equipmentCategory: String,
            equipmentType: String,
            useRmEndDate: Boolean
          ): FleetDiagnosticSchema
          getFleetAggregatedView(input: [FleetAggregatedViewInput], page: Int!, pageSize: Int!): fleetAggregatedView
          getDeviceLocationHistory(
            customerNumber: String!,
            equipmentIC: String!,
            divisionCode: String!,
            startDate: String!,
            endDate: String!,
            isWeekendExcluded: Boolean,
            maxResults: Int,
            nextToken: String
          ): deviceLocationHistorySchems
          getLTAndSchedulesList(
            accountID: String!,
            divisionCode: String!,
            profileId: Int!,
            page: Int,
            pageSize: Int
          ): GetLTAndSchedulesListResponse
          getEquipmentSummaryFromRentalMan(equipmentIC: String!, accountId: String!, divisionCode: String): EquipmentRentalManData
          getEnabledEquipmentByOperator(currentPage: String!, pageSize: String!, operatorEmail: AWSEmail!): GetEnabledEquipmentByOperator
          getFetchEquipments(customerNum: String!, companyCode: String!): FetchEquipments
          getJobSiteDetailsbyAccountID(
            divisionCode: String!,
            accountId: String!,
            page: Int,
            pageSize: Int
          ): JobSiteDetailsPaginatedResponse
          getGroupById(groupId: String!): GroupDetails
          getGroupByAccount(
            currentPage: String!,
            pageSize: String!,
            customerNum: String!,
            countryCode: String!
          ): GroupResponse
          GetFleetUtilization(
            customerNumber: String!,
            divisionCode: String!,
            startDate: String!,
            endDate: String!,
            isWeekendExcluded: Boolean!
          ): EquipmentUtilizationWidget
          getEquipmentsInGeofence(id: String!, pageSize: Int, page: Int): [EquipmentDataInList]
          getEquipmentsInAccount(
            customerNumber: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int,
            equipmentCategory: String,
            equipmentType: String,
            equipmentBranch: Int
          ): EquipmentListSchema
          GetEquipmentUtilizationTimeline(
            customerNumber: String!,
            equipmentIC: String!,
            divisionCode: String!,
            startDate: String!,
            endDate: String!,
            isWeekendExcluded: Boolean!
          ): [EquipmentUtilizationTimeline]
          getEquipmentStatusAndInfo(
            accountId: String!,
            customerId: String,
            divisionCode: String!,
            contractNumber: String!,
            equipmentIC: String!
          ): EquipmentDeliveryDetails
          getEquipmentDiagnosticsAndSafety(customerNumber: String!, ic: String!, divisionCode: String!): EquipmentDiagnosticsAndSafety
          getAlertsByAccountId(customerNumber: String!, ic: String!): AlertResponse
          getGeofenceById(geofenceId: String!): GeoFence
          getGeofenceByAccount(
            accountId: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int
          ): getGeofenceByAccountResponse
          getAllDeliveryPickups(
            accountId: String!,
            token: String!,
            pickupType: String!,
            page: Int,
            pageSize: Int,
            divisionCode: String
          ): [OtgDTO]
          getDeliveryPickUpDetails(
            contractNumber: String!,
            equipmentIc: String!,
            accountId: String!,
            token: String!
          ): OtgDTO
          getRouteUpdates(contractNumber: String!, equipmentIc: String!, token: String!): RouteInfo
          getEquipmentSummary(
            equipmentId: String!,
            contractId: String!,
            accountId: String!,
            token: String!
          ): EquipSummary
          getEquipmentUtilizationDetails(
            customerNumber: String!,
            equipmentIC: String!,
            divisionCode: String!,
            startDate: String!,
            endDate: String!,
            isWeekendExcluded: Boolean
          ): UtilizationDetails
          GetAlertPreferenceById(id: String!): AlertPreferenceById
          getDiagnosticTroubleCode(
            customerNumber: String,
            equipmentIc: String,
            divisionCode: String,
            page: Int,
            pageSize: Int
          ): DiagnosticTroubleCodeResponse
          GetAlertPreferenceByAccountNumberandAlertCategory(divisionCode: String!, accountNumber: String!, alertCategory: String!): AlertPreferenceById
          GetAlertPreferenceByAccountNumberandAlertCategory_BE(divisionCode: String!, accountNumber: String!, alertCategory: String!): AlertPreferenceById
          GetViewAlertsByAccountID(
            customerNumber: String!,
            divisionCode: String!,
            startDate: String,
            endDate: String,
            page: Int,
            groups: String,
            isWeekendInclusive: Boolean,
            pageSize: Int
          ): ViewAlertsByAccountIDResponse
          GetMacEquipments(equipmentIC: [String]!, customerNumber: String!, divisionCode: String!): EquipmentsData
          GetSingleLightTowerbyAccountId(
            accountID: String,
            divisionCode: String,
            geofenceId: String,
            contractNumber: String,
            jobNumber: String,
            page: Int!,
            pageSize: Int!
          ): SingleLightTowerResponse
          getAssignmentsByAccount(
            currentPage: String,
            pageSize: String,
            customerNumber: String,
            countryCode: String
          ): MacFetchAssignmentsByAccount
          getAssignmentDetailsbyId(assignmentId: String!): GetAssignmentDetailsById
          getSingleLTScheduleByEquipmentId(accountID: String!, equipmentIC: String!, divisionCode: String!): LightTowerSingleSchedule
          getLTMultipleSchedule(
            accountID: String!,
            equipmentIC: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int
          ): LightTowerMultipleSchedule
          getGeofenceSummery(geofenceID: String!, startDate: String!, endDate: String!): GeofenceSummery
          getAllLightTowerGroups(
            customerNumber: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int
          ): LightTowerGroupResponse
          RetrieveUserDeviceTokens(userEmailIds: [AWSEmail!]): RetrieveUserToken
          GetLightTowerFilter(input: LightTowerFilterInput): LightTowerFilterResponse
          getFetchEquipments_AM(customerNum: String!, companyCode: String!): FetchEquipments
          getFetchEquipments_FMAC(customerNum: String!, companyCode: String!): FetchEquipments
          getGeofenceByAccount_FGF(
            accountId: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int
          ): getGeofenceByAccountResponse
          getGeofenceByAccount_FLT(
            accountId: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int
          ): getGeofenceByAccountResponse
          getEquipmentsInAccount_FV(
            customerNumber: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int,
            equipmentCategory: String,
            equipmentType: String,
            equipmentBranch: Int
          ): EquipmentListSchema
          getEquipmentsInAccount_FL(
            customerNumber: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int,
            equipmentCategory: String,
            equipmentType: String,
            equipmentBranch: Int
          ): EquipmentListSchema
          getEquipmentsInAccount_FGF(
            customerNumber: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int,
            equipmentCategory: String,
            equipmentType: String,
            equipmentBranch: Int
          ): EquipmentListSchema
          getEquipmentsInAccount_FLT(
            customerNumber: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int,
            equipmentCategory: String,
            equipmentType: String,
            equipmentBranch: Int
          ): EquipmentListSchema
          getEquipmentsInAccount_FTM(
            customerNumber: String!,
            divisionCode: String!,
            page: Int,
            pageSize: Int,
            equipmentCategory: String,
            equipmentType: String,
            equipmentBranch: Int
          ): EquipmentListSchema
          getEquipmentSummaryFromRentalMan_FV(equipmentIC: String!, accountId: String!, divisionCode: String): EquipmentRentalManData
          getEquipmentSummaryFromRentalMan_FL(equipmentIC: String!, accountId: String!, divisionCode: String): EquipmentRentalManData
          getEquipmentStatusAndInfo_FV(
            accountId: String!,
            customerId: String,
            divisionCode: String!,
            contractNumber: String!,
            equipmentIC: String!,
            contractSequence: String!,
            contractType: String!
          ): EquipmentDeliveryDetails
          getEquipmentStatusAndInfo_FL(
            accountId: String!,
            customerId: String,
            divisionCode: String!,
            contractNumber: String!,
            equipmentIC: String!,
            contractSequence: String!,
            contractType: String!
          ): EquipmentDeliveryDetails
          GetMacEquipments_FMAC(icNumber: [String]!, customerNumber: String!, divisionCode: String!): EquipmentsData
          GetMacEquipments_FV(icNumber: [String]!, customerNumber: String!, divisionCode: String!): EquipmentsData
        }

        input RecipientsDetailsInput {
          type: String
          recipientCategory: String
          firstName: String
          lastName: String
          emailId: String
          phoneNumber: String
          preferredNotificationType: [String]
          primaryUsers: [PrimaryUsers]
          secondaryUser: [SecondaryUsers]
        }

        type RentalBranchDetails {
          branchname: String
          addressline1: String
          city: String
          state: String
          zip: String
          phone: String
        }

        type RentalInfo {
          equipmentRentalStatus: String
          accountNumber: String
          accountName: String
          contractNumber: String
          jobsiteName: String
          jobsiteNumber: String
        }

        type RetrieveUserToken {
          statusCode: Int
          usersDeviceTokens: [UsersDeviceTokens]
        }

        type RouteCoordinates {
          latitude: Float
          longitude: Float
        }

        type RouteInfo {
          contractNumber: String
          driverId: String
          equipmentIc: String
          eta: String
          routeUpdates: [RouteCoordinates]
        }

        input SMSAlertNotificationDetailsInput {
          category: String
          subCategory: String
          alertInfoMap: [AlertInfoMapInput]
        }

        input SMSDispatcherInput {
          source: String
          division: String
          recipientsDetails: [RecipientsDetailsInput]
          alertOrNotificationDetails: SMSAlertNotificationDetailsInput
        }

        type Schedule {
          activeState: Boolean
          timeZone: String
        }

        type ScheduleDetailsbyProfileIdResponse {
          activeState: Boolean
          onTime: String
          offTime: String
          startDate: String
          endDate: String
          recurrence: String
          mobileNumber: String
          timeZone: String
          mobileAuthEnabled: Boolean
        }

        input ScheduleInput {
          customerNumber: String!
          divisionCode: String!
          recurrence: String!
          timeZone: String!
          startDate: String!
          endDate: String!
          onTime: String!
          offTime: String!
          isActive: Int
          equipmentIC: [String]!
          mobileNumber: String
        }

        type ScheduleList {
          activeState: Boolean
          startTime: String
          endTime: String
          daysOfWeek: String
          timeZone: String
          startDate: String
          endDate: String
        }

        type ScheduleListSingleLT {
          activeState: Boolean
          profileID: Int
          timeZone: String
        }

        type ScheduleListWithProfileID {
          activeState: Boolean
          startTime: String
          endTime: String
          daysOfWeek: String
          profileID: Int
          timeZone: String
          mobileAuthEnabled: Boolean
          startDate: String
          endDate: String
        }

        type ScheduleResponse {
          message: String
          data: Data
        }

        type SecondLevelCategoriesFromCatClassCategories {
          category_name: String
        }

        type SecondLevelCategoriesFromCatClassResponse {
          data: Dataa
        }

        input SecondaryUsers {
          email: String
          phoneNumber: String
        }

        type ServingBranch {
          address: String
          addressLatitude: String
          addressLongitude: String
          branchName: String
          branchNumber: String
          branchType: String
          city: String
          country: String
          phone: String
          state: String
          zip: String
          image: String
        }

        input ShapeInput {
          shapeType: ShapeType
          radius: Float
          coordinate: [[[Float]]]
        }

        type ShapeSchema {
          shapeType: ShapeType
          radius: Float
          coordinate: [[[Float]]]
        }

        enum ShapeType {
          CIRCLE
          POLYGON
          RECTANGLE
        }

        type SingleLightTower {
          catClass: String
          equip: Equip
          powerAndScheduleData: PowerAndScheduleData
        }

        type SingleLightTowerResponse {
          totalCount: Int
          response: [SingleLightTower]
        }

        type Sort {
          empty: Boolean
          sorted: Boolean
          unsorted: Boolean
        }

        enum StatusType {
          REGISTERING
          READY
          ERROR
        }

        type TagDetails {
          lastReportedDate: String
          tagTemperature: Float
          tagReportingStatus: Int
          tagName: String
          tagId: String
          humidity: Float
        }

        type TagsforTemperatureMonitoringResponse {
          tagId: String
          tagName: String
          lastReportedDate: String
          isSelected: Int
        }

        type TemperaturMonitoringDetails {
          totalcount: Int
          groupProfileLists: [GroupProfileLists]
        }

        input TemperatureMonitoringGroupProfileInput {
          groupProfileId: Int
          isAlert: Int
          groupName: String
          hubId: String
          isActive: Int
          userName: String
          minThresholdInCelsius: Float
          maxThresholdInCelsius: Float
          notes: String
          accountNumber: String
          divisionCode: String
          manualRecipientPhoneLists: [ManualRecipientPhoneListsInput]
          manualRecipientEmailLists: [ManualRecepientEmailListsInput]
          existingAppRecipients: [ExistingAppRecipientsInput]
          tagId: [String]
          equipmentIC: [String]
        }

        type TemperatureMonitoringGroupProfileResponse {
          message: String
          status: String
        }

        input TemperatureMonitoringInput {
          groupProfileId: Int!
          userName: String!
        }

        type TermsConditionsAcceptance {
          getTermsConditionsAcceptance: GetTermsConditionsAcceptance
        }

        type TermsConditionsAcceptanceMain {
          data: TermsConditionsAcceptance
        }

        type TermsConditionsAcceptanceUpdate {
          isAcceptanceTerms: Boolean
        }

        type Tirepressure {
          tirePressureLF: Int
          tirePressureLR: Int
          tirePressureRF: Int
          tirePressureRR: Int
        }

        type ToggleLTsInAGroupResponse {
          equipmentIC: String
          manualCommandID: Int
        }

        input UpdateAlertPreferenceInput {
          operationType: String
          divisionCode: String
          id: String
          isActive: Boolean
          accountNumber: String
          alertCategory: String
          applyToAllEquipment: Boolean
          alertTriggerType: String
          manualRecipientPhoneList: [ManualRecipientPhoneListInput]
          manualRecipientEmailList: [ManualRecipientEmailListInput]
          existingAppRecipients: [ExistingAppRecipientsInput]
          alertTriggerTiming: [String]
          deliveryMode: [String]
          equipmentList: [EquipmentListInput]
          allEquipmentConfig: [AllEquipmentConfigInput]
        }

        input UpdateGeoFenceInput {
          divisionCode: String
          equipmentsToAdd: [String]
          equipmentsToRemove: [String]
          name: String
          shape: ShapeInput
          accountId: String
        }

        type UpdateGroupProfileStatusResponse {
          message: String
          status: String
        }

        type UpdateStatus {
          geofenceId: String
          accountId: String
          active: Boolean
          autoAddEquipOfType: String
          autoAddEquipment: Boolean
          name: String
          notes: String
          status: StatusType
          totalEntrances: Int
          totalExits: Int
          shape: ShapeSchema
          autoAddEquipTypeValues: [String]
          equipmentsToRemove: [String]
          equipmentsToAdd: [String]
          divisionCode: String
        }

        type UpdateTermsConditionsAcceptance {
          updateTermsConditionsAcceptance: TermsConditionsAcceptanceUpdate
        }

        type UpdateTermsConditionsAcceptanceMain {
          data: UpdateTermsConditionsAcceptance
        }

        type UserDeviceTokenRegistrationResponse {
          message: String
          statusCode: Int
        }

        type UserMappings {
          operatorGroups: [OperatorGroups]
          operatorEmails: [String]
        }

        input UserMappingsInput {
          operatorGroups: [String]
          operatorEmails: [String]
        }

        type UsersDeviceTokens {
          userEmailId: String
          deviceTokens: [DeviceTokens]
        }

        type UtilizationByDay {
          date: String
          avgUtilization: Float
        }

        type UtilizationDetails {
          lastStart: String
          usageToday: Float
          utilizationPercentage: Float
          lastTransmissionDate: String
          usageLast5Weekdays: Float
          engineHours: Float
          engineidleHours: Float
          mileage: Float
          ignitionStatus: Boolean
        }

        type ViewAlerts {
          id: String
          timeStamp: String
          alertType: String
          alertTitle: String
          alertMessage: String
        }

        type ViewAlertsByAccountIDResponse {
          customerNumber: String
          divisionCode: String
          alertList: AlertList
        }

        input ViewAlertsFilters {
          startDate: String
          endDate: String
          isExcludeWeekends: Boolean
          filterByAlertType: [String]
        }

        type ViewAlertsResponse {
          accountNumber: String
          totalElements: Int
          pageNumber: Int
          pagesize: Int
          totalPages: Int
          equipments: [ViewEquipments]
        }

        type ViewEquipments {
          equipmentIC: String
          sku: String
          url_key: String
          alerts: [ViewAlerts]
        }

        input commerceCategoryInput {
          label: String
          id: String
        }

        type commerceCategoryOutput {
          label: String
          id: String
        }

        type deviceCurrentStatus {
          deviceId: String
          heading: String
          reportDate: String
          locationDate: String
          gpsStatus: Int
        }

        type deviceLocationHistoryList {
          time: String
          odometerReading: Float
          latitude: Float
          longitude: Float
          eventName: String
          speed: Int
        }

        type deviceLocationHistorySchems {
          deviceHistory: [deviceLocationHistoryList]
          totalCount: Int
          nextToken: String
        }

        type devicePeriodicMessagesSchema {
          defLevel: Float
        }

        type equipmentDetailsMAC {
          icNumber: String
          customEquipmentName: String
          hercEquipmentName: String
          imageUrl: String
        }

        type equipmentSchema {
          equipmentIdentifier: String
          equipmentName: String
          equipmentCustomName: String
          accountID: String
          ignitionStatus: Boolean
          fuelLevel: Float
          engineCoolantTemp: Float
          coolantLevel: Float
          batteryVoltage: Float
          totalCount: Int
        }

        type fleetAggregatedView {
          content: [fleetAggregatedViewEachObject]
          pageable: pageableSchema
          totalElements: Int
          totalPages: Int
          last: Boolean
          size: Int
          number: Int
          sort: sortSchema
          numberOfElements: Int
          first: Boolean
          empty: Boolean
          errorMessage: String
        }

        type fleetAggregatedViewEachObject {
          equipmentIdentifier: String
          customerNumber: String
          name: String
          customName: String
          ignitionStatus: Boolean
          accountName: String
          equipmentName: String
          equipmentCustomName: String
          fuelLevel: Int
          alertCount: Int
          latitude: Float
          longitude: Float
          jobName: String
          equipmentImage: String
          rentalmanCategory: String
          rentalmanClass: String
        }

        type getGeofenceByAccountResponse {
          totalCount: Int
          response: [GeoFence]
        }

        type pageableSchema {
          sort: sortSchema
          offset: Int
          pageNumber: Int
          pageSize: Int
          paged: Boolean
          unpaged: Boolean
        }

        enum pickupTypeEnum {
          FROM_BRANCH
          FROM_CUSTOMER
        }

        schema {
          query: Query
          mutation: Mutation
        }

        type sortSchema {
          empty: Boolean
          sorted: Boolean
          unsorted: Boolean
        }

#-----------------------------------------------------------------------------
# Outputs-----Outputs---Outputs---Outputs
#-----------------------------------------------------------------------------

Outputs:
  GraphQLApiARN:
    Description: The Api ARN of the GraphQL endpoint.
    Value: !Ref GraphQLApi
  GraphQLApiId:
    Description: The Api ID of the GraphQL endpoint.
    Value: !GetAtt GraphQLApi.ApiId
#   GraphQLApiEndpoint:
#     Description: The URL for the GraphQL endpoint.
#     Value: !GetAtt GraphQLApi.GraphQLUrl


